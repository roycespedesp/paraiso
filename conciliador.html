<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conciliador Bancario v2.2.0</title>
    <!--
    
    ████████████████████████████████████████████████████████████████
    █                                                              █
    █     🏦 CONCILIADOR BANCARIO PARAÍSO v2.2.0                  █
    █     📅 Actualizado: 02/01/2025 - 15:30 UTC                  █
    █     🚀 VERSIÓN FINAL CON FUNCIONALIDADES COMPLETAS          █
    █                                                              █
    █     ✅ (+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS     █
    █     ✅ (+) CARGO EN BANCOS NO REGISTRADO EN LIBROS          █
    █     ✅ Filtros: Estado Pendiente + Criterios de Importe     █
    █     ✅ Soporte para todos los bancos                        █
    █                                                              █
    ████████████████████████████████████████████████████████████████
    
    -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Cache buster v2 -->
    
<!-- CDN Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/preline@2.0.3/dist/preline.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            important: '.conciliador-bancario-app',
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Conciliador Bancario - Estilos aislados para WordPress */
        .conciliador-bancario-app [x-cloak] { display: none !important; }
        .conciliador-bancario-app .file-input-area {
            transition: all 0.2s ease !important;
        }
        .conciliador-bancario-app .file-input-area:hover {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        .conciliador-bancario-app .file-input-area.has-file {
            border-color: #10b981 !important;
            background-color: #ecfdf5 !important;
        }
        
        /* Reset de estilos WordPress que podrían interferir */
        .conciliador-bancario-app * {
            box-sizing: border-box !important;
        }
        
        .conciliador-bancario-app {
            line-height: 1.5 !important;
            font-family: 'Inter', ui-sans-serif, system-ui, sans-serif !important;
            min-height: 100vh !important;
            isolation: isolate !important;
        }
        
        /* Prevenir que los estilos de WordPress afecten los botones y formularios */
        .conciliador-bancario-app button,
        .conciliador-bancario-app input,
        .conciliador-bancario-app select,
        .conciliador-bancario-app textarea {
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
        }
        
        /* Espaciado específico para la lista de archivos */
        .conciliador-bancario-app .space-y-1 > * + * {
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .file-item {
            padding: 0.5rem !important;
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .space-y-1 {
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .space-y-1 > *:first-child {
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app .files-container {
            display: flex !important;
            flex-direction: column !important;
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .files-container .file-item {
            margin: 0 !important;
        }
        
        /* Reset de margin-bottom de párrafos que causa el espaciado extra */
        .conciliador-bancario-app .files-container p {
            margin-bottom: 0 !important;
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app p {
            margin-bottom: 0 !important;
        }
    </style>
</head>

<body>
<div class="conciliador-bancario-app bg-gray-50" x-data="bancarioConciliador()">
    <!-- Header -->
    <div class="max-w-none mx-auto px-4 py-8" style="max-width: 1200px;">
        <h1 class="text-3xl font-bold text-gray-900 mb-2">Conciliador Bancario</h1>
        
        <!-- Version Badge -->
        <div class="flex items-center gap-3 mb-6">
            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                🏦 v2.2.0 - Final Release
            </span>
            <span class="inline-flex items-center px-2 py-1 rounded text-xs font-mono bg-blue-50 text-blue-700 border border-blue-200">
                📅 02/01/2025 15:30 UTC
            </span>
            <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-purple-50 text-purple-700 border border-purple-200">
                🚀 Funcionalidades Completas
            </span>
        </div>

        <!-- Upload Area - Layout Compacto -->
        <div class="mb-8">
            <div class="grid grid-cols-12 gap-6">
                
                <!-- 30% Izquierda: Área de Drag & Drop -->
                <div class="col-span-4">
            <div class="border-2 border-dashed border-gray-300 rounded-lg bg-white hover:border-gray-400 transition-colors duration-200 cursor-pointer"
                         style="height: 150px;"
                 :class="{ 'border-blue-500 bg-blue-50': isDragOver }"
                 @dragover.prevent="isDragOver = true"
                 @dragleave.prevent="isDragOver = false"
                 @drop.prevent="handleDrop($event)"
                 @click="$refs.fileInput.click()">
                
                        <div class="p-6 text-center h-full flex flex-col justify-center">
                    <input type="file" 
                           x-ref="fileInput" 
                           multiple 
                           accept=".xlsx,.xls,.csv,.txt"
                           @change="handleFileSelect($event)"
                           class="hidden">
                    
                            <div class="mx-auto h-10 w-10 text-gray-400 mb-3">
                                <i class="fas fa-cloud-upload-alt text-3xl"></i>
                    </div>

                            <div class="text-lg text-gray-900 font-medium mb-3">
                                Arrastra archivos aquí
                            </div>
                            
                            <p class="text-xs text-blue-600 mt-3" x-show="files.length > 0">
                        <i class="fas fa-info-circle mr-1"></i>
                                Auto-guardado activado
                    </p>
                                    </div>
                                </div>
                                
                                <!-- Inputs Manuales para DET, BN y Tipo de Cambio -->
                                <div x-show="files.length > 0" class="mt-4 space-y-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                    <h4 class="text-sm font-medium text-yellow-800">Datos Requeridos</h4>
                                    <div class="grid grid-cols-1 gap-3">
                                        <div>
                                            <label class="block text-xs font-medium text-gray-700 mb-1">Saldo DET (S/)</label>
                                            <input type="number" 
                                                   x-model="saldoDET" 
                                                   step="0.01" 
                                                   placeholder="0.00"
                                                   class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div>
                                            <label class="block text-xs font-medium text-gray-700 mb-1">Saldo BN (S/)</label>
                                            <input type="number" 
                                                   x-model="saldoBN" 
                                                   step="0.01" 
                                                   placeholder="0.00"
                                                   class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div>
                                            <label class="block text-xs font-medium text-gray-700 mb-1">Tipo de Cambio</label>
                                            <input type="number" 
                                                   x-model="tipoCambio" 
                                                   step="0.0001" 
                                                   placeholder="3.7500"
                                                   class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div>
                                            <label class="block text-xs font-medium text-gray-700 mb-1">Mes/Año para TARJETAS</label>
                                            <input type="month" 
                                                   x-model="mesAnoTarjetas" 
                                                   class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                    </div>
                                    
                                    <!-- Botón para limpiar solo cache de datos manuales -->
                                    <div class="flex justify-end mt-2">
                                        <button @click="limpiarCacheDatosManuales(); saldoDET = 0; saldoBN = 0; tipoCambio = 3.75; mesAnoTarjetas = '';"
                                                class="text-xs text-gray-500 hover:text-gray-700 underline"
                                                title="Limpiar valores guardados y resetear a defaults">
                                            Resetear valores
                                        </button>
                                    </div>
                                </div>

                                <!-- Botones de Conciliación debajo del drag and drop -->
                                <div class="mt-4 space-y-3">
                                    <button x-show="canProcessConciliation()"
                                            @click="realizarConciliacion()"
                                            :disabled="!validarDatosRequeridos()"
                                            class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200 shadow-sm disabled:bg-gray-400 disabled:cursor-not-allowed">
                                        <i class="fas fa-balance-scale mr-2"></i>
                                        Iniciar
                                    </button>
                                    
                                    <button x-show="!canProcessConciliation() && files.length > 0"
                                            disabled
                                            class="w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-400 bg-gray-100 cursor-not-allowed">
                                        <i class="fas fa-exclamation-triangle mr-2"></i>
                                        <span x-text="getMissingFilesMessage()"></span>
                                    </button>
                                    
                                    <button @click="limpiarArchivos()"
                                            class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200 shadow-sm">
                                        <i class="fas fa-trash mr-2"></i>
                                        Limpiar
                                    </button>
                                    

                                </div>
                            </div>

                <!-- 70% Derecha: Lista de Archivos -->
                <div class="col-span-8">
                    <div class="bg-white rounded-lg border border-gray-200 p-6" 
                         :style="`min-height: 150px; height: ${files.length > 0 ? 'auto' : '150px'};`">
                        
                        <!-- Lista de Archivos -->
                        <div x-show="files.length > 0" x-cloak class="h-full flex flex-col">
                            <h3 class="text-lg font-semibold text-gray-900 mb-4">
                                <i class="fas fa-list mr-2 text-blue-600"></i>
                                Archivos cargados (<span x-text="files.length"></span>)
                            </h3>
                            
                            <div class="grid grid-cols-3 gap-2 flex-1 overflow-y-auto">
                <template x-for="file in files" :key="file.id">
                                    <div class="file-item flex items-center p-2 bg-gray-50 border border-gray-200 rounded-lg hover:bg-gray-100 transition-colors duration-200 h-fit">
                        
                                        <div class="flex-shrink-0 w-5 h-5 rounded flex items-center justify-center mr-2 text-sm text-gray-600">
                            <i :class="getFileIcon(file.name)"></i>
    </div>

                        <div class="flex-grow min-w-0">
                            <p class="text-sm font-medium text-gray-900 truncate" x-text="file.name"></p>
    </div>

                        <button @click="deleteFile(file.id)"
                                                class="flex-shrink-0 text-red-500 hover:text-red-700 text-xs ml-1">
                                            <i class="fas fa-times"></i>
                            </button>
            </div>
                </template>
                            </div>
        </div>
                        
                        <!-- Mensaje cuando no hay archivos -->
                        <div x-show="files.length === 0" x-cloak class="h-full flex flex-col items-center justify-center text-center">
                            <div class="text-gray-400 mb-3">
                                <i class="fas fa-file-upload text-4xl"></i>
                            </div>
                            <p class="text-gray-500 text-lg font-medium mb-2">No hay archivos cargados</p>
                            <p class="text-gray-400 text-sm">Arrastra archivos al área de la izquierda para comenzar</p>
                        </div>
                        
                    </div>
                </div>
                
            </div>
        </div>



        <!-- Loading Spinner -->
        <div x-show="isLoading" x-cloak class="text-center py-8">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-2"></div>
            <p class="text-gray-600">Procesando archivos de conciliación...</p>
                                    </div>

        <!-- Status Message -->
        <div x-show="statusMessage.show" 
             x-cloak
             class="mb-6 p-4 rounded-md"
             :class="statusMessage.type === 'success' ? 'bg-green-50 text-green-800 border border-green-200' : 'bg-red-50 text-red-800 border border-red-200'">
            <span x-text="statusMessage.text"></span>
                                </div>




                
                <!-- SECCIÓN DE RESULTADOS Y DESCARGAS -->
                <div x-show="conciliationResult && conciliationResult.archivosGenerados" x-cloak class="mt-8">
                    <div class="bg-white rounded-lg border border-gray-200 p-6">
                        <h3 class="text-xl font-semibold text-gray-900 mb-4">
                            <i class="fas fa-download mr-2 text-blue-600"></i>
                            Archivos Generados
                        </h3>
                        

                        
                        <!-- Archivos Generados -->
                        <div class="border-t pt-6">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <!-- Archivo de Datos Originales -->
                                <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors">
                                    <div class="flex items-center justify-between">
                                        <div class="flex-1">
                                            <h5 class="font-medium text-gray-900 mb-1">
                                                <i class="fas fa-file-excel text-green-600 mr-2"></i>
                                                Resumen
                                            </h5>
                                            <p class="text-sm text-gray-600 mb-2" x-text="conciliationResult?.archivosGenerados?.datosOriginales?.descripcion || ''"></p>
                                            <p class="text-xs text-gray-500" x-text="conciliationResult?.archivosGenerados?.datosOriginales?.nombre || ''"></p>
                                        </div>
                                        <button @click="downloadFile(conciliationResult?.archivosGenerados?.datosOriginales?.url, conciliationResult?.archivosGenerados?.datosOriginales?.nombre)"
                                                class="ml-4 inline-flex items-center px-3 py-2 border border-blue-300 text-sm font-medium rounded-md text-blue-600 bg-white hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                                            <i class="fas fa-download mr-1"></i>
                                            Descargar
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Archivo de Conciliación -->
                                <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors">
                                    <div class="flex items-center justify-between">
                                        <div class="flex-1">
                                            <h5 class="font-medium text-gray-900 mb-1">
                                                <i class="fas fa-file-excel text-blue-600 mr-2"></i>
                                                Hoja de Trabajo
                                            </h5>
                                            <p class="text-sm text-gray-600 mb-2" x-text="conciliationResult?.archivosGenerados?.conciliacion?.descripcion || ''"></p>
                                            <p class="text-xs text-gray-500" x-text="conciliationResult?.archivosGenerados?.conciliacion?.nombre || ''"></p>
                                        </div>
                                        <button @click="downloadFile(conciliationResult?.archivosGenerados?.conciliacion?.url, conciliationResult?.archivosGenerados?.conciliacion?.nombre)"
                                                class="ml-4 inline-flex items-center px-3 py-2 border border-green-300 text-sm font-medium rounded-md text-green-600 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors">
                                            <i class="fas fa-download mr-1"></i>
                                            Descargar
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            </div>
                        
                        <!-- Resumen de Cuentas Bancarias -->
                        <div class="mt-8">
                            <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                                <div class="flex items-center mb-6">
                                    <i class="fas fa-university text-blue-600 mr-3"></i>
                                    <h3 class="text-xl font-semibold text-gray-900">Resumen de Cuentas Bancarias</h3>
                        </div>
                                
                                <!-- Tabla compacta con franjas -->
                                <div class="overflow-x-auto">
                                    <table class="min-w-full divide-y divide-gray-200">
                                        <thead class="bg-gray-50">
                                            <tr>
                                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">#CTA</th>
                                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nombre</th>
                                                <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">USD</th>
                                                <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">PEN</th>
                                                <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Libros</th>
                                                <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Ajuste TC</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-200">
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041501</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">BCP.01</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041501')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041501')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041505</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">BCP.02</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041505')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041505')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041502</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">BCP.USD</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041502')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtractoPEN('1041502')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041502')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-green-600">✅</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041401</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">SANT</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041401')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041401')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041402</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">SANT.USD</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041402')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtractoPEN('1041402')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041402')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-green-600">✅</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041201</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">BBVA</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041201')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041201')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041202</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">BBVA.USD</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041202')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtractoPEN('1041202')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041202')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-green-600">✅</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041301</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">SBP</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041301')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041301')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041302</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">SBP.USD</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041302')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtractoPEN('1041302')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041302')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-green-600">✅</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041101</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">IBK</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041101')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041101')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041102</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">IBK.USD</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041102')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtractoPEN('1041102')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041102')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-green-600">✅</td>
                                            </tr>
                                            <tr class="bg-gray-50 hover:bg-gray-100">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1042101</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 text-orange-800">DET</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1042101')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1042101')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                            <tr class="bg-white hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">1041601</td>
                                                <td class="px-4 py-2 whitespace-nowrap">
                                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 text-orange-800">BN</span>
                                                </td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoExtracto('1041601')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-blue-600 font-medium" x-text="getSaldoLibros('1041601')"></td>
                                                <td class="px-4 py-2 whitespace-nowrap text-center text-sm text-gray-500">❌</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>

                            </div>
                        </div>
                    </div>
                </div>
                
                                <!-- Botón para cargar archivos de prueba -->
                <button x-show="files.length === 0"
                        @click="loadTestFiles()"
                        class="inline-flex items-center px-4 py-3 border border-green-300 text-base font-medium rounded-md text-green-600 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200 shadow-sm"
                        title="Cargar archivos de prueba con nomenclatura: MAYOR.PEN/USD.MMAAAA, BCP.01/02/USD.PEN/USD.MMAAAA, SANT.PEN/USD.MMAAAA, BBVA.PEN/USD.MMAAAA, SBP.PEN/USD.MMAAAA, IBK.PEN.MMAAAA, SALDO.PEN.MMAAAA">
                    <i class="fas fa-flask mr-2"></i>
                    Cargar Archivos de Prueba
                </button>

                <!-- Botón para limpiar cache -->

            </div>
        </div>


</div>

<script>
    function bancarioConciliador() {
        return {
            files: [],
            isDragOver: false,
            isLoading: false,
            statusMessage: {
                show: false,
                text: '',
                type: 'success'
            },
            conciliationResult: null,
            saldoDET: 0,
            saldoBN: 0,
            tipoCambio: 3.75,
            mesAnoTarjetas: '',
            requiredFileTypes: ['mayor', 'extracto', 'resumen'],

            // === FUNCIONES DE CACHE PARA DATOS MANUALES ===

            guardarDatosManuales() {
                const datosCache = {
                    saldoDET: this.saldoDET,
                    saldoBN: this.saldoBN,
                    tipoCambio: this.tipoCambio,
                    mesAnoTarjetas: this.mesAnoTarjetas,
                    fechaGuardado: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem('conciliador_datos_manuales', JSON.stringify(datosCache));
                    
                    // Verificar que se guardó correctamente
                    const verificacion = localStorage.getItem('conciliador_datos_manuales');
                } catch (error) {
                }
            },

            cargarDatosManuales() {
                try {
                    const datosGuardados = localStorage.getItem('conciliador_datos_manuales');
                    if (datosGuardados) {
                        const datos = JSON.parse(datosGuardados);
                        this.saldoDET = datos.saldoDET || 0;
                        this.saldoBN = datos.saldoBN || 0;
                        this.tipoCambio = datos.tipoCambio || 3.75;
                        this.mesAnoTarjetas = datos.mesAnoTarjetas || '';
                        // Datos manuales cargados desde cache
                    } else {
                    }
                } catch (error) {
                    // Usar valores por defecto si hay error
                    this.saldoDET = 0;
                this.saldoBN = 0;
                this.tipoCambio = 3.75;
                this.mesAnoTarjetas = '';
                }
            },

            limpiarCacheDatosManuales() {
                try {
                    localStorage.removeItem('conciliador_datos_manuales');
                } catch (error) {
                }
            },
            
            // === CONFIGURACIÓN MULTI-CUENTA ===
            cuentasConfig: {
                '1041501': {
                    codigo: '1041501',
                    banco: 'BCO DE CREDITO M/N',
                    alias: 'BCP.01',
                    moneda: 'PEN',
                    archivoPattern: /^bcp\.01\.pen\.\d{6}/,
                    pestañaExcel: 'BCP.01',
                    activo: true, // Actualmente activo
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041505': {
                    codigo: '1041505',
                    banco: 'BCO DE CREDITO M/N',
                    alias: 'BCP.02',
                    moneda: 'PEN',
                    archivoPattern: /^bcp\.02\.pen\.\d{6}/,
                    pestañaExcel: 'BCP.02',
                    activo: true, // ACTIVADO - Ahora funcional
                    pasos: {
                        paso3: 'anulaciones_standard', // Misma lógica que BCP.01
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041502': {
                    codigo: '1041502',
                    banco: 'BCO DE CREDITO M/E',
                    alias: 'BCP.USD',
                    moneda: 'USD',
                    archivoPattern: /^bcp\.usd\.\d{6}/,
                    pestañaExcel: 'BCP.USD',
                    activo: true, // NUEVO - Cuenta USD
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041402': {
                    codigo: '1041402',
                    banco: 'BCO. SANTANDER M/E',
                    alias: 'SANT.USD',
                    moneda: 'USD',
                    archivoPattern: /^sant\.usd\.\d{6}/,
                    pestañaExcel: 'SANT.USD',
                    activo: true, // NUEVO - Cuenta Santander USD
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (índice 7) - igual que SANT.PEN
                        dataInicio: 9   // Datos empiezan en fila 9 (índice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_santander', // Misma lógica que SANT.PEN
                        paso4: 'santander_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_santander',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_santander',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041401': {
                    codigo: '1041401',
                    banco: 'BCO. SANTANDER M/N',
                    alias: 'SANT',
                    moneda: 'PEN',
                    archivoPattern: /^sant\.pen\.\d{6}/,
                    pestañaExcel: 'SANT',
                    activo: true, // ACTIVADO - Ahora funcional
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (índice 7)
                        dataInicio: 9   // Datos empiezan en fila 9 (índice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_santander',
                        paso4: 'santander_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_santander',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_santander',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041202': {
                    codigo: '1041202',
                    banco: 'CONTINENTAL M/E',
                    alias: 'BBVA.USD',
                    moneda: 'USD',
                    archivoPattern: /^bbva\.usd\.\d{6}/,
                    pestañaExcel: 'BBVA.USD',
                    activo: true, // NUEVO - Cuenta BBVA USD
                    estructuraEspecial: {
                        headerFila: 11, // Headers en fila 11 (índice 10) - igual que BBVA.PEN
                        dataInicio: 13   // Datos empiezan en fila 13 (índice 12), saltando fila 12
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bbva_operations', // Misma lógica que BBVA.PEN
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041201': {
                    codigo: '1041201',
                    banco: 'CONTINENTAL M/N',
                    alias: 'BBVA',
                    moneda: 'PEN',
                    archivoPattern: /^bbva\.pen\.\d{6}/,
                    pestañaExcel: 'BBVA',
                    activo: true, // ACTIVADO - Nueva cuenta BBVA
                    estructuraEspecial: {
                        headerFila: 11, // Headers en fila 11 (índice 10)
                        dataInicio: 13   // Datos empiezan en fila 13 (índice 12), saltando fila 12
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041302': {
                    codigo: '1041302',
                    banco: 'SCOTIABANK M/E',
                    alias: 'SBP.USD',
                    moneda: 'USD',
                    archivoPattern: /^sbp\.usd\.\d{6}/,
                    pestañaExcel: 'SBP.USD',
                    activo: true, // NUEVO - Cuenta SBP USD
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (índice 7) - igual que SBP.PEN
                        dataInicio: 9   // Datos empiezan en fila 9 (índice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations', // MISMA LÓGICA QUE SBP.PEN
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard', // MISMA LÓGICA QUE SBP.PEN
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped', // NOTA: Paso 9 ahora excluye SBP USD
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'sbp_usd_agrupado' // NUEVO - Agrupación por fecha + monto para USD
                    }
                },
                '1041301': {
                    codigo: '1041301',
                    banco: 'SCOTIABANK M/N',
                    alias: 'SBP',
                    moneda: 'PEN',
                    archivoPattern: /^sbp\.pen\.\d{6}/,
                    pestañaExcel: 'SBP',
                    activo: true, // ACTIVADO - Nueva cuenta Scotiabank
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (índice 7)
                        dataInicio: 9   // Datos empiezan en fila 9 (índice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'sbp_reprocess_paso4' // NUEVO - Reprocesar fase 1 del paso 4 para pendientes
                    }
                },
                '1041101': {
                    codigo: '1041101',
                    banco: 'INTERBANK M/N',
                    alias: 'IBK',
                    moneda: 'PEN',
                    archivoPattern: /^ibk\.pen\.\d{6}/,
                    pestañaExcel: 'IBK',
                    activo: true, // ACTIVADO - Nueva cuenta Interbank
                    estructuraEspecial: {
                        headerFila: 12, // Headers en fila 12 (índice 11) - desde A12 hasta I12
                        dataInicio: 13,   // Datos empiezan en fila 13 (índice 12) - siguiente fila después de headers
                        columnaInicio: 0, // Columna A (índice 0)
                        columnaFin: 8,   // Columna I (índice 8)
                        origenHeaders: {
                            fila: 12,     // Los headers originales están en fila 12
                            inicio: 0,    // Desde columna A (índice 0)
                            fin: 8        // Hasta columna I (índice 8)
                        },
                        headersEspecificos: {
                            fechaOperacion: 0,    // A - Fecha de operación
                            fechaProceso: 1,      // B - Fecha de proceso
                            nroOperacion: 2,      // C - Nro. de operación (CORREGIDO)
                            movimiento: 3,        // D - Movimiento
                            descripcion: 4,       // E - Descripción
                            canal: 5,             // F - Canal
                            cargo: 6,             // G - Cargo
                            abono: 7,             // H - Abono
                            saldoContable: 8      // I - Saldo contable
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'ibk_operations',
                        paso5: 'ibk_financ_docs_78', // Lógica específica IBK para FINANC.DOCS -78
                        paso6: 'ibk_depositos_abono', // Lógica específica IBK usando columna Abono
                        paso7: 'ibk_libro03_abono',   // Lógica específica IBK usando columna Abono
                        paso8: 'ibk_multi_libro_cargo', // Lógica específica IBK usando Fecha operación + |Cargo|
                        paso9: 'ibk_multi_libro_grouped_cargo', // Lógica específica IBK agrupada usando |Cargo|
                        paso10: 'cheques_operations',
                        paso11: 'ibk_itf_abono', // Lógica específica IBK para ITF usando ABONO
                        paso12: 'ibk_reprocess_paso4' // Reprocesar fase 1 del paso 4 para pendientes
                    }
                },
                '1041102': {
                    codigo: '1041102',
                    banco: 'INTERBANK M/E',
                    alias: 'IBK.USD',
                    moneda: 'USD',
                    archivoPattern: /^ibk\.usd\.\d{6}/,
                    pestañaExcel: 'IBK.USD',
                    activo: true, // NUEVO - Cuenta IBK USD
                    estructuraEspecial: {
                        headerFila: 12, // Headers en fila 12 (índice 11) - igual que IBK.PEN
                        dataInicio: 13,   // Datos empiezan en fila 13 (índice 12)
                        columnaInicio: 1, // Columna B (índice 1)
                        columnaFin: 9,   // Columna J (índice 9)
                        origenHeaders: {
                            fila: 12,     // Los headers originales están en fila 12
                            inicio: 1,    // Desde columna B (índice 1)
                            fin: 9        // Hasta columna J (índice 9)
                        },
                        headersEspecificos: {
                            fechaOperacion: 0,    // A - Fecha de operación (de B12)
                            fechaProceso: 1,      // B - Fecha de proceso (de C12)
                            nroOperacion: 2,      // C - Nro. de operación (de D12)
                            movimiento: 3,        // D - Movimiento (de E12)
                            descripcion: 4,       // E - Descripción (de F12)
                            canal: 5,             // F - Canal (de G12)
                            cargo: 6,             // G - Cargo (de H12)
                            abono: 7,             // H - Abono (de I12)
                            saldoContable: 8,     // I - Saldo contable (de J12)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'ibk_operations', // Misma lógica que IBK.PEN
                        paso5: 'ibk_financ_docs_78', // Lógica específica IBK para FINANC.DOCS -78
                        paso6: 'ibk_depositos_abono', // Lógica específica IBK usando columna Abono
                        paso7: 'ibk_libro03_abono',   // Lógica específica IBK usando columna Abono
                        paso8: 'ibk_multi_libro_cargo', // Lógica específica IBK usando Fecha operación + |Cargo|
                        paso9: 'ibk_multi_libro_grouped_cargo', // Lógica específica IBK agrupada usando |Cargo|
                        paso10: 'cheques_operations',
                        paso11: 'ibk_itf_abono', // Lógica específica IBK para ITF usando ABONO
                        paso12: 'ibk_reprocess_paso4' // Reprocesar fase 1 del paso 4 para pendientes
                    }
                },
                '1042101': {
                    codigo: '1042101',
                    banco: 'BANCOS Y FINANCIERAS',
                    alias: 'DET',
                    moneda: 'PEN',
                    archivoPattern: /^det\.pen\.\d{6}/,
                    pestañaExcel: 'DET',
                    activo: true, // ACTIVADO - Nuevo banco DET
                    estructuraEspecial: {
                        headerFila: 1, // Headers en fila 1 (índice 0)
                        dataInicio: 2,   // Datos empiezan en fila 2 (índice 1)
                        headersEspecificos: {
                            nro: 0,        // A - Nro
                            fecha: 1,      // B - Fecha
                            trans: 2,      // C - Trans
                            documento: 3,  // D - Documento
                            ruc: 4,        // E - RUC
                            oficina: 5,    // F - Oficina
                            cargo: 6,      // G - Cargo
                            abono: 7,      // H - Abono
                            estado: 8,     // I - ESTADO (nueva columna)
                            ref: 9         // J - #REF (nueva columna)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'det_operations',           // Operaciones específicas DET usando Cargo/Abono
                        paso5: 'prot_dev_grouping',
                        paso6: 'det_depositos_abono',      // Depósitos DET usando columna Abono
                        paso7: 'det_libro03_abono',        // Libro 03 DET usando columna Abono
                        paso8: 'det_multi_libro_cargo',    // Multi-libro DET usando columna Cargo
                        paso9: 'det_multi_libro_grouped_cargo', // Multi-libro agrupado DET usando Cargo
                        paso10: 'cheques_operations',
                        paso11: 'det_itf_abono',          // ITF DET usando columna Abono
                        paso12: 'det_fecha_debe_grouping'  // ESPECÍFICO DET: Agrupa por fecha y compara DEBE
                    }
                },
                '1041601': {
                    codigo: '1041601',
                    banco: 'BCO. DE LA NACION',
                    alias: 'BN',
                    moneda: 'PEN',
                    archivoPattern: /^bn\.pen\.\d{6}/,
                    pestañaExcel: 'BN',
                    activo: true, // ACTIVADO - Nuevo banco BN
                    estructuraEspecial: {
                        headerFila: 1, // Headers en fila 1 (índice 0)
                        dataInicio: 2,   // Datos empiezan en fila 2 (índice 1)
                        headersEspecificos: {
                            // Pendiente: definir estructura específica de BN cuando se proporcionen las columnas
                            estado: -2,  // Penúltima columna (ESTADO)
                            ref: -1      // Última columna (#REF)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'bn_depositos_abono',      // Depósitos BN usando columna Abono
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                }
                // Más cuentas se agregarán aquí en el futuro
            },

            init() {
                // Cargar archivos guardados
                this.loadStoredFiles();
                
                // Cargar valores manuales guardados
                this.cargarDatosManuales();
                
                // Inicializar mes/año por defecto si no hay valor guardado
                if (!this.mesAnoTarjetas) {
                    const ahora = new Date();
                    const año = ahora.getFullYear();
                    const mes = (ahora.getMonth() + 1).toString().padStart(2, '0');
                    this.mesAnoTarjetas = `${año}-${mes}`;
                }
                
                // Guardar automáticamente cuando cambien los valores
                this.$watch('saldoDET', () => this.guardarDatosManuales());
                this.$watch('saldoBN', () => this.guardarDatosManuales());
                this.$watch('tipoCambio', () => this.guardarDatosManuales());
                this.$watch('mesAnoTarjetas', () => this.guardarDatosManuales());
            },

            // === MÉTODOS PARA MANEJO MULTI-CUENTA ===
            
            // Obtener configuración de cuenta activa (primera cuenta activa encontrada)
            getCuentaActiva() {
                return Object.values(this.cuentasConfig).find(cuenta => cuenta.activo);
            },
            
            // Obtener todas las cuentas activas (futuro: múltiples)
            getCuentasActivas() {
                return Object.values(this.cuentasConfig).filter(cuenta => cuenta.activo);
            },
            
            // Detectar cuenta por nombre de archivo
            detectarCuentaPorArchivo(fileName) {
                const name = fileName.toLowerCase();
                
                // Diagnóstico específico para IBK
                if (name.includes('ibk')) {
                    //console.log(`🔍 [IBK DEBUG] Detectando archivo: ${fileName}`);
                    //console.log(`🔍 [IBK DEBUG] Nombre normalizado: ${name}`);
                }
                
                // Diagnóstico específico para SBP.USD
                if (name.includes('sbp.usd')) {
                    // Probar variaciones del nombre
                    const sinExtension = name.replace(/\.(xls|xlsx)$/, '');
                }
                
                // Probar cada patrón de cuenta
                for (const [codigo, config] of Object.entries(this.cuentasConfig)) {
                    const coincide = config.archivoPattern.test(name);
                    
                    if (name.includes('ibk')) {
                        //console.log(`🔍 [IBK DEBUG] Probando patrón ${config.alias}: ${config.archivoPattern} -> ${coincide}`);
                    }
                    
                    if (coincide) {
                        if (name.includes('ibk')) {
                            //console.log(`✅ [IBK DEBUG] Archivo detectado como: ${config.alias} (${codigo})`);
                        }
                        return { codigo, config };
                    }
                }
                
                if (name.includes('ibk')) {
                    //console.log(`❌ [IBK DEBUG] No se pudo detectar cuenta para archivo: ${fileName}`);
                }
                
                return null;
            },
            
            // Obtener estrategia de procesamiento por cuenta y paso
            getEstrategiaProcesamiento(codigoCuenta, numeroPaso) {
                const cuenta = this.cuentasConfig[codigoCuenta];
                if (!cuenta) return 'default';
                return cuenta.pasos[`paso${numeroPaso}`] || 'default';
            },
            
            // Verificar si una cuenta debe ser procesada
            debeProcestarCuenta(codigoCuenta) {
                const cuenta = this.cuentasConfig[codigoCuenta];
                return cuenta && cuenta.activo;
            },
            
            // Obtener TODAS las cuentas para filtrado (PEN + USD completo)
            getCuentasCompletasParaFiltrado() {
                // Lista MAESTRA de TODAS las cuentas (PEN + USD) que deben procesarse
                const todasLasCuentas = [
                    // Cuentas PEN
                    '1041501', // BCP.01
                    '1041505', // BCP.02
                    '1041401', // SANT
                    '1041201', // BBVA
                    '1041301', // SBP
                    '1041101', // IBK
                    '1042101', // DET
                    '1041601', // BN
                    // Cuentas USD
                    '1041502', // BCP.USD
                    '1041402', // SANT.USD
                    '1041202', // BBVA.USD
                    '1041302', // SBP.USD
                    '1041102'  // IBK.USD
                ];
                
                // Filtrar solo las que están activas en configuración
                const cuentasActivasCompletas = todasLasCuentas.filter(codigo => {
                    const cuenta = this.cuentasConfig[codigo];
                    return cuenta && cuenta.activo;
                });
                

                return cuentasActivasCompletas;
            },
            
            // Obtener configuración de filtro de cuenta (WRAPPER para compatibilidad)
            getCuentasFiltro() {
                // IMPORTANTE: Usar la función maestra que garantiza PEN + USD completo
                return this.getCuentasCompletasParaFiltrado();
            },

            // Cargar archivos guardados en localStorage
            loadStoredFiles() {
                try {
                    const storedFiles = localStorage.getItem('bancarioConciliador_files');
                    if (storedFiles) {
                        const filesData = JSON.parse(storedFiles);
                        this.files = filesData.map(fileData => ({
                            ...fileData,
                            file: this.base64ToFile(fileData.base64Data, fileData.name, fileData.type)
                        }));
                        if (this.files.length > 0) {
                            this.showStatus(`${this.files.length} archivo(s) cargado(s) desde la sesión anterior`, 'success');
                        }
                    }
                } catch (error) {
                }
            },

            // Guardar archivos en localStorage
            saveFilesToStorage() {
                try {
                    const filesToStore = this.files.map(file => ({
                        id: file.id,
                        name: file.name,
                        size: file.size,
                        category: file.category,
                        type: file.file.type,
                        base64Data: null // Se llenará después
                    }));

                    // Convertir archivos a base64 y guardar
                    Promise.all(filesToStore.map((fileInfo, index) => 
                        this.fileToBase64(this.files[index].file).then(base64 => {
                            fileInfo.base64Data = base64;
                            return fileInfo;
                        })
                    )).then(filesWithBase64 => {
                        localStorage.setItem('bancarioConciliador_files', JSON.stringify(filesWithBase64));
                    }).catch(error => {
                    });
                } catch (error) {
                }
            },

            // Convertir archivo a base64
            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            // Convertir base64 a archivo
            base64ToFile(base64String, fileName, fileType) {
                const byteCharacters = atob(base64String.split(',')[1]);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new File([byteArray], fileName, { type: fileType });
            },

            // Limpiar archivos guardados
            clearStoredFiles() {
                localStorage.removeItem('bancarioConciliador_files');
                this.files = [];
                this.conciliationResult = null;
                this.showStatus('Archivos guardados eliminados', 'success');
            },

            handleDrop(event) {
                this.isDragOver = false;
                const files = Array.from(event.dataTransfer.files);
                this.processFiles(files);
            },

            handleFileSelect(event) {
                const files = Array.from(event.target.files);
                this.processFiles(files);
            },

            processFiles(files) {
                const validFiles = files.filter(file => {
                    const extension = file.name.split('.').pop().toLowerCase();
                    const allowedExtensions = ['xlsx', 'xls', 'csv', 'txt'];
                    return allowedExtensions.includes(extension);
                });

                if (validFiles.length > 0) {
                    this.addFiles(validFiles);
        } else {
                    this.showStatus('Por favor selecciona archivos válidos (XLSX, XLS, CSV, TXT)', 'error');
                }
            },

            addFiles(files) {
                files.forEach(file => {
                    //console.log(`🔍 [FILE DEBUG] Procesando archivo: ${file.name}`);
                    
                    // Manejo especial para archivo cheques.txt
                    if (file.name.toLowerCase() === 'cheques.txt') {
                        //console.log('🔍 [CHEQUES DEBUG] Detectado archivo cheques.txt');
                        this.processChequesFile(file);
                        // Agregar a la lista visual pero con categoría especial
                        const fileObj = {
                            id: Date.now() + Math.random(),
                            name: file.name,
                            size: file.size,
                            file: file,
                            category: 'cheques'
                        };
                        this.files.push(fileObj);
                        return;
                    }
                    
                    if (file.name.toLowerCase().includes('sbp.usd')) {
        
                    }
                    const fileObj = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        file: file,
                        category: this.categorizeFile(file.name)
                    };
                    
                    //console.log(`🔍 [FILE DEBUG] Archivo categorizado como: ${fileObj.category}`);
                    
                    if (file.name.toLowerCase().includes('sbp.usd')) {
        
                    }
                    this.files.push(fileObj);
                });
                this.showStatus(`${files.length} archivo(s) agregado(s) correctamente`, 'success');
                
                // Guardar automáticamente en localStorage
                this.saveFilesToStorage();
            },

            // Función para procesar el archivo cheques.txt
            async processChequesFile(file) {
                try {
                    //console.log('🔍 [CHEQUES DEBUG] Iniciando procesamiento de cheques.txt');
                    
                    // Leer el contenido del archivo
                    const text = await this.readFileAsText(file);
                    //console.log('🔍 [CHEQUES DEBUG] Contenido del archivo leído:', text.length, 'caracteres');
                    //console.log('🔍 [CHEQUES DEBUG] Primeras 500 caracteres del archivo:', text.substring(0, 500));
                    
                    // Convertir el texto a JSON usando el formato específico
                    const chequesData = this.parseChequesTextToJSON(text);
                    //console.log('🔍 [CHEQUES DEBUG] Datos convertidos a JSON:', chequesData);
                    
                    // Guardar en localStorage para uso posterior
                    this.saveChequesDataToStorage(chequesData);
                    
                    // Mostrar mensaje de éxito
                    this.showStatus(`Archivo cheques.txt procesado correctamente: ${chequesData.length} registros`, 'success');
                    
                    /*Cambio solicitado: OBSERVACIÓN 6 - Deshabilitar auto descarga de cheques_debug.json - 27102025 20:05*/
                    // Descargar el archivo JSON generado para debug
                    // this.downloadChequesJSON(chequesData);
                    
                } catch (error) {
                    //console.error('❌ [CHEQUES ERROR] Error procesando cheques.txt:', error);
                    this.showStatus('Error al procesar cheques.txt: ' + error.message, 'error');
                }
            },

            // Función para leer archivo como texto
            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Error al leer el archivo'));
                    reader.readAsText(file, 'UTF-8');
                });
            },

            // Función para convertir texto de cheques a JSON (formato específico)
            parseChequesTextToJSON(text) {
                //console.log('🔍 [CHEQUES DEBUG] Parseando texto a JSON con formato específico...');
                
                // Filtramos líneas que empiezan con código (por ejemplo "01-0001")
                const lineas = text.split('\n')
                    .map(l => l.replace(/\r/g, '')) // limpia retornos
                    .filter(l => /^\d{2}-\d{4}/.test(l.trim()));

                //console.log('🔍 [CHEQUES DEBUG] Total de líneas válidas encontradas:', lineas.length);

                // Analizar el formato del archivo
                const formatoDetectado = this.analizarFormatoArchivo(lineas);
                //console.log('🔍 [CHEQUES DEBUG] Formato detectado:', formatoDetectado);

                // Parseamos cada línea usando el método detectado
                const cheques = lineas.map((linea, index) => {
                    //console.log(`🔍 [CHEQUES DEBUG] Procesando línea ${index + 1}:`, linea);
                    
                    let chequeData = null;
                    
                    // Usar el método detectado
                    switch (formatoDetectado) {
                        case 'csv':
                            chequeData = this.parsearLineaCSV(linea, index);
                            break;
                        case 'tsv':
                            chequeData = this.parsearLineaTSV(linea, index);
                            break;
                        case 'spaces':
                            chequeData = this.parsearLineaEspacios(linea, index);
                            break;
                        case 'fixed':
                        default:
                            chequeData = this.parsearLineaPosicionesFijas(linea, index);
                            break;
                    }
                    
                    //console.log(`🔍 [CHEQUES DEBUG] Línea ${index + 1} - Resultado:`, chequeData);
                    return chequeData;
                });

                //console.log('🔍 [CHEQUES DEBUG] Total de cheques procesados:', cheques.length);
                
                // Mostrar algunos cheques procesados para debug
                //console.log('🔍 [CHEQUES DEBUG] Primeros 3 cheques procesados:', cheques.slice(0, 3));
                
                // Guardar globalmente para uso posterior
                window.datosCheques = cheques;
                
                //console.log('🔍 [CHEQUES DEBUG] Datos guardados en window.datosCheques:', window.datosCheques.length);
                
                return cheques;
            },

            // Función para buscar cheques por número (exacto o parcial)
            buscarCheque(numeroCheque) {
                if (!window.datosCheques) {
                    console.warn('⚠️ Los datos de cheques aún no están cargados. Adjunta cheques.txt primero.');
                    return [];
                }

                const resultado = window.datosCheques.filter(c =>
                    c.cheque.includes(numeroCheque.toString())
                );

                //console.log(`🔎 Resultados para cheque ${numeroCheque}:`, resultado);
                return resultado;
            },

            // Función para descargar el archivo JSON generado (para debug)
            downloadChequesJSON(chequesData) {
                try {
                    const jsonString = JSON.stringify(chequesData, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'cheques_debug.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    //console.log('🔍 [CHEQUES DEBUG] Archivo JSON de debug descargado: cheques_debug.json');
                } catch (error) {
                    //console.error('❌ [CHEQUES ERROR] Error descargando JSON de debug:', error);
                }
            },

            // Función para parsear línea CSV (separado por comas)
            parsearLineaCSV(linea, index) {
                const partes = linea.split(',').map(parte => parte.trim());
                //console.log(`🔍 [CHEQUES DEBUG] Línea ${index + 1} - Partes CSV:`, partes);
                
                return {
                    comprobante: partes[0] || '',
                    fecha: partes[1] || '',
                    banco: partes[2] || '',
                    cheque: partes[3] || '',
                    importe: partes[4] || '',
                    girado: partes[5] || '',
                    estado: partes[6] || '',
                    concepto: partes[7] || '',
                    firmante1: partes[8] || '',
                    firmante2: partes[9] || '',
                    datosAux: partes.slice(10).join(',') || '',
                    lineaOriginal: linea.trim(),
                    numeroLinea: index + 1,
                    metodo: 'csv'
                };
            },

            // Función para parsear línea TSV (separado por tabs)
            parsearLineaTSV(linea, index) {
                const partes = linea.split('\t').map(parte => parte.trim());
                //console.log(`🔍 [CHEQUES DEBUG] Línea ${index + 1} - Partes TSV:`, partes);
                
                return {
                    comprobante: partes[0] || '',
                    fecha: partes[1] || '',
                    banco: partes[2] || '',
                    cheque: partes[3] || '',
                    importe: partes[4] || '',
                    girado: partes[5] || '',
                    estado: partes[6] || '',
                    concepto: partes[7] || '',
                    firmante1: partes[8] || '',
                    firmante2: partes[9] || '',
                    datosAux: partes.slice(10).join('\t') || '',
                    lineaOriginal: linea.trim(),
                    numeroLinea: index + 1,
                    metodo: 'tsv'
                };
            },

            // Función para parsear línea con espacios múltiples
            parsearLineaEspacios(linea, index) {
                const partes = linea.split(/\s+/).filter(parte => parte.trim() !== '');
                //console.log(`🔍 [CHEQUES DEBUG] Línea ${index + 1} - Partes espacios:`, partes);
                
                // Para espacios, asumimos que los primeros campos son fijos y el resto es texto libre
                return {
                    comprobante: partes[0] || '',
                    fecha: partes[1] || '',
                    banco: partes[2] || '',
                    cheque: partes[3] || '',
                    importe: partes[4] || '',
                    girado: partes.slice(5, -2).join(' ') || '', // Todo lo del medio
                    estado: partes[partes.length - 2] || '',
                    concepto: partes[partes.length - 1] || '',
                    firmante1: '',
                    firmante2: '',
                    datosAux: '',
                    lineaOriginal: linea.trim(),
                    numeroLinea: index + 1,
                    metodo: 'spaces'
                };
            },

            // Función para parsear línea con posiciones fijas
            parsearLineaPosicionesFijas(linea, index) {
                //console.log(`🔍 [CHEQUES DEBUG] Línea ${index + 1} - Parsing posiciones fijas`);
                //console.log(`🔍 [CHEQUES DEBUG] Línea completa:`, linea);
                
                // Usar regex para extraer campos de manera más precisa
                const regex = /^(\d{2}-\d{4})\s+(\d{6})\s+(\d{2}\/\d{2}\/\d{4})\s+(\w+)\s+(\d{8})\s+S\/\s+([\d,]+\.\d{2})\s+(.+?)\s+(Cobrado|Entrega|Entregado|Impreso|Anulado|Pendiente)\s+(.+)$/;
                const match = linea.match(regex);
                
                if (match) {
                    //console.log(`🔍 [CHEQUES DEBUG] Regex match exitoso:`, match);
                    
                    const resultado = {
                        comprobante: match[1] + ' ' + match[2],  // "01-0001 000001"
                        fecha: match[3],                         // "03/01/2025"
                        banco: match[4],                        // "CREDITO"
                        cheque: match[5],                        // "00042342"
                        importe: 'S/ ' + match[6],              // "S/ 3,000.00"
                        girado: match[7].trim(),                // "DEL CARPIO HERRERA NEIL ENRIQUE"
                        estado: match[8],                       // "Cobrado" o "Entrega"
                        concepto: match[9].trim(),               // Todo lo que sigue después del estado
                        firmante1: '',
                        firmante2: '',
                        datosAux: '',
                        lineaOriginal: linea.trim(),
                        numeroLinea: index + 1,
                        metodo: 'fixed-regex'
                    };
                    
                    //console.log(`🔍 [CHEQUES DEBUG] Resultado final:`, resultado);
                    return resultado;
                } else {
                    //console.log(`🔍 [CHEQUES DEBUG] Regex no hizo match, usando método alternativo`);
                    
                    // Método alternativo: análisis por partes
                    const partes = linea.split(/\s+/).filter(parte => parte.trim() !== '');
                    //console.log(`🔍 [CHEQUES DEBUG] Partes encontradas:`, partes);
                    
                    // Buscar el número de cheque (formato: 00042342)
                    let indiceCheque = -1;
                    let numeroCheque = '';
                    for (let i = 0; i < partes.length; i++) {
                        if (/^\d{8}$/.test(partes[i])) { // 8 dígitos
                            indiceCheque = i;
                            numeroCheque = partes[i];
                            break;
                        }
                    }
                    
                    // Buscar el importe (formato: S/ 3,000.00)
                    let indiceImporte = -1;
                    let importe = '';
                    for (let i = 0; i < partes.length; i++) {
                        if (partes[i] === 'S/' && i + 1 < partes.length) {
                            indiceImporte = i;
                            importe = partes[i] + ' ' + partes[i + 1];
                            break;
                        }
                    }
                    
                    // Buscar el estado (palabras como "Cobrado", "Entrega", etc.)
                    let indiceEstado = -1;
                    let estado = '';
                    const estadosPosibles = ['Cobrado', 'Entregado', 'Impreso', 'Anulado', 'Pendiente', 'Entrega'];
                    for (let i = 0; i < partes.length; i++) {
                        if (estadosPosibles.includes(partes[i])) {
                            indiceEstado = i;
                            estado = partes[i];
                            break;
                        }
                    }
                    
                    /*console.log(`🔍 [CHEQUES DEBUG] Índices encontrados:`, {
                        indiceCheque,
                        numeroCheque,
                        indiceImporte,
                        importe,
                        indiceEstado,
                        estado
                    });*/
                    
                    // Construir el objeto con los datos encontrados
                    const resultado = {
                        comprobante: partes[0] + ' ' + partes[1] || '', // "01-0001 000001"
                        fecha: partes[2] || '',                        // "03/01/2025"
                        banco: partes[3] || '',                       // "CREDITO"
                        cheque: numeroCheque,                          // "00042342"
                        importe: importe,                             // "S/ 3,000.00"
                        girado: '',                                   // Se llenará después
                        estado: estado,                               // "Cobrado"
                        concepto: '',                                 // Se llenará después
                        firmante1: '',
                        firmante2: '',
                        datosAux: '',
                        lineaOriginal: linea.trim(),
                        numeroLinea: index + 1,
                        metodo: 'fixed-fallback'
                    };
                    
                    // Extraer girado (entre el importe y el estado)
                    if (indiceImporte !== -1 && indiceEstado !== -1) {
                        const giradoPartes = partes.slice(indiceImporte + 2, indiceEstado);
                        resultado.girado = giradoPartes.join(' ');
                    }
                    
                    // Extraer concepto (después del estado)
                    if (indiceEstado !== -1) {
                        const conceptoPartes = partes.slice(indiceEstado + 1);
                        resultado.concepto = conceptoPartes.join(' ');
                    }
                    
                    //console.log(`🔍 [CHEQUES DEBUG] Resultado final (fallback):`, resultado);
                    return resultado;
                }
            },

            // Función para analizar el formato del archivo y determinar el mejor método de parsing
            analizarFormatoArchivo(lineas) {
                //console.log('🔍 [CHEQUES DEBUG] Analizando formato del archivo...');
                
                if (lineas.length === 0) return 'unknown';
                
                // Tomar las primeras 3 líneas para análisis
                const muestras = lineas.slice(0, Math.min(3, lineas.length));
                
                let tieneComasSeparadoras = 0;
                let tieneEspaciosMultiples = 0;
                let tieneTabs = 0;
                
                muestras.forEach((linea, index) => {
                    //console.log(`🔍 [CHEQUES DEBUG] Muestra ${index + 1}:`, linea);
                    
                    // Verificar si tiene comas separadoras (no solo en números)
                    // Una línea CSV debería tener múltiples comas separando campos claramente
                    const partesPorComas = linea.split(',');
                    const tieneComasSeparadorasReal = partesPorComas.length >= 6 && 
                        partesPorComas.every(parte => parte.trim().length < 50); // Campos no muy largos
                    
                    if (tieneComasSeparadorasReal) tieneComasSeparadoras++;
                    
                    // Verificar espacios múltiples (más confiable para formato fijo)
                    if (linea.includes('  ') || linea.includes('   ')) tieneEspaciosMultiples++;
                    if (linea.includes('\t')) tieneTabs++;
                });
                
                /*console.log('🔍 [CHEQUES DEBUG] Análisis:', {
                    tieneComasSeparadoras,
                    tieneEspaciosMultiples,
                    tieneTabs,
                    totalMuestras: muestras.length
                });*/
                
                // Determinar el mejor método - priorizar espacios múltiples sobre comas
                if (tieneEspaciosMultiples === muestras.length) {
                    //console.log('🔍 [CHEQUES DEBUG] Formato detectado: Espacios múltiples (posiciones fijas)');
                    return 'fixed';
                } else if (tieneTabs === muestras.length) {
                    //console.log('🔍 [CHEQUES DEBUG] Formato detectado: TSV (separado por tabs)');
                    return 'tsv';
                } else if (tieneComasSeparadoras === muestras.length) {
                    //console.log('🔍 [CHEQUES DEBUG] Formato detectado: CSV (separado por comas)');
                    return 'csv';
                } else {
                    //console.log('🔍 [CHEQUES DEBUG] Formato detectado: Posiciones fijas (fallback)');
                    return 'fixed';
                }
            },

            // Función para buscar datos de cheques por número de referencia
            buscarDatosChequePorReferencia(numeroReferencia) {
                //console.log('🔍 [CHEQUES MATCH] Buscando cheque para REF:', numeroReferencia);
                //console.log('🔍 [CHEQUES MATCH] window.datosCheques disponible:', !!window.datosCheques);
                //console.log('🔍 [CHEQUES MATCH] Total de cheques en memoria:', window.datosCheques?.length || 0);
                
                if (!window.datosCheques || !Array.isArray(window.datosCheques)) {
                    //console.log('🔍 [CHEQUES MATCH] No hay datos de cheques disponibles');
                    return null;
                }

                // Mostrar algunos cheques para debug
                //console.log('🔍 [CHEQUES MATCH] Primeros 3 cheques en memoria:', window.datosCheques.slice(0, 3));

                // Buscar por número de cheque exacto o parcial
                const chequeEncontrado = window.datosCheques.find(cheque => {
                    const numeroCheque = cheque.cheque ? cheque.cheque.toString() : '';
                    const numeroRef = numeroReferencia ? numeroReferencia.toString() : '';
                    const match = numeroCheque.includes(numeroRef);
                    
                    /*console.log('🔍 [CHEQUES MATCH] Comparando:', {
                        numeroCheque,
                        numeroRef,
                        match
                    });*/
                    
                    return match;
                });

                if (chequeEncontrado) {
                    //console.log('🔍 [CHEQUES MATCH] Cheque encontrado para REF:', numeroReferencia, chequeEncontrado);
                    return {
                        estado: chequeEncontrado.estado || '',
                        descripcion: chequeEncontrado.concepto || '',
                        comprobante: chequeEncontrado.comprobante || '',
                        girado: chequeEncontrado.girado || '',
                        importe: chequeEncontrado.importe || ''
                    };
                } else {
                    //console.log('🔍 [CHEQUES MATCH] No se encontró cheque para REF:', numeroReferencia);
                    return null;
                }
            },

            // Función para guardar datos de cheques en localStorage
            saveChequesDataToStorage(chequesData) {
                try {
                    localStorage.setItem('chequesData', JSON.stringify(chequesData));
                    //console.log('🔍 [CHEQUES DEBUG] Datos guardados en localStorage');
                } catch (error) {
                    //console.error('❌ [CHEQUES ERROR] Error guardando en localStorage:', error);
                }
            },


            categorizeFile(fileName) {
                const name = fileName.toLowerCase();
                
                if (name.includes('sbp.usd')) {
    
                }
                
                // === CATEGORIZACIÓN BASADA EN CONFIGURACIÓN DE CUENTAS ===
                
                // 1. Verificar si es archivo de extracto por cuenta específica
                const cuentaDetectada = this.detectarCuentaPorArchivo(fileName);
                if (name.includes('sbp.usd')) {
    
                }
                if (cuentaDetectada) {
                    if (name.includes('sbp.usd')) {
        
                    }
                    // Archivo de extracto de cuenta específica (BCP.01, BCP.02, SANT, BBVA, etc.)
                    return 'extracto';
                } else if (name.includes('sbp.usd')) {
    
                }
                
                // 2. Patrones para Mayor: MAYOR.PEN.MMAAAA o MAYOR.USD.MMAAAA
                if (name.match(/^mayor\.(pen|usd)\.\d{6}/)) {
                    return 'mayor';
                }
                
                // 3. Patrones para Saldo: SALDO.PEN.MMAAAA o SALDO.USD.MMAAAA
                if (name.match(/^saldo\.(pen|usd)\.\d{6}/)) {
                    return 'resumen';
                }
                
                const resumenMatch = name.match(/^resumen\.\d{6}/);
                
                const resumenFlexible = name.startsWith('resumen.');
                
                if (resumenMatch || resumenFlexible) {
                    return 'libros';
                }
                
                // 4. Patrones legacy para compatibilidad (se eliminarán gradualmente)
                if (name.includes('mayor') || name.includes('analitico')) {
                    return 'mayor';
                } else if (name.includes('extracto') || name.includes('banco')) {
                    return 'extracto';
                } else if (name.includes('resumen') || name.includes('saldo')) {
                    return 'resumen';
                } else if (name === 'cheques.txt') {
                    return 'cheques';
        } else {
                    return 'otro';
                }
            },

            deleteFile(fileId) {
                if (confirm('¿Estás seguro de que quieres eliminar este archivo?')) {
                    this.files = this.files.filter(file => file.id !== fileId);
                    this.showStatus('Archivo eliminado correctamente', 'success');
                    
                    // Actualizar localStorage
                    this.saveFilesToStorage();
                }
            },

            canProcessConciliation() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                return hasMayor && hasExtracto;
            },

            getMissingFilesMessage() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                
                if (!hasMayor && !hasExtracto) {
                    return 'Faltan archivos MAYOR.PEN/USD.MMAAAA y extractos bancarios (BCP.01/02/USD, SANT.PEN/USD, BBVA.PEN/USD, SBP.PEN/USD, IBK)';
                } else if (!hasMayor) {
                    return 'Falta archivo MAYOR.PEN/USD.MMAAAA';
                } else if (!hasExtracto) {
                    return 'Faltan archivos de extractos bancarios (BCP.01/02/USD, SANT.PEN/USD, BBVA.PEN/USD, SBP.PEN/USD, IBK)';
                }
                return 'Archivos incompletos';
            },

            validarDatosRequeridos() {
                // Validar que los campos manuales tengan valores válidos
                const saldoDETValido = this.saldoDET !== null && this.saldoDET !== undefined && this.saldoDET >= 0;
                const saldoBNValido = this.saldoBN !== null && this.saldoBN !== undefined && this.saldoBN >= 0;
                const tipoCambioValido = this.tipoCambio !== null && this.tipoCambio !== undefined && this.tipoCambio > 0;
                
                const resultado = saldoDETValido && saldoBNValido && tipoCambioValido;
                return resultado;
            },

            async realizarConciliacion() {
                if (!this.canProcessConciliation()) {
                    this.showStatus('Se necesitan al menos los archivos MAYOR.PEN/USD.MMAAAA y extractos bancarios (BCP.01/02, SANT, BBVA, IBK)', 'error');
                    return;
                }
                this.isLoading = true;
                try {
                    // === SEPARAR ARCHIVOS MAYOR POR MONEDA ===
                    const mayorFiles = this.files.filter(f => f.category === 'mayor');
                    const mayorFilePEN = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.pen'))?.file;
                    const mayorFileUSD = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.usd'))?.file;
                    
                    // Por compatibilidad, si no hay archivos específicos, usar el genérico
                    const mayorFileGenerico = mayorFiles[0]?.file;
                    const mayorFile = mayorFilePEN || mayorFileGenerico;
                    
                    const librosFiles = this.files.filter(f => f.category === 'libros');
                    
                    let saldosLibros = new Map();
                    
                    if (librosFiles.length > 0) {
                        const librosFile = librosFiles[0].file;
                        saldosLibros = await this.procesarArchivoLibros(librosFile);
                    } else {
                    }
                    
                    // === SEPARAR EXTRACTOS POR CUENTA ===
                    const extractoFiles = this.files.filter(f => f.category === 'extracto');
                    
                    const extractosPorCuenta = new Map();
                    const saldosExtractos = new Map(); // Para almacenar saldos de E6
                    
                    // Procesar cada archivo de extracto por cuenta específica
                    for (const extractoFileObj of extractoFiles) {
                        const cuentaInfo = this.detectarCuentaPorArchivo(extractoFileObj.name);
                        
                        if (cuentaInfo) {
                            if (cuentaInfo.codigo === '1041302') {
                
                            }
                            
                            // Capturar saldo de extractos para todos los bancos (excepto DET y BN)
                            if (!cuentaInfo.codigo.startsWith('1042101') && !cuentaInfo.codigo.startsWith('1041601')) {
                                const saldoExtracto = await this.leerSaldoExtracto(extractoFileObj.file, cuentaInfo.codigo);
                                if (saldoExtracto !== null) {
                                    saldosExtractos.set(cuentaInfo.codigo, saldoExtracto);
                                }
                            }
                            
                            if (cuentaInfo.config.activo) {
                                // Leer archivo con configuración específica (estructura especial si aplica)
                                const datosExtracto = await this.readExcelFile(extractoFileObj.file, cuentaInfo.config);
                            extractosPorCuenta.set(cuentaInfo.codigo, {
                                config: cuentaInfo.config,
                                datos: datosExtracto,
                                archivo: extractoFileObj.name
                            });
                                if (cuentaInfo.codigo === '1041302') {
                    
                                }
                                
                                // Diagnóstico especial para SBP.USD
                                if (cuentaInfo.codigo === '1041302') {
    
    
    
    
                                    if (cuentaInfo.config.estructuraEspecial) {
    
    
                                    }
                                    // Mostrar primeras filas para verificar
                                    if (datosExtracto.length > 0) {
    
                                        if (datosExtracto.length > 1) {
        
                                        }
                                    }
                                }
                            } else {

                            }
                        } else {

                        }
                    }
                    
    
                    extractosPorCuenta.forEach((info, codigo) => {
    
                    });
                    if (extractosPorCuenta.size === 0 || !mayorFile) {
                        throw new Error('No se encontraron los archivos necesarios');
                    }
                    
                    // Debug: mostrar todos los archivos y sus categorías
                    this.files.forEach(f => {
                    });
                    
                    const saldoFile = this.files.find(f => f.category === 'resumen')?.file; // Archivo de saldo opcional
                    const mayorDataPEN = await this.readExcelFile(mayorFile);
                    
                    // Cargar MAYOR.USD si existe
                                    let mayorDataUSD = null;
                if (mayorFileUSD) {
                    mayorDataUSD = await this.readExcelFile(mayorFileUSD);
    
                    
                    // Verificar datos de SBP.USD específicamente
    
                    
                    // 1. Mostrar estructura del archivo
                    if (mayorDataUSD.length > 2) {
        
        
        
                    }
                    
                    // 2. Buscar columna CUENTA dinámicamente
                    const headerMayorUSD = mayorDataUSD.length > 1 ? mayorDataUSD[1] : [];
                    const indicesMayorUSD = this.buscarIndicesColumnas(headerMayorUSD, {
                        cuenta: ['CUENTA']
                    });
    
                    
                    // 3. Buscar SBP.USD usando la columna correcta
                    let filasSBPUSD = [];
                    if (indicesMayorUSD.cuenta !== -1) {
        
                        filasSBPUSD = mayorDataUSD.filter(fila => {
                            const cuenta = fila[indicesMayorUSD.cuenta] || '';
                        const cuentaStr = cuenta.toString().trim();
                        const contiene1041302 = cuentaStr.includes('1041302');
                        if (contiene1041302) {
        
                        }
                        return contiene1041302;
                    });
                    } else {
                        // Fallback: buscar en todas las columnas

                        const filasData = mayorDataUSD.slice(2);
                        filasData.forEach((fila, idx) => {
                            fila.forEach((valor, colIdx) => {
                                const valorStr = (valor || '').toString().trim();
                                if (valorStr.includes('1041302')) {
    
                                    filasSBPUSD.push(fila);
                                }
                            });
                        });
                    }
                    

                    
                    // Si no encontramos, revisar todas las cuentas para diagnosticar
                    if (filasSBPUSD.length === 0 && mayorDataUSD.length > 0) {
    
                        mayorDataUSD.slice(0, 5).forEach((fila, idx) => {
                            const cuenta = fila[7] || ''; // Columna H = índice 7

                        });
                        
                        // Buscar cualquier cuenta que empiece con 1041
                        const cuentas1041 = mayorDataUSD.filter(fila => {
                            const cuenta = fila[7] || ''; // Columna H = índice 7
                            return cuenta.toString().startsWith('1041');
                        });
                        const cuentasUnicas = [...new Set(cuentas1041.map(fila => fila[7]))];
    
                    }
                    
                    if (filasSBPUSD.length > 0) {

                    }
                }
                    
                    // Cargar archivo de saldo si está disponible
                    let saldoData = null;
                    if (saldoFile) {
                        saldoData = await this.readExcelFile(saldoFile);
                        if (saldoData && saldoData.length > 0) {
                        }
                    } else {
                    }
            
            if (!mayorDataPEN || extractosPorCuenta.size === 0) {
                throw new Error('Error al leer los archivos Excel');
            }
            
            
            mayorDataPEN.slice(0, 3).forEach((fila, idx) => {
            });
            
            extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                extractoInfo.datos.slice(0, 6).forEach((fila, idx) => {
                });
            });
            
            if (saldoData) {
                saldoData.slice(0, 3).forEach((fila, idx) => {
                });
                
                // TEST ESPECÍFICO PARA EL EJEMPLO DEL USUARIO
                
                // TEST DE NORMALIZACIÓN DE FECHAS PARA PASO 4
                
                // TEST DE MONTOS PARA TU EJEMPLO ESPECÍFICO
                const monto1 = this.normalizarMonto('396118,93');
                const monto2 = this.normalizarMonto('396.118,93');
                const diferencia = Math.abs(monto1 - monto2);
                
                // Test adicional del mapeo exacto
            } else {
            }
                    const resultado = this.procesarConciliacionMultiCuenta(extractosPorCuenta, mayorDataPEN, saldoData, mayorDataUSD);
            if (!resultado || !resultado.datosMayor || resultado.datosMayor.length === 0) {
                throw new Error('No se generaron datos de conciliación');
            }
            
            // Verificar que tenemos extractos por cuenta
            if (!resultado.extractosPorCuenta || resultado.extractosPorCuenta.size === 0) {

            }
            
            const fileName = `conciliacion_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
                    
                    // Agregar saldos manuales para DET y BN
                    saldosExtractos.set('1042101', this.saldoDET); // DET
                    saldosExtractos.set('1041601', this.saldoBN);   // BN
                    
                    // Mostrar resultados
                    this.conciliationResult = {
                        totalProcesados: resultado.totalProcesados,
                        conciliados: Math.floor(resultado.totalProcesados * 0.8), // Ejemplo
                        noConciliados: Math.floor(resultado.totalProcesados * 0.2), // Ejemplo
                        saldosLibros: saldosLibros, // Agregar saldos de libros
                        saldosExtractos: saldosExtractos, // Agregar saldos de extractos (E6)
                        tipoCambio: this.tipoCambio, // Agregar tipo de cambio
                        resultado: resultado, // Agregar el resultado completo para acceso a datosSaldo
                        detalles: {
                            fecha: new Date().toISOString(),
                            archivo_generado: fileName,
                            registros_procesados: resultado.totalProcesados
                        }
                    };
                    
                    // Log para verificar asignación
                    // Generar dos archivos Excel
                    const archivosGenerados = await this.generateTwoExcelFiles(resultado, fileName);
                    // Guardar información de archivos generados para descarga manual
                    this.conciliationResult.archivosGenerados = archivosGenerados;
                    
                    this.showStatus(`Conciliación completada exitosamente. Se generaron 2 archivos para descarga.`, 'success');
            
                 } catch (error) {
                    this.showStatus(`Error en conciliación: ${error.message}`, 'error');
                } finally {
                    this.isLoading = false;
                }
            },

            readExcelFile(file, cuentaConfig = null) {
         return new Promise((resolve, reject) => {
             const reader = new FileReader();
             reader.onload = function(e) {
                 try {
                     const data = new Uint8Array(e.target.result);
                     const workbook = XLSX.read(data, { type: 'array' });
                     const sheetName = workbook.SheetNames[0];
                     const worksheet = workbook.Sheets[sheetName];
                    let jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                    

                    //console.log(`🔍🔍🔍🔍🔍🔍🔍🔍🔍`);
                    //console.log(jsonData);
                    //console.log(`🔍🔍🔍🔍🔍🔍🔍🔍🔍`);

                    
                    // 🔧 DIAGNÓSTICO DETALLADO: Verificar archivo y configuración
                    
                    if (cuentaConfig) {
                        if (cuentaConfig.estructuraEspecial) {
                        }
                    } else {
                    }
            
            // Aplicar estructura especial si está configurada
            if (cuentaConfig && cuentaConfig.estructuraEspecial) {
                        const estructura = cuentaConfig.estructuraEspecial;
        
        
        
        
                        
                        // Extraer header y datos según configuración
                        const headerFila = jsonData[estructura.headerFila - 1] || []; // Convertir a índice base 0
                        const datosDesde = estructura.dataInicio - 1; // Convertir a índice base 0
                        
                        
                        // Mostrar algunas filas de datos de ejemplo
                        if (jsonData.length > datosDesde) {
                        }
                        
                        // VALIDAR QUE EL HEADER SEA REALMENTE UN HEADER (no datos)
    
                        // Activar logs solo para IBK y IBK.USD
                        // if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                        //     //console.log(`🔍 [DEBUG ${cuentaConfig.alias}] Validando header:`, headerFila);
                        // }
                        
                        headerFila.forEach((col, idx) => {
                            const esString = typeof col === 'string';
                            const colStr = col ? col.toString().toUpperCase() : '';
                            const contieneTerminos = colStr.includes('FECHA') || colStr.includes('IMPORTE') || 
                                                   colStr.includes('MONTO') || colStr.includes('DESCRIPCION') || 
                                                   colStr.includes('REFERENCIA') || colStr.includes('MOVIMIENTO');
                            // if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                            //     //console.log(`  [${cuentaConfig.alias}] Columna ${idx}: "${col}" -> esString: ${esString}, contieneTerminos: ${contieneTerminos}`);
                            // }
                        });
                        
                        const esHeaderValido = headerFila.some(col => 
                            col && typeof col === 'string' && 
                            (col.toUpperCase().includes('FECHA') || 
                             col.toUpperCase().includes('IMPORTE') || 
                             col.toUpperCase().includes('MONTO') ||
                             col.toUpperCase().includes('DESCRIPCION') ||
                             col.toUpperCase().includes('REFERENCIA') ||
                             col.toUpperCase().includes('MOVIMIENTO'))
                        );
                        
                        // if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                        //     //console.log(`🔍 [DEBUG ${cuentaConfig.alias}] Header válido: ${esHeaderValido}`);
                        // }
                        //console.log(`🔍🔍🔍🔍🔍🔍🔍🔍🔍`);
                        //console.log(`🔍 [DEBUG ${cuentaConfig.alias}] `);
                        //console.log(`🔍 [DEBUG ${cuentaConfig.alias}] `);
                        //console.log(`🔍 [DEBUG ${cuentaConfig.alias}] `);
                        //console.log(`🔍🔍🔍🔍🔍🔍🔍🔍🔍`);

                        if (!esHeaderValido) {

                            // Generar header por defecto según el banco
                            let headerPorDefecto;
                            if (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD') {
                                headerPorDefecto = ['Fecha', 'Movimiento', 'Importe', 'Referencia', 'CDR', 'Módulo', 'Transac.', 'Relación'];
                            } else if (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD') {
                                headerPorDefecto = ['Fecha', 'Fecha valuta', 'Descripción operación', 'Monto', 'Saldo', 'Sucursal', 'Operación - Número', 'Operación - Hora', 'Usuario', 'UTC', 'Referencia2'];
                            } else if (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD') {
                                headerPorDefecto = ['F. Operación', 'F. Valor', 'Código', 'Nº. Doc.', 'Concepto', 'Importe', 'Oficina'];
                            } else if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                                headerPorDefecto = ['Fecha', 'Fecha Valor', 'Número', 'Concepto', 'Descripción', 'Cód. Aux', 'Monto', 'Vencimiento', 'Saldo'];
                            } else {
                                headerPorDefecto = ['Fecha', 'Descripción', 'Monto', 'Referencia', 'Saldo'];
                            }
                            
                            // Crear nueva estructura: [header por defecto, ...datos desde dataInicio]
                            const datosEstructurados = [headerPorDefecto];
                            if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                                //console.log(`🔍 [${cuentaConfig.alias}] USANDO HEADER POR DEFECTO:`, headerPorDefecto);
                                //console.log(`🔍 [${cuentaConfig.alias}] Recorriendo desde fila ${datosDesde} hasta ${jsonData.length}`);
                            }
                            for (let i = datosDesde; i < jsonData.length; i++) {
                                if ((cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') && i < datosDesde + 3) {
                                    //console.log(`🔍 [${cuentaConfig.alias}] Fila ${i}:`, jsonData[i]);
                                }
                                datosEstructurados.push(jsonData[i]);
                            }
                            


                            jsonData = datosEstructurados;
                        } else {
                            // Header válido, usar estructura normal
                            const datosEstructurados = [headerFila];
                            if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                                //console.log(`✅ [${cuentaConfig.alias}] USANDO HEADER REAL:`, headerFila);
                                //console.log(`✅ [${cuentaConfig.alias}] Recorriendo desde fila ${datosDesde} hasta ${jsonData.length}`);
                            }
                            for (let i = datosDesde; i < jsonData.length; i++) {
                                if ((cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') && i < datosDesde + 3) {
                                    //console.log(`✅ [${cuentaConfig.alias}] Fila ${i}:`, jsonData[i]);
                                }
                                datosEstructurados.push(jsonData[i]);
                            }
                            


                            jsonData = datosEstructurados;
                        }
                    }
                    
                    // 🔧 DIAGNÓSTICO FINAL: Verificar datos que se devuelven
                    if (jsonData.length > 0) {
                        if (jsonData.length > 1) {
                        }
                    }
                    
                     resolve(jsonData);
                 } catch (error) {
                     reject(error);
                 }
             };
             reader.onerror = () => reject(new Error('Error al leer el archivo'));
             reader.readAsArrayBuffer(file);
         });
            },

            getFileIcon(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                const icons = {
                    'xlsx': 'fas fa-file-excel',
                    'xls': 'fas fa-file-excel',
                    'csv': 'fas fa-file-csv',
                    'txt': 'fas fa-file-alt'
                };
                return icons[extension] || 'fas fa-file';
            },

            getFileType(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                return extension.toUpperCase();
            },

            getCategoryColor(category) {
                const colors = {
                    'mayor': 'bg-blue-100 text-blue-800',
                    'extracto': 'bg-green-100 text-green-800',
                    'resumen': 'bg-purple-100 text-purple-800',
                    'cheques': 'bg-orange-100 text-orange-800',
                    'otro': 'bg-gray-100 text-gray-800'
                };
                return colors[category] || colors['otro'];
            },

            getFileCategory(fileName) {
                const name = fileName.toLowerCase();
                
                // === CATEGORIZACIÓN BASADA EN CONFIGURACIÓN DE CUENTAS ===
                
                // 1. Verificar si es archivo de extracto por cuenta específica
                const cuentaDetectada = this.detectarCuentaPorArchivo(fileName);
                if (cuentaDetectada) {
                    const { config } = cuentaDetectada;
                    return `Extracto ${config.banco} - ${config.alias} (${config.moneda})`;
                }
                
                // 2. Patrones para Mayor: MAYOR.PEN.MMAAAA o MAYOR.USD.MMAAAA
                if (name.match(/^mayor\.(pen|usd)\.\d{6}/)) {
                    const match = name.match(/^mayor\.(pen|usd)\.\d{6}/);
                    const moneda = match[1].toUpperCase();
                    return `Mayor Analítico (${moneda})`;
                }
                
                // 3. Patrones para Saldo: SALDO.PEN.MMAAAA o SALDO.USD.MMAAAA
                if (name.match(/^saldo\.(pen|usd)\.\d{6}/)) {
                    const match = name.match(/^saldo\.(pen|usd)\.\d{6}/);
                    const moneda = match[1].toUpperCase();
                    return `Saldo Anterior (${moneda})`;
                }
                
                // 4. Patrones legacy para compatibilidad
                if (name.includes('mayor') || name.includes('analitico')) {
                    return 'Mayor Analítico';
                } else if (name.includes('extracto') || name.includes('banco')) {
                    return 'Extractos Bancarios';
                } else if (name.includes('resumen') || name.includes('saldo')) {
                    return 'Resumen de Saldos';
                } else {
                    return 'Archivo General';
                }
            },

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },

            formatResultKey(key) {
                const labels = {
                    fecha: 'Fecha de Conciliación',
                    archivo_generado: 'Archivo Generado',
                    registros_procesados: 'Registros Procesados'
                };
                return labels[key] || key.replace(/_/g, ' ').toUpperCase();
            },

            formatResultValue(key, value) {
                if (key === 'fecha') {
                    return new Date(value).toLocaleString();
                }
                return value;
            },

            showStatus(message, type) {
                this.statusMessage = {
                    show: true,
                    text: message,
                    type: type
                };

                setTimeout(() => {
                    this.statusMessage.show = false;
                }, 5000);
            },

            // === FUNCIONES DE FORMATO PARA RESULTADOS ===
            
            formatResultKey(key) {
                const labels = {
                    fecha: 'Fecha de Conciliación',
                    archivo_generado: 'Archivo Generado',
                    registros_procesados: 'Registros Procesados'
                };
                return labels[key] || key.replace(/_/g, ' ').toUpperCase();
            },

            formatResultValue(key, value) {
                if (key === 'fecha') {
                    return new Date(value).toLocaleString('es-ES', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
                return value;
            },

            // === FUNCIÓN PARA CARGAR ARCHIVOS DE PRUEBA ===
            loadTestFiles() {
                // Crear archivos de prueba simulados con la nomenclatura correcta
                const currentDate = new Date();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const year = currentDate.getFullYear();
                const periodo = `${month}${year}`;
                
                const testFiles = [
                    {
                        name: `MAYOR.PEN.${periodo}.xlsx`,
                        size: 150000,
                        category: 'mayor',
                        content: 'Archivo simulado de Mayor Analítico'
                    },
                    {
                        name: `BCP.01.PEN.${periodo}.xlsx`,
                        size: 85000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BCP.01'
                    },
                    {
                        name: `BCP.02.PEN.${periodo}.xlsx`,
                        size: 82000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BCP.02'
                    },
                    {
                        name: `SANT.PEN.${periodo}.xlsx`,
                        size: 78000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto Santander'
                    },
                    {
                        name: `BBVA.PEN.${periodo}.xlsx`,
                        size: 65000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BBVA'
                    },
                    {
                        name: `IBK.PEN.${periodo}.xlsx`,
                        size: 72000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto Interbank'
                    },
                    {
                        name: `SALDO.PEN.${periodo}.xlsx`,
                        size: 25000,
                        category: 'resumen',
                        content: 'Archivo simulado de Saldo Anterior'
                    }
                ];
                
                // Crear objetos File simulados
                testFiles.forEach(testFile => {
                    const blob = new Blob([testFile.content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const file = new File([blob], testFile.name, { type: blob.type });
                    
                    const fileObj = {
                        id: Date.now() + Math.random(),
                        name: testFile.name,
                        size: testFile.size,
                        file: file,
                        category: testFile.category
                    };
                    
                    this.files.push(fileObj);
                });
                
                this.showStatus(`${testFiles.length} archivos de prueba cargados con nomenclatura ${periodo}`, 'success');
                this.saveFilesToStorage();
            },

            async descargarConciliacion() {
                if (!this.conciliationResult) {
                    this.showStatus('No hay conciliación para descargar', 'error');
                    return;
                }

                try {
                                    const data = {
                    fecha_conciliacion: this.conciliationResult.detalles?.fecha || new Date().toISOString().split('T')[0],
                    registros_procesados: this.conciliationResult.totalProcesados || 0,
                    conciliados: this.conciliationResult.conciliados || 0,
                    no_conciliados: this.conciliationResult.noConciliados || 0
                };

                    const jsonString = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `resumen_conciliacion_${new Date().toISOString().split('T')[0]}.json`;
                    
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    this.showStatus('Resumen de conciliación descargado exitosamente', 'success');
                } catch (error) {
                    this.showStatus('Error al descargar resumen de conciliación', 'error');
                }
            },

    // === FUNCIÓN MULTI-CUENTA NUEVA ===
            procesarConciliacionMultiCuenta(extractosPorCuenta, datosMayorPEN, datosSaldo = null, datosMayorUSD = null) {
                // Inicializar variable global para registros omitidos del Paso 2 (TARJETAS)
                window.registrosOmitidosPaso2 = [];
                const resultadosPorCuenta = new Map();
                
                // === MAP COMPARTIDO PARA ESTADOS DE SALDO ===
                // Crear un Map compartido que acumule estados de todas las cuentas
                let estadosSaldoCompartidos = new Map();
                if (datosSaldo && datosSaldo.length > 1) {
                    const filasSaldo = datosSaldo.slice(1);
                    for (let i = 0; i < filasSaldo.length; i++) {
                        estadosSaldoCompartidos.set(i, { estado: 'Pendiente', ref: '' });
                    }
                    //console.log(`📊 [MULTI-CUENTA] Map compartido de estados saldo inicializado con ${estadosSaldoCompartidos.size} registros`);
                }
                
                // Procesar cada cuenta por separado
                extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                    if (codigoCuenta === '1041302') {
        
                    }
                    
                    // Seleccionar el archivo mayor apropiado según la cuenta
                    let datosMayorParaCuenta;
                    const cuentasUSDMaestras = ['1041502', '1041402', '1041202', '1041302', '1041102']; // Lista de referencia USD (BCP, SANT, BBVA, SBP, IBK)
                    
                    if (cuentasUSDMaestras.includes(codigoCuenta) && datosMayorUSD) {
                        // Cuentas USD: usar archivo MAYOR.USD
                        datosMayorParaCuenta = datosMayorUSD;
                        if (codigoCuenta === '1041302') {
            
                        }
                    } else {
                        // Cuentas PEN: usar archivo MAYOR.PEN
                        datosMayorParaCuenta = datosMayorPEN;
                        if (codigoCuenta === '1041302') {
        
                        }
                    }
                    
                    // Llamar a la función de conciliación pasando información de cuenta específica
                    const resultadoCuenta = this.procesarConciliacion(
                        extractoInfo.datos, 
                        datosMayorParaCuenta, 
                        datosSaldo, 
                        extractoInfo.config, // ← NUEVO: Pasar configuración de cuenta
                        estadosSaldoCompartidos // ← NUEVO: Pasar Map compartido de estados saldo
                    );
                    resultadosPorCuenta.set(codigoCuenta, {
                        config: extractoInfo.config,
                        resultado: resultadoCuenta,
                        archivo: extractoInfo.archivo
                    });
                    
                    if (codigoCuenta === '1041302') {
        
        
                    }
                });
                
                // === VERIFICAR SBP.USD (DIAGNÓSTICO MEJORADO) ===





                
                if (extractosPorCuenta.has('1041302')) {
                    const sbpInfo = extractosPorCuenta.get('1041302');





                } else if (datosMayorUSD && this.cuentasConfig['1041302'] && this.cuentasConfig['1041302'].activo) {
                    // Solo forzar si NO se detectó archivo de extracto

                    
                    // Buscar columna CUENTA dinámicamente (igual que arriba)
                    const headerMayorUSD = datosMayorUSD.length > 1 ? datosMayorUSD[1] : [];
                    const indicesMayorUSD = this.buscarIndicesColumnas(headerMayorUSD, {
                        cuenta: ['CUENTA']
                    });
                    
                    let filasSBPUSD = [];
                    if (indicesMayorUSD.cuenta !== -1) {
                        filasSBPUSD = datosMayorUSD.filter(fila => {
                            const cuenta = fila[indicesMayorUSD.cuenta] || '';
                        const cuentaStr = cuenta.toString().trim();
                            return cuentaStr.includes('1041302');
                        });
                    } else {

                        filasSBPUSD = [];
                    }
                    

                    
                    if (filasSBPUSD.length > 0) {

                        extractosPorCuenta.set('1041302', {
                            config: this.cuentasConfig['1041302'],
                            datos: [], // Sin datos de extracto - solo fallback
                            archivo: 'FORZADO_MAYOR_USD'
                        });

                    } else {

                    }
                } else {

                }
                
                // === APLICAR ESTADOS FINALES DE SALDO COMPARTIDOS ===
                // Aplicar todos los estados acumulados de todas las cuentas al saldo final
                let datosSaldoConEstados = datosSaldo; // Por defecto usar datos originales
                
                if (datosSaldo && datosSaldo.length > 1 && estadosSaldoCompartidos.size > 0) {
                    //console.log(`📊 [MULTI-CUENTA] Aplicando estados finales de saldo compartidos: ${estadosSaldoCompartidos.size} registros`);
                    
                    // Crear datos de saldo para la hoja de trabajo
                    const headerSaldoOriginal = datosSaldo[0];
                    // Filtrar columnas ESTADO y #REF si ya existen en el header original
                    const headerSaldoSinEstado = headerSaldoOriginal.filter((col, idx) => {
                        const colUpper = String(col).toUpperCase();
                        return colUpper !== 'ESTADO' && colUpper !== '#REF' && colUpper !== 'REF';
                    });
                    
                    // Encontrar la última columna con datos reales
                    let ultimaColumnaConDatos = headerSaldoSinEstado.length - 1;
                    for (let i = headerSaldoSinEstado.length - 1; i >= 0; i--) {
                        if (headerSaldoSinEstado[i] && String(headerSaldoSinEstado[i]).trim() !== '') {
                            ultimaColumnaConDatos = i;
                            break;
                        }
                    }
                    
                    // Cortar el header eliminando las columnas vacías al final
                    const headerSaldoLimpiado = headerSaldoSinEstado.slice(0, ultimaColumnaConDatos + 1);
                    const headerSaldo = [...headerSaldoLimpiado, 'ESTADO', '#REF'];
                    
                    const datosSaldoSinHeader = datosSaldo.slice(1);
                    
                    // Asegurar que cada fila tenga las columnas ESTADO y #REF
                    const datosSaldoHoja = datosSaldoSinHeader.map(fila => {
                        // Cortar también las columnas vacías al final para alinear con el header
                        const filaCortada = fila.slice(0, ultimaColumnaConDatos + 1);
                        return [...filaCortada, '', '']; // Agregar ESTADO y #REF vacíos
                    });
                    
                    // Aplicar estados compartidos
                    this.aplicarEstadosASaldo([headerSaldo, ...datosSaldoHoja], estadosSaldoCompartidos);
                    
                    // Guardar los datos con estados aplicados para pasar a consolidarResultadosMultiCuenta
                    datosSaldoConEstados = [headerSaldo, ...datosSaldoHoja];
                    
                    //console.log(`✅ [MULTI-CUENTA] Estados de saldo aplicados exitosamente`);
                    //console.log(`📊 [MULTI-CUENTA] Datos saldo con estados listos para consolidación: ${datosSaldoConEstados.length} filas`);
                }
                
                // Consolidar resultados - PASAR datosSaldoConEstados en lugar de datosSaldo original
                const resultadoFinal = this.consolidarResultadosMultiCuenta(resultadosPorCuenta, datosMayorPEN, datosSaldoConEstados, datosMayorUSD);
                return resultadoFinal;
            },

            // === FUNCIÓN PARA CONSOLIDAR MAYOR DE MÚLTIPLES CUENTAS ===
            consolidarDatosMayorPorCuentas(resultadosPorCuenta) {
                if (resultadosPorCuenta.size === 0) {
                    return [];
                }

                let headerMayor = null;
                const registrosConsolidados = [];
                const registrosYaProcesados = new Set();

                let totalOriginal = 0;
                let duplicadosEliminados = 0;

                // Consolidación Mayor Multi-cuenta

                // Recorrer cada cuenta y consolidar sus datos del mayor
                resultadosPorCuenta.forEach((cuentaInfo, codigoCuenta) => {
                    if (cuentaInfo.resultado && cuentaInfo.resultado.datosMayor) {
                        const datosMayorCuenta = cuentaInfo.resultado.datosMayor;
                        const registrosCuenta = datosMayorCuenta.length - 1; // Sin header
                        totalOriginal += registrosCuenta;
                        
                        
                        // Tomar el header del primer resultado (todos deberían ser iguales)
                        if (!headerMayor && datosMayorCuenta.length > 0) {
                            headerMayor = datosMayorCuenta[0];
                        }
                        
                        // Agregar registros de datos (saltando el header)
                        for (let i = 1; i < datosMayorCuenta.length; i++) {
                            const registro = datosMayorCuenta[i];
                            
                            // ⭐ CLAVE MÁS ESPECÍFICA PARA EVITAR FALSOS DUPLICADOS
                            // Incluir más columnas: DES_TDOP, NUMDOC, FDOC, LIBRO, COMPROB, CUENTA, GLOSA, DEBE, HABER
                            const claveRegistro = registro.slice(0, 13).join('|'); // Primeras 13 columnas en lugar de 8
                            
                            if (!registrosYaProcesados.has(claveRegistro)) {
                                registrosConsolidados.push(registro);
                                registrosYaProcesados.add(claveRegistro);
                            } else {
                                duplicadosEliminados++;
                                if (codigoCuenta === '1041401' && duplicadosEliminados <= 3) {
                                }
                            }
                        }
                        
                    }
                });


                // Construir resultado final con header + todos los registros
                const resultado = headerMayor ? [headerMayor, ...registrosConsolidados] : registrosConsolidados;
                
                // Mayor consolidado
                
                return resultado;
            },

            // === FUNCIÓN PARA FILTRAR MAYOR POR CUENTAS ESPECÍFICAS ===
            // NOTA: Para MAYOR.USD ahora se usa el archivo completo sin filtrado
            filtrarMayorPorCuentas(datosMayor, cuentasPermitidas) {



                
                if (!datosMayor || datosMayor.length < 2) {

                    return [];
                }
                
                // Obtener header del mayor (fila 2)
                const headerMayor = datosMayor[1];
                const indicesMayor = this.buscarIndicesColumnas(headerMayor, {
                    cuenta: ['CUENTA']
                });
                


                
                if (indicesMayor.cuenta === -1) {

                    return datosMayor; // Retornar todo si no se puede filtrar
                }
                
                // === DIAGNÓSTICO: VER QUÉ CUENTAS EXISTEN EN EL ARCHIVO ===
                const cuentasEncontradas = new Set();
                const filasData = datosMayor.slice(2);
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    if (codigoCuenta) {
                        cuentasEncontradas.add(codigoCuenta);
                    }
                });
                

                
                // === DIAGNÓSTICO: VER CUÁLES DE LAS 5 USD EXISTEN ===
                const cuentasUSDRequeridas = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                const cuentasUSDEncontradas = cuentasUSDRequeridas.filter(cuenta => cuentasEncontradas.has(cuenta));
                const cuentasUSDFaltantes = cuentasUSDRequeridas.filter(cuenta => !cuentasEncontradas.has(cuenta));
                


                
                // Filtrar filas según las cuentas permitidas
                const filasFiltered = [];
                
                // Agregar filas de encabezado (fila 0 y 1)
                filasFiltered.push(datosMayor[0]);
                filasFiltered.push(datosMayor[1]);
                
                // Filtrar filas de datos (desde fila 2) con conteo por cuenta
                const contadorPorCuenta = {};
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    
                    // Verificar si la cuenta está en la lista de cuentas permitidas
                    if (cuentasPermitidas.includes(codigoCuenta)) {
                        filasFiltered.push(fila);
                        contadorPorCuenta[codigoCuenta] = (contadorPorCuenta[codigoCuenta] || 0) + 1;
                    }
                });
                


                Object.entries(contadorPorCuenta).forEach(([cuenta, cantidad]) => {

                });
                
                return filasFiltered;
            },

            // === FUNCIÓN PARA EXCLUIR CUENTAS ESPECÍFICAS DEL MAYOR ===
            excluirCuentaDelMayor(datosMayor, cuentasExcluir) {
                if (!datosMayor || datosMayor.length < 2) {
                    return [];
                }
                
                // Obtener header del mayor (fila 2)
                const headerMayor = datosMayor[1];
                const indicesMayor = this.buscarIndicesColumnas(headerMayor, {
                    cuenta: ['CUENTA']
                });
                
                if (indicesMayor.cuenta === -1) {

                    return datosMayor; // Retornar todo si no se puede filtrar
                }
                
                // Filtrar filas excluyendo las cuentas especificadas
                const filasFiltered = [];
                
                // Agregar filas de encabezado (fila 0 y 1)
                filasFiltered.push(datosMayor[0]);
                filasFiltered.push(datosMayor[1]);
                
                // Filtrar filas de datos (desde fila 2)
                const filasData = datosMayor.slice(2);
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    
                    // Verificar si la cuenta NO está en la lista de cuentas a excluir
                    if (!cuentasExcluir.includes(codigoCuenta)) {
                        filasFiltered.push(fila);
                    }
                });
                
                
                return filasFiltered;
            },

            // Consolidar todos los resultados en estructura final
            consolidarResultadosMultiCuenta(resultadosPorCuenta, datosMayorPEN, datosSaldo, datosMayorUSD = null) {
                let totalProcesados = 0;
                
                // === CONSOLIDAR DATOS MAYOR PEN (solo cuentas PEN) ===
                const resultadosPEN = new Map();
                const resultadosUSD = new Map();
                
                // Separar resultados por moneda usando función maestra
                const cuentasUSDMaestras = ['1041502', '1041402', '1041202', '1041302', '1041102']; // Lista de referencia USD (BCP, SANT, BBVA, SBP, IBK)
                
                resultadosPorCuenta.forEach((valor, codigo) => {
                    if (cuentasUSDMaestras.includes(codigo)) {
                        resultadosUSD.set(codigo, valor);
                        if (codigo === '1041302') {
        
                        }
                    } else {
                        resultadosPEN.set(codigo, valor);
                    }
                });
                if (resultadosUSD.has('1041302')) {
    
                } else {

                }
                
                // Consolidar MAYOR.PEN (solo cuentas PEN)
                const datosMayorConsolidadoPEN = this.consolidarDatosMayorPorCuentas(resultadosPEN);
                
                // === CONSOLIDAR MAYOR.USD CON LÓGICA DE CONCILIACIÓN RESTAURADA ===

                let datosMayorUSDFinal = null;
                
                if (resultadosUSD.size > 0) {
                    // OPCIÓN 1: Usar consolidación cuenta por cuenta (como antes)

                    
                    if (resultadosUSD.has('1041302')) {
                        const sbpInfo = resultadosUSD.get('1041302');
                        const mayorLength = sbpInfo.resultado?.datosMayor?.length || 0;
                        const extractoLength = sbpInfo.resultado?.datosExtracto?.length || 0;

                    } else {

                    }
                    
                    datosMayorUSDFinal = this.consolidarDatosMayorPorCuentas(resultadosUSD);

                } else if (datosMayorUSD) {
                    // OPCIÓN 2: Filtrado directo con estructura correcta (fallback)

                    
                    // Buscar header real en MAYOR.USD
                    let filaHeaderReal = -1;
                    for (let i = 0; i < Math.min(5, datosMayorUSD.length); i++) {
                        const fila = datosMayorUSD[i];
                        if (fila && fila.length > 7 && 
                            (String(fila[7]).includes('CUENTA') || String(fila[0]).includes('DES_TDOC'))) {
                            filaHeaderReal = i;
                            break;
                        }
                    }
                    
                    if (filaHeaderReal !== -1) {
                        const cuentasUSDFiltro = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                        const filasFiltradas = [];
                        
                        // Header con ESTADO y #REF en columnas O y P
                        const headerOriginal = datosMayorUSD[filaHeaderReal];
                        const headerAjustado = [...headerOriginal];
                        while (headerAjustado.length < 14) headerAjustado.push('');
                        headerAjustado[14] = 'ESTADO'; // Columna O
                        headerAjustado[15] = '#REF';   // Columna P
                        filasFiltradas.push(headerAjustado);
                        
                        // Datos filtrados por cuenta
                        for (let i = filaHeaderReal + 1; i < datosMayorUSD.length; i++) {
                            const fila = datosMayorUSD[i];
                            const cuentaColumnaH = String(fila[7] || '').trim();
                            
                            if (cuentasUSDFiltro.includes(cuentaColumnaH)) {
                                const filaAjustada = [...fila];
                                while (filaAjustada.length < 14) filaAjustada.push('');
                                filaAjustada[14] = 'Pendiente'; // Columna O
                                filaAjustada[15] = '';          // Columna P
                                filasFiltradas.push(filaAjustada);
                            }
                        }
                        
                        datosMayorUSDFinal = filasFiltradas;
    
                    }
                } else {

                }
                
                // Preparar extractos por cuenta
                const extractosPorCuentaResultado = new Map();
                
                resultadosPorCuenta.forEach((cuentaInfo, codigoCuenta) => {
                    if (codigoCuenta === '1041302') {
    
    
    
    
                    }
                    
                    if (cuentaInfo.resultado && cuentaInfo.resultado.datosExtracto) {
                        if (codigoCuenta === '1041302') {
    
                            if (cuentaInfo.resultado.datosExtracto.length > 0) {
    
                            }
                        }
                        
                        extractosPorCuentaResultado.set(codigoCuenta, {
                            config: cuentaInfo.config,
                            datosExtracto: cuentaInfo.resultado.datosExtracto, // ✅ DEBE INCLUIR HEADERS
                            archivo: cuentaInfo.archivo
                        });
                        totalProcesados += cuentaInfo.resultado.totalProcesados || 0;
                        if (codigoCuenta === '1041302') {
    
                        }
                    } else if (cuentaInfo.archivo === 'MAYOR_USD_ONLY' || cuentaInfo.archivo === 'FORZADO_MAYOR_USD') {
                        // Para cuentas USD sin extracto real, crear entrada vacía
                        extractosPorCuentaResultado.set(codigoCuenta, {
                            config: cuentaInfo.config,
                            datosExtracto: [], // Sin datos de extracto
                            archivo: cuentaInfo.archivo
                        });
    
                        totalProcesados += cuentaInfo.resultado?.totalProcesados || 0;
                    } else {

                    }
                });
                
                // Usar datosSaldo con estados aplicados que se pasaron como parámetro
                // En lugar de usar datos del primer resultado individual
                const datosSaldoConsolidado = datosSaldo || [];
                //console.log(`📊 [CONSOLIDAR] Usando datosSaldo con estados aplicados: ${datosSaldoConsolidado.length} filas`);
                
                return {
                    datosMayor: datosMayorConsolidadoPEN, // MAYOR.PEN (solo cuentas PEN procesadas)
                    datosMayorUSD: datosMayorUSDFinal, // MAYOR.USD (cuenta 1041502 desde archivo propio)
                    extractosPorCuenta: extractosPorCuentaResultado, // Nueva estructura
                    datosSaldo: datosSaldoConsolidado, // ✅ USAR datosSaldo con estados aplicados
                    totalProcesados: totalProcesados
                };
            },

    // --- Lógica de Conciliación Principal (mantenida del código original) ---
            procesarConciliacion(datosExtracto, datosMayor, datosSaldo = null, cuentaConfig = null, estadosSaldoCompartidos = null) {
                if (datosSaldo && datosSaldo.length > 0) {
                }

        if (datosExtracto && datosExtracto.length > 0) {

            if (datosExtracto.length > 1) {

            }
        }
        

        // --- MAPEO DE ÍNDICES ---
        const headersMayorRow = datosMayor.length > 1 ? datosMayor[1] : [];
        
                const indicesMayor = this.buscarIndicesColumnas(headersMayorRow, {
            cuenta: ['CUENTA'], glosa: ['GLOSA'], paso: ['PASO'], fdoc: ['FDOC', 'FECHA'],
            debe: ['DEBE'], haber: ['HABER'], numdoc: ['NUMDOC'], libro: ['LIBRO'], 
            desTdop: ['DES_TDOP'], comprob: ['COMPROB']
        });

        // === HEADERS DINÁMICOS SEGÚN CUENTA ===
        // Determinar fila del header según configuración de cuenta
        let filaHeader = 4; // Por defecto fila 5 (índice 4) para BCP
        let filaDataInicio = 5; // Por defecto fila 6 (índice 5) para BCP
        
        if (cuentaConfig && cuentaConfig.estructuraEspecial) {
            // IMPORTANTE: Si readExcelFile aplicó estructuraEspecial, los datos YA están reestructurados
            // con header en fila 0 y datos desde fila 1. NO recalcular las posiciones.


            filaHeader = 0; // Header ya reestructurado en fila 0 por readExcelFile
            filaDataInicio = 1; // Datos ya reestructurados desde fila 1 por readExcelFile
        }
        
        const headersExtracto = datosExtracto.length > filaHeader ? datosExtracto[filaHeader] : [];
                // === MAPEO DINÁMICO DE COLUMNAS SEGÚN EL BANCO ===
        let camposMapeados = {
            fecha: ['FECHA', 'Fecha'], 
            monto: ['MONTO', 'IMPORTE', 'Monto', 'Importe'], 
            operacion: ['OPERACION', 'NUMERO', 'Operacion', 'Numero'],
            descripcion: ['DESCRIPCION OPERACION', 'DESCRIPCIÓN OPERACIÓN', 'DESCRIPCION', 'DESC', 'MOVIMIENTO', 'Descripcion Operacion', 'Descripcion', 'Desc', 'Movimiento']
        };
        
        // Ajustar mapeo específico por banco
        if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
            camposMapeados = {
                fecha: ['FECHA', 'Fecha'],
                monto: ['IMPORTE', 'Importe'],
                operacion: ['REFERENCIA', 'Referencia'],
                descripcion: ['MOVIMIENTO', 'Movimiento']
            };
        } else if (cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD')) {
            camposMapeados = {
                fecha: ['FECHA', 'Fecha'],
                monto: ['IMPORTE', 'MONTO', 'Importe', 'Monto'],
                operacion: ['REFERENCIA', 'NUMERO', 'Referencia', 'Numero'],
                descripcion: ['DESCRIPCION', 'CONCEPTO', 'Descripcion', 'Concepto']
            };
        } else if (cuentaConfig && (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD')) {
            camposMapeados = {
                fecha: ['F. OPERACION', 'FECHA', 'F. Operacion', 'Fecha'],
                monto: ['IMPORTE', 'MONTO', 'Importe', 'Monto'],
                operacion: ['NUMERO', 'REFERENCIA', 'Numero', 'Referencia'],
                descripcion: ['CONCEPTO', 'DESCRIPCION', 'Concepto', 'Descripcion']
            };
        }
        
        const indicesExtracto = this.buscarIndicesColumnas(headersExtracto, camposMapeados);
        // 🔧 DIAGNÓSTICO: Mostrar mapeo de columnas para SBP.USD
        if (cuentaConfig && (cuentaConfig.alias === 'SBP.USD')) {
        }
        
        
        
        // --- ESTRUCTURA GLOBAL PARA ESTADOS DEL SALDO ---
        // Usar Map compartido si está disponible, sino crear uno local
        let estadosSaldo = estadosSaldoCompartidos || new Map();
        
        // Solo inicializar si no hay Map compartido y hay datos de saldo
        if (!estadosSaldoCompartidos && datosSaldo && datosSaldo.length > 1) {
            const filasSaldo = datosSaldo.slice(1);
            for (let i = 0; i < filasSaldo.length; i++) {
                estadosSaldo.set(i, { estado: 'Pendiente', ref: '' });
            }
            //console.log(`📊 [CONCILIACION] Map local de estados saldo inicializado con ${estadosSaldo.size} registros`);
        } else if (estadosSaldoCompartidos) {
            //console.log(`📊 [CONCILIACION] Usando Map compartido de estados saldo con ${estadosSaldo.size} registros`);
        }
        
        // VERIFICAR QUE LOS ÍNDICES CRÍTICOS ESTÉN BIEN MAPEADOS
        const indicesCriticos = ['numdoc', 'glosa', 'debe', 'haber', 'comprob'];
        indicesCriticos.forEach(campo => {
            if (indicesMayor[campo] === -1) {

            } else {

            }
        });
        
        // --- FILTROS APLICADOS ---
        let dataRowsMayor = datosMayor.slice(2);
        // === PASO 1: Filtro por Cuenta Específica (si se proporciona) ===
        let filasFiltradasMayor = dataRowsMayor;
        
        if (indicesMayor.cuenta !== -1) {
            const countInicial = filasFiltradasMayor.length;
            
            if (cuentaConfig && cuentaConfig.codigo) {
                const codigoCuentaEspecifica = cuentaConfig.codigo;
                
                if (codigoCuentaEspecifica === '1041401') {



                    
                    // Mostrar ejemplos de cuentas en las primeras 10 filas

                    for (let i = 0; i < Math.min(10, filasFiltradasMayor.length); i++) {
                        const cuentaEjemplo = (filasFiltradasMayor[i][indicesMayor.cuenta] || '').toString();
                        const coincide = cuentaEjemplo === codigoCuentaEspecifica;

                    }
                }
                
            filasFiltradasMayor = filasFiltradasMayor.filter(fila => {
                const cuenta = (fila[indicesMayor.cuenta] || '').toString();
                    return cuenta === codigoCuentaEspecifica;
                });
                
                if (codigoCuentaEspecifica === '1041401') {


                }
                
        } else {
                // Fallback: Filtrar por todas las cuentas activas (para compatibilidad)
                const cuentasActivas = this.getCuentasFiltro();
                
                filasFiltradasMayor = filasFiltradasMayor.filter(fila => {
                    const cuenta = (fila[indicesMayor.cuenta] || '').toString();
                    return cuentasActivas.includes(cuenta);
                });
                
            }
        } else {
        }
        
        // PASO 2: Omisiones Globales - Excluir términos específicos en GLOSA y capturar para TARJETAS
        const terminosExclusion = ["AMERICAN EXP", "CALIDDA", "DINERS", "MASTER CARD", "MERCADOPAGO", "VISANET", "POWERPAY"];
        if (indicesMayor.glosa !== -1) {
            const countAntesFiltro = filasFiltradasMayor.length;
            
            filasFiltradasMayor.slice(0, 3).forEach((fila, idx) => {
                const glosa = fila[indicesMayor.glosa] || '';
            });
            
            let filasExcluidas = 0;
            const filasRestantes = [];
            
            filasFiltradasMayor.forEach(fila => {
                const glosa = (fila[indicesMayor.glosa] || '').toString().toUpperCase();
                const excluir = terminosExclusion.some(termino => glosa.startsWith(termino.toUpperCase()));
                
                if (excluir) {
                    filasExcluidas++;
                    // Capturar registro omitido para la pestaña TARJETAS
                    const cuenta = fila[indicesMayor.cuenta] || '';
                    const descrip = fila[indicesMayor.descrip] || '';
                    const fdoc = fila[indicesMayor.fdoc] || '';
                    const glosaCelda = fila[indicesMayor.glosa] || '';
                    const debe = parseFloat(fila[indicesMayor.debe]) || 0;
                    const haber = parseFloat(fila[indicesMayor.haber]) || 0;
                    
                    // Determinar qué término coincidió
                    const terminoCoincidente = terminosExclusion.find(termino => 
                        glosa.startsWith(termino.toUpperCase())
                    );
                    
                    window.registrosOmitidosPaso2.push({
                        cuenta,
                        descrip,
                        fdoc,
                        glosa: glosaCelda,
                        debe,
                        haber,
                        termino: terminoCoincidente
                    });
                } else {
                    filasRestantes.push(fila);
                }
            });
            
            filasFiltradasMayor = filasRestantes;
        } else {
        }
        // Preparar extracto para conciliación (datos empiezan dinámicamente según cuenta)
        let extractoProcesable = datosExtracto.slice(filaDataInicio).map(fila => ({ fila, conciliado: false }));
        // VERIFICAR CUÁNTAS ANULACIONES HAY EN TOTAL
        const anulacionesEncontradas = filasFiltradasMayor.filter(fila => {
            const glosa = fila[indicesMayor.glosa] || '';
            return glosa.toUpperCase().includes('ANULADO');
        });
        // Mostrar primeras 3 anulaciones como muestra
        anulacionesEncontradas.slice(0, 3).forEach((fila, idx) => {
            const numdoc = fila[indicesMayor.numdoc] || '';
            const glosa = fila[indicesMayor.glosa] || '';
            const debe = fila[indicesMayor.debe] || '';
            const haber = fila[indicesMayor.haber] || '';
        });

        // === PREPARACIÓN PARA PROCESAMIENTO MULTI-CUENTA ===
        // Agrupar filas por cuenta para futuro procesamiento paralelo
        const filasPorCuenta = new Map();
        filasFiltradasMayor.forEach((fila, index) => {
            const cuenta = (fila[indicesMayor.cuenta] || '').toString();
            if (!filasPorCuenta.has(cuenta)) {
                filasPorCuenta.set(cuenta, []);
            }
            filasPorCuenta.get(cuenta).push({ fila, index });
        });
        
        // filasPorCuenta.forEach((filas, cuenta) => {
        // });

        // --- PROCESO DE CONCILIACIÓN ---
        const resultados = [];
        let paso3Procesados = 0;
        let paso3Conciliados = 0;
        let paso3Etapa2 = 0; // Etapa 3b: Anulado Saldo
        let paso3Etapa3 = 0; // Etapa 3c: Anulaciones en Mayor
        
        // NUEVO ENFOQUE: Mapear estados para todas las filas primero
        const estadosFilas = new Map(); // índice → {estado, ref}
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            if (i % 100 === 0) { // Log cada 100 iteraciones para no saturar
            }
            const filaMayor = filasFiltradasMayor[i];
            const glosa = filaMayor[indicesMayor.glosa] || '';
            const numdoc = filaMayor[indicesMayor.numdoc] || '';
            
            // Si ya fue procesada como parte de un par, continuar
            if (estadosFilas.has(i)) continue;
            
            // Verificar si es anulación por GLOSA
            const esAnulacion = glosa.toUpperCase().includes('ANULADO');

            if (esAnulacion && paso3Procesados < 3) {
            }
            
            if (esAnulacion) {
                paso3Procesados++;
                const resultadoPaso3 = this.procesarPaso3(filaMayor, extractoProcesable, indicesMayor, indicesExtracto, filasFiltradasMayor, datosSaldo, i);
                
                if (resultadoPaso3.estado) {
                    // Asignar estado a la fila actual
                    estadosFilas.set(i, {
                        estado: resultadoPaso3.estado,
                        ref: resultadoPaso3.ref || ''
                    });
                    
                    paso3Conciliados++;
                    
                    // Si hay pareja interna (ETAPA 3c), asignar estado también a la pareja
                    if (resultadoPaso3.etapa === 3 && resultadoPaso3.indiceParejaEncontrada !== -1) {
                        const indicePareja = resultadoPaso3.indiceParejaEncontrada;
                        estadosFilas.set(indicePareja, {
                            estado: resultadoPaso3.estadoPareja,
                            ref: resultadoPaso3.refPareja
                        });
                        
                        
                        paso3Conciliados++; // Contar también la pareja
                    }
                    
                    // Contar por etapa
                    if (resultadoPaso3.etapa === 2) {
                        paso3Etapa2++; // Etapa 3b: Anulado Saldo
                        
                        if (resultadoPaso3.indiceParejaEncontrada !== -1 && datosSaldo && datosSaldo.length > 1) {
                            // Actualizar estado de la fila correspondiente en saldo
                            estadosSaldo.set(resultadoPaso3.indiceParejaEncontrada, {
                                estado: resultadoPaso3.estadoPareja,
                                ref: resultadoPaso3.refPareja
                            });
                            
                        }
                        
                    } else if (resultadoPaso3.etapa === 3) {
                        paso3Etapa3++; // Etapa 3c: Anulaciones en Mayor
                    }
                } else {
                    // Caso por defecto para anulados no procesados
                    estadosFilas.set(i, {
                        estado: 'Anulado Sin Procesar',
                        ref: numdoc
                    });
                }
            }
        }
        // PASO 4: Operaciones BNA (Banco de la Nación)
        const estadosExtracto = new Map(); // Para rastrear estados del extracto
        
        const resultadosPaso4 = this.procesarPaso4(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // PASO 5: Operaciones PROT y DEV (Agrupación por totales diarios)
        const resultadosPaso5 = this.procesarPaso5(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        const resultadosPaso6 = this.procesarPaso6(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        const resultadosPaso7 = this.procesarPaso7(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        
        
        const resultadosPaso8 = this.procesarPaso8(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        
        
        const resultadosPaso9 = this.procesarPaso9(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // Paso 9 completado
        
        // Mostrar estadísticas de P9B si existen
        if (resultadosPaso9.conciliadosP9B !== undefined) {
        }
        
        
        const resultadosPaso10 = this.procesarPaso10(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, datosSaldo, estadosSaldo);
        
        
        const resultadosPaso11 = this.procesarPaso11(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        
        // === PASO 12 - AGRUPACIÓN POR BANCO (DESPUÉS DE ITF) ===
        
        
        // Detectar banco específico para lógica especializada
        const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
        const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
        const esBCP = cuentaConfig && (cuentaConfig.codigo === '1041501' || cuentaConfig.codigo === '1041505' || cuentaConfig.codigo === '1041502');
        const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
        const esDET = cuentaConfig && (cuentaConfig.codigo === '1042101');
        
        if (esDET) {
        }
        
        let resultadosPaso12;
        if (esBBVA) {
            resultadosPaso12 = this.procesarPaso12BBVA(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esSBP) {
            resultadosPaso12 = this.procesarPaso12SBP(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esBCP) {
            resultadosPaso12 = this.procesarPaso12BCP(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esIBK) {
            resultadosPaso12 = this.procesarPaso12IBK(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esDET) {
            // Para DET necesitamos acceso a TODOS los datos del Mayor (todas las cuentas)
            // Usar datosMayor completo (parámetro original) que contiene TODOS los registros
            resultadosPaso12 = this.procesarPaso12DET(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig, datosMayor);
        } else {
            resultadosPaso12 = this.procesarPaso12Santander(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        }
        // Paso 12 completado
        
        // Crear resultados finales con estados asignados
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            const estadoInfo = estadosFilas.get(i);
            
            const estadoAsignado = estadoInfo ? estadoInfo.estado : 'Pendiente';
            const refAsignada = estadoInfo ? estadoInfo.ref : '';

            if (estadoInfo && estadoInfo.estado === 'P5 - Conciliada') {
            }

            // Agregar estado y referencia a la fila
            const filaCompleta = [...filaMayor, estadoAsignado, refAsignada];
            resultados.push(filaCompleta);
            
            if (resultados.length === 1) {
            }
        }

        // USAR SOLO LAS PRIMERAS 14 COLUMNAS ESTÁNDAR DEL MAYOR
        const columnasEstandar = [
            'DES_TDOP', 'NUMDOC', 'FDOC', 'CUO', 'LIBRO', 'COMPROB', 
            'FECHCON', 'CUENTA', 'DESCRIP', 'CODAUX', 'RAZON SOCI', 
            'GLOSA', 'DEBE', 'HABER'
        ];
        
        // Agregar las nuevas columnas al final (columnas O y P)
        const cabeceraFinal = [...columnasEstandar, 'ESTADO', '#REF'];
        
        // Filtrar solo las primeras 14 columnas de cada fila + las 2 nuevas
        const resultadosFiltrados = resultados.map(fila => {
            const filaBase = fila.slice(0, 14); // Solo primeras 14 columnas
            const estado = fila[fila.length - 2]; // ESTADO (penúltima)
            const ref = fila[fila.length - 1]; // #REF (última)
            return [...filaBase, estado, ref];
        });
        
        const datosFinales = [cabeceraFinal, ...resultadosFiltrados];
        
        if (resultadosFiltrados[0]) {
        }
        
        // MUESTRA DE PRIMERAS 3 FILAS PARA VERIFICACIÓN
        datosFinales.slice(0, 3).forEach((fila, index) => {
            if (index === 0) {
            } else {
            }
        });
        
        
        // CONTEO FINAL DE ESTADOS
        const estadosContados = {};
        resultadosFiltrados.forEach(fila => {
            const estado = fila[fila.length - 2]; // Penúltima columna (ESTADO)
            estadosContados[estado] = (estadosContados[estado] || 0) + 1;
        });
        
        
        
        
        
        
        
        
        
        
        Object.entries(estadosContados).forEach(([estado, cantidad]) => {
        });
        
        // MOSTRAR MUESTRA DE ANULACIONES PROCESADAS
        const anulacionesProcesadas = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            const ref = fila[fila.length - 1];
            return estado === 'P3 - Conciliada' || estado.includes('Anulado') || estado.includes('Anula a');
        });
        
        // anulacionesProcesadas.slice(0, 10).forEach((fila, idx) => {
        //     const numdoc = fila[1] || ''; // NUMDOC en índice 1
        //     const debe = fila[12] || ''; // DEBE en índice 12  
        //     const haber = fila[13] || ''; // HABER en índice 13
        //     const estado = fila[fila.length - 2]; // ESTADO
        //     const ref = fila[fila.length - 1]; // #REF
        // });
        
        // MOSTRAR CASOS ESPECÍFICOS DEL USUARIO
        const caso43335 = resultadosFiltrados.find(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43335';
        });
        
        const casos43676 = resultadosFiltrados.filter(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43676';
        });
        
        // if (caso43335) {
        //     const estado = caso43335[caso43335.length - 2];
        //     const ref = caso43335[caso43335.length - 1];
        // }
        
        // if (casos43676.length > 0) {
        //     casos43676.forEach((fila, idx) => {
        //         const debe = fila[12] || '';
        //         const haber = fila[13] || '';
        //         const estado = fila[fila.length - 2];
        //         const ref = fila[fila.length - 1];
        //     });
        // }
        
        // MOSTRAR RESULTADOS DEL PASO 4
        const casosPaso4 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P4 - Conciliada');
        });
        
        if (casosPaso4.length > 0) {
            casosPaso4.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const debe = fila[12] || ''; // DEBE 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
            });
        }
        
        // MOSTRAR CASOS ESPECÍFICOS DEL PASO 5
        const casosPaso5 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P5 - Conciliada');
        });
        
        if (casosPaso5.length > 0) {
            casosPaso5.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const libro = fila[4] || ''; // LIBRO
                const glosa = (fila[11] || '').substring(0, 20); // GLOSA truncada
                const haber = fila[13] || ''; // HABER 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
                
            });
        }

        // PREPARAR DATOS PARA LAS 3 HOJAS
        
        // HOJA 1: MAYOR (filas filtradas después del paso 2)
        const datosMayorHoja = [cabeceraFinal, ...resultadosFiltrados];
        
        // HOJA 2: EXTRACTO (dinámico según estructura de cuenta + agregar ESTADO y #REF procesados)
        let datosExtractoHoja;
        if (datosExtracto.length > filaHeader) {
            // Header del extracto (dinámico según cuenta) + columnas ESTADO y #REF
            let headerExtracto;
            if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                // Para SBP: asegurar que ESTADO esté en columna I y #REF en columna J
                const headerOriginal = datosExtracto[filaHeader] || [];
                // Filtrar columnas ESTADO y #REF si ya existen
                const headerSinEstado = headerOriginal.filter((col, idx) => {
                    const colUpper = String(col).toUpperCase();
                    return colUpper !== 'ESTADO' && colUpper !== '#REF' && colUpper !== 'REF';
                });
                headerExtracto = [...headerSinEstado];
                // Rellenar hasta la columna I (8) si es necesario
                while (headerExtracto.length < 8) {
                    headerExtracto.push('');
                }
                headerExtracto[8] = 'ESTADO'; // Columna I
                headerExtracto[9] = '#REF';   // Columna J
            } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                // Para IBK: mapear headers desde B12-J12 a A1-I1, luego ESTADO en J1 y #REF en K1
                const headerOriginal = datosExtracto[filaHeader] || [];
                // Tomar datos desde columna B hasta J (índices 1-9) del archivo original
                const headersIBKOriginal = headerOriginal.slice(1, 10); // B12 hasta J12
                // Filtrar columnas ESTADO y #REF si ya existen
                const headersIBK = headersIBKOriginal.filter((col, idx) => {
                    const colUpper = String(col).toUpperCase();
                    return colUpper !== 'ESTADO' && colUpper !== '#REF' && colUpper !== 'REF';
                });
                headerExtracto = [...headersIBK, 'ESTADO', '#REF']; // Reorganizar en A1-K1
            } else {
                // Para otros bancos (SANT, BBVA, etc.): extraer header y añadir columnas adicionales
                const headerOriginal = datosExtracto[filaHeader] || [];
                
                // Headers por defecto si no se pueden extraer del archivo
                const headersDefault = ['Fecha', 'Fecha valuta', 'Descripción operación', 'Monto', 'Saldo', 'Sucursal - agencia', 'Operación - Número', 'Operación - Hora', 'Usuario', 'UTC', 'Referencia2'];
                
                if (headerOriginal.length > 0) {
                    // Si hay header en el archivo, asegurar que ESTADO y #REF estén siempre en las últimas dos posiciones
                    // Si el header original ya tiene ESTADO, eliminarlo primero
                    const headerOriginalSinEstado = headerOriginal.filter((col, idx) => {
                        const colUpper = String(col).toUpperCase();
                        return colUpper !== 'ESTADO' && colUpper !== '#REF' && colUpper !== 'REF';
                    });
                    headerExtracto = [...headerOriginalSinEstado, 'ESTADO', '#REF'];
                } else {
                    // Si no hay header, usar headers por defecto
                    headerExtracto = [...headersDefault, 'ESTADO', '#REF'];
                }
                
            }
            
            // Verificar que extractoProcesable existe y es un array
            if (extractoProcesable && Array.isArray(extractoProcesable)) {
                // Datos del extracto (dinámico según cuenta) con estados procesados
                const datosExtractoSinHeader = extractoProcesable.map((item, idx) => {
                    // Verificar si esta fila fue procesada en PASO 4
                    const estadoInfo = estadosExtracto.get(idx);
                    
                    // ⭐ VERIFICAR QUE TENGA DATOS REALES ANTES DE ASIGNAR "Pendiente"
                    const filaOriginal = item.fila;
                    let fechaExtracto, importeExtracto;
                    
                    if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                        // Para IBK e IBK.USD: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        fechaExtracto = filaOriginal[indicesIBK.fechaOperacion] || '';     // Fecha operación
                        const cargo = filaOriginal[indicesIBK.cargo] || '0';              // Cargo
                        const abono = filaOriginal[indicesIBK.abono] || '0';               // Abono
                        // Considerar que tiene importe si tiene Cargo O Abono (no necesariamente ambos)
                        importeExtracto = (parseFloat(cargo) !== 0 || parseFloat(abono) !== 0) ? '1' : '0';
                    } else {
                        // Para otros bancos: usar estructura estándar
                        fechaExtracto = filaOriginal[0] || '';
                        importeExtracto = filaOriginal[6] || '0';
                    }
                    
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    // Para IBK: considerar válido si tiene fecha O importe (no necesariamente ambos)
                    const tieneDatosReales = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') 
                        ? (tieneFecha || tieneImporte) 
                        : (tieneFecha && tieneImporte);
                    
                    // Solo asignar "Pendiente" si tiene datos reales y no tiene estado procesado
                    // Para DET, BN e IBK: asignar "Pendiente" solo si tiene datos reales
                    let estado;
                    if (estadoInfo) {
                        estado = estadoInfo.estado;
                    } else if (cuentaConfig && (cuentaConfig.alias === 'DET' || cuentaConfig.alias === 'BN' || cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                        estado = tieneDatosReales ? 'Pendiente' : ''; // Para DET, BN e IBK: solo Pendiente si tiene datos reales
                        
                        // Debug para IBK: mostrar registros sin estado
                        if ((cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') && !tieneDatosReales && filaOriginal && filaOriginal.length > 0) {
                           /* //console.log('🔍 [DEBUG IBK] Registro sin estado:', {
                                fecha: fechaExtracto,
                                tieneFecha: tieneFecha,
                                cargo: cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD' ? filaOriginal[7] : 'N/A',
                                abono: cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD' ? filaOriginal[8] : 'N/A',
                                tieneImporte: tieneImporte,
                                tieneDatosReales: tieneDatosReales,
                                fila: filaOriginal.slice(0, 5) // Primeras 5 columnas para debug
                            });
                            */
                        }
                    } else {
                        estado = tieneDatosReales ? 'Pendiente' : ''; // Para otros bancos: solo si tiene datos reales
                    }
                    const ref = estadoInfo ? estadoInfo.ref : '';
                    
                    // ⭐ CREAR NUEVA FILA SEGÚN EL BANCO
                    let filaNueva;
                    
                    if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                        // Para IBK: reorganizar datos desde B12-J12 a A1-I1, luego ESTADO en J1 y #REF en K1
                        // Tomar datos desde columna B hasta J (índices 1-9) del archivo original
                        const datosIBK = filaOriginal.slice(1, 10); // B12 hasta J12
                        filaNueva = [...datosIBK, estado, ref]; // Reorganizar en A1-K1
                    } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                        // Para DET: usar estructura específica con 7 columnas originales + columna H + ESTADO + #REF
                        // Nro, Fecha, Trans, Documento, Oficina, Cargo, Abono, [H], ESTADO, #REF
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        // Asegurar que las columnas ESTADO y #REF estén en las posiciones correctas
                        while (filaNueva.length < 10) {
                            filaNueva.push(''); // Rellenar hasta tener 10 columnas
                        }
                        filaNueva[8] = estado; // Columna I - ESTADO
                        filaNueva[9] = ref;    // Columna J - #REF
                    } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                        // Para BN: estructura pendiente de definir
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        // Agregar ESTADO y #REF al final hasta tener la estructura específica
                        filaNueva.push(estado); // ESTADO
                        filaNueva.push(ref);    // #REF
                    } else {
                        // Para SANT/SBP y otros bancos: preservar columnas originales
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        
                    if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                        // SBP tiene 8 columnas (A-H), rellenar hasta la columna I (8) y J (9)
                        while (filaNueva.length < 8) {
                            filaNueva.push(''); // Rellenar columnas faltantes si es necesario
                        }
                        filaNueva[8] = estado; // ESTADO en columna I (índice 8)
                        filaNueva[9] = ref;    // #REF en columna J (índice 9)
                    } else {
                        // SANT y otros bancos: añadir ESTADO y #REF al final
                        filaNueva.push(estado); // Añadir ESTADO como nueva columna
                        filaNueva.push(ref);    // Añadir #REF como nueva columna
                        }
                    }
                    
                    return filaNueva;
                });
                
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
            } else {
                // Fallback: usar datos básicos del extracto (dinámico según cuenta)
                let datosExtractoSinHeader;
                if (cuentaConfig && cuentaConfig.alias === 'IBK') {
                    // Para IBK: reorganizar datos desde B12-J12 a A1-I1 en fallback también
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio)
                        .filter(fila => fila && Array.isArray(fila) && fila.length > 0 && fila.some(celda => celda && celda.toString().trim() !== '')) // Solo filas con datos reales
                        .map(fila => {
                            const datosIBK = fila.slice(1, 10); // B hasta J
                            return [...datosIBK, 'Pendiente', '']; // Reorganizar + ESTADO + #REF
                        });
                } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                    // Para DET: asegurar estructura correcta con ESTADO y #REF en posiciones específicas
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => {
                        const filaNueva = [...fila];
                        // Asegurar que hay 10 columnas (A-J) para DET
                        while (filaNueva.length < 10) {
                            filaNueva.push('');
                        }
                        filaNueva[8] = 'Pendiente'; // Columna I - ESTADO
                        filaNueva[9] = '';          // Columna J - #REF
                        return filaNueva;
                    });
                } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                    // Para BN: estructura pendiente de definir
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => [
                        ...fila, 
                        'Pendiente', // ESTADO al final
                        '' // #REF al final
                    ]);
                } else {
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => [
                    ...fila, 
                    'Pendiente', // ESTADO por defecto
                    '' // #REF vacío
                ]);
                }
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
            }
        } else {
            // Fallback: generar header por defecto según el banco
            let headerFallback;
            if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                headerFallback = ['Fecha', 'Movimiento', 'Importe', 'Referencia', 'CDR', 'Módulo', 'Transac.', 'Relación', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                headerFallback = ['Fecha', 'Concepto', 'Número', 'Descripción', 'Monto', 'Cód. Aux', 'Vencimiento', 'Relac.', 'Agencia', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD')) {
                headerFallback = ['Fecha', 'Importe', 'Descripción', 'Referencia', 'Saldo', 'Sucursal', 'Número', 'Hora', 'Usuario', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD')) {
                headerFallback = ['F. Operación', 'Concepto', 'Importe', 'Número', 'Descripción', 'Saldo', 'Sucursal', 'Hora', 'Referencia', 'ESTADO', '#REF'];
            } else {
                // BCP y otros bancos estándar
                headerFallback = ['Fecha', 'Fecha valuta', 'Descripción operación', 'Monto', 'Saldo', 'Sucursal - agencia', 'Operación - Número', 'Operación - Hora', 'Usuario', 'UTC', 'Referencia2', 'ESTADO', '#REF'];
            }
            
            datosExtractoHoja = [headerFallback];
        }
        
        // HOJA 3: SALDO (usar datos reales si están disponibles + agregar ESTADO y #REF)
        let datosSaldoHoja;
        if (datosSaldo && datosSaldo.length > 0) {
            // Header del saldo
            const headerSaldoOriginal = datosSaldo[0] || [];
            // Filtrar columnas ESTADO y #REF si ya existen en el header original
            const headerSaldoSinEstado = headerSaldoOriginal.filter((col, idx) => {
                const colUpper = String(col).toUpperCase();
                return colUpper !== 'ESTADO' && colUpper !== '#REF' && colUpper !== 'REF';
            });
            
            // Encontrar la última columna con datos reales
            let ultimaColumnaConDatos = headerSaldoSinEstado.length - 1;
            for (let i = headerSaldoSinEstado.length - 1; i >= 0; i--) {
                if (headerSaldoSinEstado[i] && String(headerSaldoSinEstado[i]).trim() !== '') {
                    ultimaColumnaConDatos = i;
                    break;
                }
            }
            
            // Cortar el header eliminando las columnas vacías al final
            const headerSaldoLimpiado = headerSaldoSinEstado.slice(0, ultimaColumnaConDatos + 1);
            
            // Agregar ESTADO y #REF al final del header
            const headerSaldo = [...headerSaldoLimpiado, 'ESTADO', '#REF'];
            
            // Datos del saldo
            const datosSaldoSinHeader = datosSaldo.slice(1).map(fila => {
                // Cortar también las columnas vacías al final para alinear con el header
                const filaCortada = fila.slice(0, ultimaColumnaConDatos + 1);
                
                // Solo asignar "Pendiente" si la fila tiene datos reales (no está vacía)
                const tieneDatos = filaCortada.some(celda => celda && celda.toString().trim() !== '');
                const estado = tieneDatos ? 'Pendiente' : '';
                
                return [...filaCortada, estado, ''];
            });
            
            datosSaldoHoja = [headerSaldo, ...datosSaldoSinHeader];
        } else {
            // Datos simulados si no hay archivo de saldo
            const headerSimulado = [
                'CUENTA', 'DESCRIP', 'Banco', 'Concepto Reporte Final', 'FDOC', 
                'GLOSA 1', 'NUMDOC', 'DEBE', 'HABER',
                'ESTADO', '#REF'
            ];
            datosSaldoHoja = [headerSimulado];
        }
        
        // --- APLICAR ESTADOS FINALES AL SALDO ---
        // NOTA: En modo multi-cuenta, los estados se aplican al final en procesarConciliacionMultiCuenta
        // Solo aplicar individualmente si no hay Map compartido
        if (!estadosSaldoCompartidos && datosSaldo && datosSaldo.length > 1 && estadosSaldo.size > 0) {
            this.aplicarEstadosASaldo(datosSaldoHoja, estadosSaldo);
            //console.log(`📊 [CONCILIACION] Estados de saldo aplicados individualmente para cuenta`);
        } else if (estadosSaldoCompartidos) {
            //console.log(`📊 [CONCILIACION] Estados de saldo se aplicarán al final en modo multi-cuenta`);
        }
        if (datosSaldoHoja && datosSaldoHoja.length > 0) {
        }
        return {
            datosMayor: datosMayorHoja,
            datosExtracto: datosExtractoHoja, // ✅ INCLUYE HEADERS
            datosSaldo: datosSaldoHoja,
            totalProcesados: filasFiltradasMayor.length
        };
            },

            procesarPaso4(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 4 - OPERACIONES ESPECÍFICAS POR BANCO:
                
                BCP (GENERAL) - OPERACIONES BNA (BANCO DE LA NACIÓN):
                ETAPA 4A - MAPEO CON EXTRACTO BANCARIO:
                - DES_TDOP = "Bna", LIBRO = "04"
                - MAPEO: FDOC + DEBE vs FECHA + MONTO
                
                BBVA (CONTINENTAL) - OPERACIONES ABONO/CARGO CART:
                
                ETAPA 1 - MAPEO CON EXTRACTO:
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto:
                1. Identificar Concepto que INICIEN con "ABONO CART" y "CARGO CART"
                2. Agrupar por F. Operación  
                3. F. Operación + |Importe| (suma con signo, luego valor absoluto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR:
                Candidatos: DES_TDOP = "Bna" + DEBE > 0 + pendientes
                Destinos: CUALQUIER registro pendiente (sin filtro DES_TDOP)
                Criterio: mismo FDOC + DEBE candidato = HABER destino
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados
                */
                
                // ⭐ VERIFICAR SI ES BBVA, SBP O IBK PARA USAR LÓGICA ESPECÍFICA
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
                const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
                const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                
                if (esBBVA) {
                    return this.procesarPaso4BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else if (esSBP) {
                    return this.procesarPaso4SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    return this.procesarPaso4IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else {
                    // Lógica estándar BCP (incluyendo BCP.USD)
                    if (esBCPUSD) {
                    }
                }
                
                // ETAPA 4A - Contadores
                let candidatosBNA = 0;
                let conciliadosExtracto = 0;
                let filasPendientes = 0;
                let filasConBNA = 0;
                let filasConLibro04 = 0;
                let filasConDebe = 0;
                
                // ETAPA 4B - Contadores  
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliadosInternos = 0;
                
                // =======================================================
                // ETAPA 4A: MAPEO CON EXTRACTO BANCARIO (BNA + LIBRO 04)
                // =======================================================
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    const filaMayor = filasFiltradasMayor[i];
                    
                    // Solo procesar si no tiene estado asignado (Pendiente)
                    if (estadosFilas.has(i)) continue;
                    filasPendientes++;
                    
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    if (i < 10) {
                    }
                    
                    // Diagnóstico específico para BCP.USD
                    if (esBCPUSD && i < 20) {
                    }
                    
                    // Verificar criterios del PASO 4
                    const esBNA = String(desTdop || '').trim().toUpperCase() === 'BNA';
                    const esLibro4 = String(libro || '').trim() === '04';
                    
                    // Contar cuántas filas cumplen cada criterio
                    if (esBNA) filasConBNA++;
                    if (esLibro4) filasConLibro04++;
                    if (debe > 0) filasConDebe++;
                    
                    // Diagnóstico adicional para BCP.USD
                    if (esBCPUSD && (esBNA || esLibro4 || debe > 0)) {
                    }
                    
                    if (esBNA && esLibro4 && debe > 0) {
                        candidatosBNA++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        
                        // Buscar match en extracto
                        const matchExtracto = this.buscarMatchExtracto(fdoc, debe, extractoProcesable, idxE, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            // Asignar estados a ambos registros
                            const refMayor = matchExtracto.operacionNumero; // Columna G del extracto
                            const refExtracto = `${libro}-${comprob}`; // LIBRO-COMPROB del mayor
                            
                            estadosFilas.set(i, {
                                estado: 'P4 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indice, {
                                estado: 'P4 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliadosExtracto++;
                            
                        } else {
                            if (candidatosBNA <= 5) {
                            }
                        }
                    }
                }
                
                // =======================================================
                // ETAPA 4B: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                
                // Buscar filas pendientes con LIBRO="04"
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Solo filas con LIBRO="04" y DEBE > 0
                    if (String(libro || '').trim() === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        if (candidatosLibro04 <= 5) {
                        }
                        
                        // Buscar coincidencia en LIBRO="09" con HABER similar
                        for (let j = 0; j < filasFiltradasMayor.length; j++) {
                            if (i === j || estadosFilas.has(j)) continue;
                            
                            const otraFila = filasFiltradasMayor[j];
                            const otroLibro = otraFila[idxM.libro] || '';
                            const otroHaber = this.normalizarMonto(otraFila[idxM.haber] || '0');
                            const otroComprob = otraFila[idxM.comprob] || '';
                            
                            if (String(otroLibro || '').trim() === '09' && otroHaber > 0) {
                                candidatosLibro09++;
                                
                                                // Verificar coincidencia de montos (exacto)
                const diferencia = Math.abs(debe - otroHaber);
                const coincide = diferencia === 0;
                                
                                if (candidatosLibro04 <= 5 && candidatosLibro09 <= 10) {
                                }
                                
                                if (coincide) {
                                    // Asignar estados a ambas filas
                                    estadosFilas.set(i, {
                                        estado: 'P4 - Conciliada',
                                        ref: `09-${otroComprob}`
                                    });
                                    
                                    estadosFilas.set(j, {
                                        estado: 'P4 - Conciliada', 
                                        ref: `04-${comprob}`
                                    });
                                    
                                    conciliadosInternos++;
                                    
                                    
                                    // Salir del bucle interno ya que encontramos el match
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Diagnóstico específico para BCP.USD
                if (esBCPUSD) {
                }
                
                
                return {
                    candidatos: candidatosBNA + candidatosLibro04,
                    conciliados: conciliadosExtracto + conciliadosInternos,
                    etapa4a: conciliadosExtracto,
                    etapa4b: conciliadosInternos
                };
            },

            procesarPaso4BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 4 BBVA - DOS ETAPAS (ABONO/CARGO CART):
                
                ETAPA 1 - MAPEO CON EXTRACTO:
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto BBVA:
                1. Identificar en "Concepto" que INICIEN con "ABONO CART" y "CARGO CART"
                2. Agrupar por "F. Operación"  
                3. "F. Operación" + |Importe| (suma con signo, luego valor absoluto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR (registros pendientes):
                1. Filtrar candidatos: DES_TDOP = "Bna" + DEBE > 0 + registros pendientes
                2. Buscar destinos: CUALQUIER registro pendiente (sin filtro DES_TDOP)
                3. Mapeo exacto: mismo FDOC + DEBE candidato = HABER destino
                
                HEADERS BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados en ambas etapas
                */
                
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0; 
                let conciliados = 0;
                let numeroGrupo = 1;
                
                // === 1. FILTRAR MAYOR POR DES_TDOP="Bna" Y AGRUPAR POR FDOC ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = filaMayor[idxM.desTdop] || '';  // DES_TDOP
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    
                    // FILTRO ESPECÍFICO BBVA: DES_TDOP = "Bna" + DEBE > 0
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && debe > 0) {
                        candidatosMayor++;
                        
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFechaMayor.has(fechaNormalizada)) {
                            gruposPorFechaMayor.set(fechaNormalizada, {
                                fechaOriginal: fdoc,
                                totalDebe: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFechaMayor.get(fechaNormalizada);
                        grupo.totalDebe += debe;
                        grupo.filas.push(i);
                        

                    }
                }
                
                

                
                // === 2. IDENTIFICAR EXTRACTO BBVA ABONO/CARGO CART ===  
                const registrosAbonoCargoCart = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Headers BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina
                    const fOperacion = filaExtracto[0] || '';     // F. Operación
                    const concepto = filaExtracto[4] || '';       // Concepto  
                    const importe = filaExtracto[5] || '0';       // Importe
                    
                    // Verificar si el concepto INICIA con "ABONO CART" o "CARGO CART"
                    const conceptoUpper = concepto.toString().toUpperCase();
                    const esAbonoCart = conceptoUpper.startsWith('ABONO CART');
                    const esCargoCart = conceptoUpper.startsWith('CARGO CART');
                    
                    if (esAbonoCart || esCargoCart) {
                        candidatosExtracto++;
                        
                        registrosAbonoCargoCart.push({
                            indice: i,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: this.normalizarMonto(importe), // MANTENER SIGNO (+ o -)
                            tipo: esAbonoCart ? 'ABONO CART' : 'CARGO CART'
                        });
                        

                    }
                }
                
                
                // === 3. AGRUPAR EXTRACTO POR F. OPERACIÓN ===
                const gruposPorFOperacion = new Map();
                
                registrosAbonoCargoCart.forEach(registro => {
                    const fOperacionNormalizada = this.normalizarFecha(registro.fOperacion); // Normalizar como fecha
                    
                    if (!gruposPorFOperacion.has(fOperacionNormalizada)) {
                        gruposPorFOperacion.set(fOperacionNormalizada, {
                            fOperacionOriginal: registro.fOperacion,
                            totalImporte: 0,
                            registros: []
                        });
                    }
                    
                    const grupo = gruposPorFOperacion.get(fOperacionNormalizada);
                    grupo.totalImporte += registro.importe; // Sumar con signo (+ o -)
                    grupo.registros.push(registro);
                });
                
                

                
                // === 4. COMPARACIÓN DE GRUPOS: MAYOR vs EXTRACTO ===
                
                // Obtener todas las fechas únicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFOperacion.keys())
                ]);
                
                for (const fecha of todasFechas) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoExtracto = gruposPorFOperacion.get(fecha);
                    
                    const tieneGrupoMayor = grupoMayor !== undefined;
                    const tieneGrupoExtracto = grupoExtracto !== undefined;
                    
                    let status = '';
                    let grupoId = '';
                    
                    if (tieneGrupoMayor && tieneGrupoExtracto) {
                        const totalExtractoAbsoluto = Math.abs(grupoExtracto.totalImporte);
                        const diff = Math.abs(grupoMayor.totalDebe - totalExtractoAbsoluto);
                        if (diff < 0.01) {
                            status = 'MATCH ✅';
                            grupoId = `${numeroGrupo}`;
                            
                            
                            // === CONCILIAR REGISTROS ===
                            const refGrupo = `BBVA-GRUPO-${numeroGrupo}`;
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P4 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const registroExtracto of grupoExtracto.registros) {
                                estadosExtracto.set(registroExtracto.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                            status = `DIFF ${diff.toFixed(2)} ❌`;
                            grupoId = '-';
                        }
                    } else if (tieneGrupoMayor) {
                        status = 'MAYOR SOLO';
                        grupoId = '-';
                    } else {
                        status = 'BBVA SOLO';
                        grupoId = '-';
                    }
                    
                    // Formatear datos para tabla
                    const fechaStr = (fecha || '').toString().padEnd(10);
                    const mayorStr = tieneGrupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : '           ';
                    const mayorDebe = tieneGrupoMayor ? (grupoMayor.totalDebe || 0).toFixed(2).padStart(11) : '           ';
                    const bbvaStr = tieneGrupoExtracto ? (grupoExtracto.fOperacionOriginal || '').toString().padEnd(10) : '          ';
                    const bbvaImporte = tieneGrupoExtracto ? Math.abs(grupoExtracto.totalImporte || 0).toFixed(2).padStart(11) : '           ';
                    const statusStr = status.padEnd(11);
                    const grupoStr = grupoId.toString().padStart(7);
                    
                }
                
                
                // === 5. MAPEO INTERNO MAYOR: BNA DEBE vs CUALQUIER HABER ===
                
                let conciliadosInternos = 0;
                let candidatosBnaDebe = 0;
                let candidatosHaberEncontrados = 0;
                
                // Recopilar candidatos BNA con DEBE
                const candidatosBna = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes (no conciliadas en etapa anterior)
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    
                    // Solo registros con DES_TDOP="Bna" y DEBE > 0
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && debe > 0) {
                        candidatosBnaDebe++;
                        candidatosBna.push({
                            indice: i,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob,
                            numdoc: numdoc,
                            fechaNormalizada: this.normalizarFecha(fdoc)
                        });
                    }
                }
                
                

                
                // === MAPEO Y CONCILIACIÓN INTERNA ===
                
                const registrosYaUsados = new Set();
                
                for (const candidatoBna of candidatosBna) {
                    // Skip si este candidato BNA ya fue usado
                    if (registrosYaUsados.has(candidatoBna.indice)) continue;
                    
                    // Buscar en TODOS los registros pendientes (sin filtro DES_TDOP)
                    for (let j = 0; j < filasFiltradasMayor.length; j++) {
                        // Skip si ya fue procesado en etapa anterior o ya usado en mapeo interno
                        if (estadosFilas.has(j) || registrosYaUsados.has(j) || j === candidatoBna.indice) continue;
                        
                        const filaDestino = filasFiltradasMayor[j];
                        const fdocDestino = filaDestino[idxM.fdoc] || '';
                        const haberDestino = this.normalizarMonto(filaDestino[idxM.haber] || '0');
                        const comprobDestino = filaDestino[idxM.comprob] || '';
                        const numdocDestino = filaDestino[idxM.numdoc] || '';
                        const desTdopDestino = filaDestino[idxM.desTdop] || '';
                        
                        // Verificar coincidencia: mismo FDOC + HABER igual al DEBE del BNA
                        const fechaDestinoNormalizada = this.normalizarFecha(fdocDestino);
                        const diff = Math.abs(candidatoBna.debe - haberDestino);
                        
                        if (candidatoBna.fechaNormalizada === fechaDestinoNormalizada && diff < 0.01 && haberDestino > 0) {
                            candidatosHaberEncontrados++;
                            
                            // Conciliar ambos registros
                            estadosFilas.set(candidatoBna.indice, {
                                estado: 'P4 - Conciliada',
                                ref: `HABER-${comprobDestino}`
                            });
                            
                            estadosFilas.set(j, {
                                estado: 'P4 - Conciliada',
                                ref: `BNA-${candidatoBna.comprob}`
                            });
                            
                            // Marcar como usados
                            registrosYaUsados.add(candidatoBna.indice);
                            registrosYaUsados.add(j);
                            
                            conciliadosInternos++;
                            break; // Salir del bucle para buscar siguiente candidato BNA
                        }
                    }
                }
                
                
                // === ETAPA 3: MAPEO DIRECTO LIBROS 4 Y 9 CON EXTRACTO ===
                
                let candidatosLibro4y9 = 0;
                let candidatosExtractoEtapa3 = 0;
                let conciliadosEtapa3 = 0;
                
                // Determinar moneda
                const esBBVAPEN = cuentaConfig && cuentaConfig.codigo === '1041201';
                const esBBVAUSD = cuentaConfig && cuentaConfig.codigo === '1041202';
                const moneda = esBBVAPEN ? 'PEN' : (esBBVAUSD ? 'USD' : 'DESCONOCIDA');
                
                
                // === 1. RECOPILAR REGISTROS MAYOR (LIBROS 4 Y 9) ===
                const registrosMayorL4L9 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes (no conciliadas en etapas anteriores)
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    
                    // Filtrar solo LIBRO = "04" o LIBRO = "09" con HABER > 0
                    if ((libro === '04' || libro === '09') && haber > 0) {
                        candidatosLibro4y9++;
                        
                        registrosMayorL4L9.push({
                            indice: i,
                            libro: libro,
                            fdoc: fdoc,
                            fdocNormalizado: this.normalizarFecha(fdoc),
                            debe: debe,
                            haber: haber,
                            comprob: comprob,
                            numdoc: numdoc
                        });
                    }
                }
                
                
                // Agrupar por libro para análisis detallado
                const gruposPorLibro = registrosMayorL4L9.reduce((acc, registro) => {
                    if (!acc[registro.libro]) acc[registro.libro] = [];
                    acc[registro.libro].push(registro);
                    return acc;
                }, {});
                
                Object.keys(gruposPorLibro).forEach(libro => {
                    const registros = gruposPorLibro[libro];
                    const totalHaber = registros.reduce((sum, r) => sum + r.haber, 0);
                    
                    // Mostrar primeros 5 registros de cada libro
                    registros.slice(0, 5).forEach((registro, idx) => {
                    });
                    if (registros.length > 5) {
                    }
                });
                
                // === 2. RECOPILAR REGISTROS EXTRACTO ===
                const registrosExtractoEtapa3 = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Headers BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina
                    const fOperacion = filaExtracto[0] || '';     // F. Operación
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe
                    const concepto = filaExtracto[4] || '';       // Concepto
                    
                    if (Math.abs(importe) > 0) {
                        candidatosExtractoEtapa3++;
                        
                        registrosExtractoEtapa3.push({
                            indice: i,
                            fOperacion: fOperacion,
                            fOperacionNormalizada: this.normalizarFecha(fOperacion),
                            importe: importe,
                            importeAbsoluto: Math.abs(importe),
                            concepto: concepto
                        });
                    }
                }
                
                
                // Agrupar extracto por signo (positivos/negativos) para análisis
                const extractoPositivos = registrosExtractoEtapa3.filter(r => r.importe >= 0);
                const extractoNegativos = registrosExtractoEtapa3.filter(r => r.importe < 0);
                const totalPositivos = extractoPositivos.reduce((sum, r) => sum + r.importeAbsoluto, 0);
                const totalNegativos = extractoNegativos.reduce((sum, r) => sum + r.importeAbsoluto, 0);
                
                
                // Mostrar detalles de los primeros registros de cada tipo
                if (extractoPositivos.length > 0) {
                    extractoPositivos.slice(0, 5).forEach((registro, idx) => {
                    });
                    if (extractoPositivos.length > 5) {
                    }
                }
                
                if (extractoNegativos.length > 0) {
                    extractoNegativos.slice(0, 5).forEach((registro, idx) => {
                    });
                    if (extractoNegativos.length > 5) {
                    }
                }
                
                // === 3. MAPEO DIRECTO: FDOC + HABER vs F. OPERACIÓN + IMPORTE ===
                
                
                for (const registroMayor of registrosMayorL4L9) {
                    // Buscar en extracto: misma fecha (FDOC = F. Operación) y mismo importe (HABER = |Importe|)
                    for (const registroExtracto of registrosExtractoEtapa3) {
                        // Verificar si ya fue procesado
                        if (estadosExtracto.has(registroExtracto.indice)) continue;
                        
                        // Comparar fecha normalizada
                        const mismafecha = registroMayor.fdocNormalizado === registroExtracto.fOperacionNormalizada;
                        
                        // Comparar importe (HABER del Mayor vs valor absoluto del Extracto)
                        const diffImporte = Math.abs(registroMayor.haber - registroExtracto.importeAbsoluto);
                        const mismoImporte = diffImporte < 0.01;
                        
                        if (mismafecha && mismoImporte) {
                            
                            const refDirectoEtapa3 = `BBVA-L4L9-${numeroGrupo}`;
                            
                            // Marcar registro Mayor como conciliado
                            estadosFilas.set(registroMayor.indice, {
                                estado: 'P4 - Conciliada',
                                ref: refDirectoEtapa3
                            });
                            
                            // Marcar registro Extracto como conciliado
                            estadosExtracto.set(registroExtracto.indice, {
                                estado: 'P4 - Conciliada',
                                ref: refDirectoEtapa3
                            });
                            
                            conciliadosEtapa3++;
                            numeroGrupo++;
                            
                            // Salir del bucle interno para evitar múltiples matches del mismo registro Mayor
                            break;
                        }
                    }
                }
                
                
                if (conciliadosEtapa3 > 0) {
                    const totalConciliado = registrosMayorL4L9
                        .filter((_, idx) => estadosFilas.has(registrosMayorL4L9[idx].indice))
                        .reduce((sum, r) => sum + r.haber, 0);
                }
                
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto + candidatosBnaDebe + candidatosHaberEncontrados + candidatosLibro4y9 + candidatosExtractoEtapa3,
                    conciliados: conciliados + conciliadosInternos + conciliadosEtapa3,
                    etapa4a: conciliados, // Conciliados con extracto (ABONO/CARGO CART)
                    etapa4b: conciliadosInternos, // Conciliados internos (BNA DEBE vs CUALQUIER HABER)
                    etapa4c: conciliadosEtapa3 // Conciliados ETAPA 3 (Libros 4 y 9 vs Extracto)
                };
            },

            procesarPaso4SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 4 SBP (SCOTIABANK) - OPERACIONES PAGO DE LETRA (2 ETAPAS):
                
                ETAPA 4A - MAPEO CON EXTRACTO:
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna" + LIBRO = "04" + ESTADO = "Pendiente"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto SBP:
                1. Identificar en "Movimiento" (columna B) que INICIEN con "PAGO DE LETRA"
                2. Agrupar por "Fecha" (columna A)  
                3. "Fecha" + |Importe| (columna C, valor absoluto)
                
                ETAPA 4B - MAPEO INTERNO:
                Mayor pendiente:
                1. Filtrar LIBRO = "04" (DEBE) vs LIBRO = "09" (HABER)
                2. Mapear por coincidencia de montos
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados en ambas etapas
                */
                
                
                // ETAPA 4A - Contadores
                let candidatosMayor4A = 0;
                let candidatosExtracto = 0; 
                let conciliados4A = 0;
                let numeroGrupo = 1;
                
                // ETAPA 4B - Contadores
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliados4B = 0;
                
                // =======================================================
                // ETAPA 4A: MAPEO CON EXTRACTO BANCARIO (BNA + LIBRO 04)
                // =======================================================
                
                const gruposMayor = new Map();
                
                // Primera pasada: Identificar candidatos BNA y agrupar por FDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = (filaMayor[idxM.desTdop] || '').toString().trim().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Filtrar por DES_TDOP = "BNA" + LIBRO = "04"
                    if (desTdop === 'BNA' && libro === '04' && debe > 0) {
                        candidatosMayor4A++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposMayor.has(fdocNormalizado)) {
                            gruposMayor.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalDebe: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposMayor.get(fdocNormalizado);
                        grupo.totalDebe += debe;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            debe: debe,
                            comprob: comprob,
                            libro: libro
                        });
                    }
                }
                
                // === ETAPA 2: AGRUPAR EXTRACTO POR FECHA ===
                const gruposExtracto = new Map();
                
                // Segunda pasada: Identificar "PAGO DE LETRA" y agrupar por fecha
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const fecha = filaExtracto[0] || ''; // Columna A
                    const movimiento = (filaExtracto[1] || '').toString().toUpperCase(); // Columna B
                    const importe = this.normalizarMonto(filaExtracto[2] || '0'); // Columna C
                    const referencia = filaExtracto[3] || ''; // Columna D
                    
                    // Filtrar solo "PAGO DE LETRA"
                    if (movimiento.startsWith('PAGO DE LETRA') && importe > 0) {
                        candidatosExtracto++;
                        
                        const fechaNormalizada = this.normalizarFecha(fecha);
                        
                        if (!gruposExtracto.has(fechaNormalizada)) {
                            gruposExtracto.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fecha,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposExtracto.get(fechaNormalizada);
                        grupo.totalImporte += Math.abs(importe);
                        grupo.filas.push({
                            indice: j,
                            fila: filaExtracto,
                            importe: Math.abs(importe),
                            referencia: referencia,
                            movimiento: movimiento
                        });
                    }
                }
                
                // === ETAPA 3: MAPEAR GRUPOS MAYOR vs EXTRACTO ===
                
                for (const [fechaMayor, grupoMayor] of gruposMayor) {
                    if (gruposExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposExtracto.get(fechaMayor);
                        
                        // Verificar coincidencia de totales
                        const diferencia = Math.abs(grupoMayor.totalDebe - grupoExtracto.totalImporte);
                        
                        if (diferencia < 0.01) { // Tolerancia mínima
                            const refExtracto = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].referencia : '';
                            const refMayor = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : '';
                            
                            // Marcar todas las filas del Mayor como conciliadas
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refExtracto
                                });
                                conciliados4A++;
                            });
                            
                            // Marcar todas las filas del Extracto como conciliadas
                            grupoExtracto.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados4A++;
                            });
                            
                            numeroGrupo++;
                        }
                    }
                }
                
                // =======================================================
                // ETAPA 4B: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                
                // Agrupar registros LIBRO 04 por FDOC
                const gruposLibro04 = new Map();
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const fila = filasFiltradasMayor[i];
                    const libro = fila[idxM.libro] || '';
                    const debe = this.normalizarMonto(fila[idxM.debe] || '0');
                    const fdoc = fila[idxM.fdoc] || '';
                    
                    if (libro === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposLibro04.has(fdocNormalizado)) {
                            gruposLibro04.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                totalDebe: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposLibro04.get(fdocNormalizado);
                        grupo.totalDebe += debe;
                        grupo.filas.push({ indice: i, fila, debe });
                    }
                }
                
                // Agrupar registros LIBRO 09 por FDOC
                const gruposLibro09 = new Map();
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const fila = filasFiltradasMayor[i];
                    const libro = fila[idxM.libro] || '';
                    const haber = this.normalizarMonto(fila[idxM.haber] || '0');
                    const fdoc = fila[idxM.fdoc] || '';
                    
                    if (libro === '09' && haber > 0) {
                        candidatosLibro09++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposLibro09.has(fdocNormalizado)) {
                            gruposLibro09.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposLibro09.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({ indice: i, fila, haber });
                    }
                }
                
                // Mapear grupos por FDOC y coincidencia de totales
                for (const [fdoc, grupo04] of gruposLibro04) {
                    if (gruposLibro09.has(fdoc)) {
                        const grupo09 = gruposLibro09.get(fdoc);
                        
                        const diferencia = Math.abs(grupo04.totalDebe - grupo09.totalHaber);
                        
                        if (diferencia < 0.01) { // Tolerancia mínima
                            // Marcar todas las filas del grupo LIBRO 04
                            grupo04.filas.forEach(item => {
                                const ref09 = grupo09.filas.length > 0 ? `L09-${grupo09.filas[0].fila[idxM.comprob] || ''}` : 'L09';
                                estadosFilas.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: ref09
                                });
                                conciliados4B++;
                            });
                            
                            // Marcar todas las filas del grupo LIBRO 09
                            grupo09.filas.forEach(item => {
                                const ref04 = grupo04.filas.length > 0 ? `L04-${grupo04.filas[0].fila[idxM.comprob] || ''}` : 'L04';
                                estadosFilas.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: ref04
                                });
                                conciliados4B++;
                            });
                        }
                    }
                }
                
                const totalConciliados = conciliados4A + conciliados4B;
                
                
                return {
                    candidatos: candidatosMayor4A + candidatosExtracto + candidatosLibro04 + candidatosLibro09,
                    conciliados: totalConciliados,
                    etapa4a: conciliados4A,
                    etapa4b: conciliados4B
                };
            },

            procesarPaso5(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 5 - OPERACIONES PROT Y DEV (Agrupación por Totales Diarios):
                
                CUENTA ESTÁNDAR (BCP, SANTANDER):
                CRITERIOS DE FILTRADO:
                - LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                - LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                CUENTA BBVA:
                Mayor: IDENTIFICAR TOTALES POR DÍA (PROT + DEV)
                Extracto: Concepto="DEV DOC COBRANZAS" + agrupar por F. Operación + |Importe|
                
                ESTRATEGIA DE AGRUPACIÓN:
                1. Agrupar por FDOC (fecha) los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por fecha
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                ESTADOS RESULTANTES:
                - Todas las filas del grupo: "P5 - Conciliada"
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                
                NOTA: Los montos del extracto están en negativo, se usa Math.abs()
                */
                
                // Verificar si es cuenta BBVA, SBP o IBK para usar lógica específica
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    return this.procesarPaso5BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                    return this.procesarPaso5SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                    return this.procesarPaso5IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                }
                
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Agrupar filas por FDOC que cumplan criterios
                const gruposPorFecha = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por fecha
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5
                    const esPROT = String(libro || '').trim() === '04' && glosa.startsWith('PROT');
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && glosa.startsWith('DEV');
                    
                    if (esPROT || esDEV) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        // if ((candidatosPROT + candidatosDEV) <= 5) {
                        // }
                        
                        // Normalizar fecha para agrupación
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFecha.has(fdocNormalizado)) {
                            gruposPorFecha.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFecha.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFecha.size;
                
                // Segunda pasada: Buscar matches en extracto para cada grupo
                for (const [fechaNormalizada, grupo] of gruposPorFecha.entries()) {
                    
                    // Buscar match en extracto
                    const matchExtracto = this.buscarMatchExtractoPorGrupo(fechaNormalizada, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        // Asignar estados a todas las filas del grupo
                        const refMayor = matchExtracto.operacionNumero; // Número de operación del extracto
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`; // Usar primer registro del grupo
                        
                        // IMPORTANTE: Todas las filas del grupo reciben el MISMO número de operación del extracto
                        grupo.filas.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P5 - Conciliada',
                                ref: refMayor // Mismo número de operación para todas las filas del grupo
                            });
                            
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P5 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        
                        // grupo.filas.forEach((item, idx) => {
                        // });
                    } else {
                        // if (gruposFormados <= 10) {
                        // }
                    }
                }
                
                
                return {
                    candidatos: candidatosPROT + candidatosDEV,
                    grupos: gruposFormados,
                    conciliados: conciliados
                };
            },

            procesarPaso5BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 BBVA - OPERACIONES DEV DOC COBRANZAS:
                
                Mayor: 
                1. IDENTIFICAR TOTALES POR DÍA
                2. Filtrar por LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                3. Filtrar por LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                4. Agrupar por FDOC + sumar HABER
                
                Extracto BBVA:
                1. Identificar en "Concepto" que contenga "DEV DOC COBRANZAS"
                2. Agrupar por "F. Operación" (fecha)
                3. "F. Operación" + |Importe| (valor absoluto)
                
                HEADERS BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                */
                
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === 1. AGRUPAR MAYOR POR FECHA (TOTALES POR DÍA) ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5 BBVA
                    const esPROT = String(libro || '').trim() === '04' && glosa.startsWith('PROT');
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && glosa.startsWith('DEV');
                    
                    if (esPROT || esDEV) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        // Normalizar fecha para agrupación
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFechaMayor.has(fdocNormalizado)) {
                            gruposPorFechaMayor.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFechaMayor.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFechaMayor.size;
                
                // === 2. AGRUPAR EXTRACTO POR F. OPERACIÓN (DEV DOC COBRANZAS) ===
                const gruposPorFOperacion = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operación (Col A)
                    const concepto = (filaExtracto[4] || '').toString().toUpperCase(); // Concepto (Col E)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    
                    // Verificar si contiene "DEV DOC COBRANZAS"
                    if (concepto.includes('DEV DOC COBRANZAS')) {
                        candidatosExtracto++;
                        
                        // Normalizar fecha para agrupación
                        const fOperacionNormalizada = this.normalizarFecha(fOperacion);
                        
                        if (!gruposPorFOperacion.has(fOperacionNormalizada)) {
                            gruposPorFOperacion.set(fOperacionNormalizada, {
                                fecha: fOperacionNormalizada,
                                fechaOriginal: fOperacion,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFOperacion.get(fOperacionNormalizada);
                        grupo.totalImporte += importe; // Sumar con signo
                        grupo.filas.push({
                            indice: i,
                            fila: filaExtracto,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: importe
                        });
                    }
                }
                
                
                // === 3. MOSTRAR DETALLE DE GRUPOS FORMADOS ===
                let contadorMayor = 1;
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                    });
                    if (grupo.filas.length > 3) {
                    }
                    contadorMayor++;
                    if (contadorMayor > 5) break;
                }
                
                let contadorExtracto = 1;
                for (const [fecha, grupo] of gruposPorFOperacion) {
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                    });
                    if (grupo.filas.length > 3) {
                    }
                    contadorExtracto++;
                    if (contadorExtracto > 5) break;
                }
                
                // === 4. COMPARACIÓN Y CONCILIACIÓN ===
                
                // Buscar matches entre grupos
                for (const [fechaMayor, grupoMayor] of gruposPorFechaMayor) {
                    let matchEncontrado = false;
                    let grupoId = '';
                    
                    for (const [fechaBBVA, grupoBBVA] of gruposPorFOperacion) {
                        const totalImporteAbsoluto = Math.abs(grupoBBVA.totalImporte);
                        const diff = Math.abs(grupoMayor.totalHaber - totalImporteAbsoluto);
                        
                        if (fechaMayor === fechaBBVA && diff < 0.01) {
                            matchEncontrado = true;
                            grupoId = `GRUPO-${conciliados + 1}`;
                            
                            
                            // Conciliar todas las filas del grupo Mayor
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: grupoId
                                });
                            });
                            
                            // Conciliar todas las filas del grupo BBVA
                            grupoBBVA.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: grupoId
                                });
                            });
                            
                            conciliados++;
                            break; // Salir del bucle interno
                        }
                    }
                    
                    // Mostrar en tabla
                    const fechaStr = fechaMayor.padEnd(10);
                    const mayorStr = `${grupoMayor.filas.length} filas`.padEnd(11);
                    const mayorHaber = grupoMayor.totalHaber.toFixed(2).padStart(11);
                    const bbvaStr = matchEncontrado ? `${gruposPorFOperacion.get(fechaMayor)?.filas.length || 0} filas`.padEnd(10) : 'NO MATCH'.padEnd(10);
                    const bbvaImporte = matchEncontrado ? Math.abs(gruposPorFOperacion.get(fechaMayor)?.totalImporte || 0).toFixed(2).padStart(11) : '0.00'.padStart(11);
                    const statusStr = matchEncontrado ? 'MATCH'.padEnd(11) : 'DIFF'.padEnd(11);
                    const grupoStr = matchEncontrado ? grupoId.padEnd(7) : '-'.padEnd(7);
                    
                }
                
                
                
                
                return {
                    candidatos: candidatosPROT + candidatosDEV + candidatosExtracto,
                    grupos: gruposFormados + gruposPorFOperacion.size,
                    conciliados: conciliados
                };
            },

            procesarPaso5SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 SBP (SCOTIABANK) - OPERACIONES PROT/DEV:
                
                Mayor SBP (ESPECÍFICO): 
                1. Filtrar por LIBRO = "04" + GLOSA contiene "PROT" (Protestos)
                2. Filtrar por LIBRO = "03" o "09" + GLOSA contiene "DEV" (Devoluciones)
                3. Agrupar por FDOC + sumar HABER
                
                Extracto (ESTÁNDAR - igual que otros bancos):
                1. Usar lógica estándar de PROT/DEV del extracto
                2. Buscar por fecha y monto como siempre
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                */
                
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === ETAPA 1: AGRUPAR MAYOR POR FECHA (PROT + DEV) ===
                const gruposPorFecha = new Map();
                
                
                // Primera pasada: Identificar candidatos PROT y DEV y agrupar por FDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5 - SBP específico
                    const esPROT = String(libro || '').trim() === '04' && (glosa.startsWith('PROT') || glosa.includes('PROT'));
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && (glosa.startsWith('DEV') || glosa.includes('DEV'));
                    
                    if (i < 10) {
                        const glosaSafe = glosa ? glosa.substring(0, 40) : '';
                    }
                    
                    if ((esPROT || esDEV) && haber > 0) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        
                        if (!gruposPorFecha.has(fdocNormalizado)) {
                            gruposPorFecha.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFecha.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFecha.size;
                
                // === ETAPA 2: AGRUPAR EXTRACTO SBP POR FECHA (DEVOLUCION LETRA) ===
                
                // Mostrar grupos formados en Mayor
                // for (const [fecha, grupo] of gruposPorFecha) {
                // }
                
                const gruposExtracto = new Map();
                
                // Filtrar y agrupar extracto por "DEVOLUCION LETRA"
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const fecha = filaExtracto[idxE.fecha] || ''; // Usar índice correcto
                    const movimiento = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase(); // Usar índice correcto
                    const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0'); // Usar índice correcto
                    const operacion = filaExtracto[idxE.operacion] || ''; // Para referencia
                    
                    if (j < 5) {
                    }
                    
                    // Filtrar solo "DEVOLUCION LETRA" o "DEVOLUCION"
                    if ((movimiento.includes('DEVOLUCION LETRA') || movimiento.includes('DEVOLUCION')) && importe !== 0) {
                        candidatosExtracto++;
                        
                        const fechaNormalizada = this.normalizarFecha(fecha);
                        
                        
                        if (!gruposExtracto.has(fechaNormalizada)) {
                            gruposExtracto.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fecha,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposExtracto.get(fechaNormalizada);
                        grupo.totalImporte += Math.abs(importe);
                        grupo.filas.push({
                            indice: j,
                            fila: filaExtracto,
                            importe: Math.abs(importe),
                            operacion: operacion,
                            movimiento: movimiento
                        });
                    }
                }
                
                
                // === ETAPA 3: MAPEAR GRUPOS MAYOR vs EXTRACTO ===
                
                for (const [fechaMayor, grupoMayor] of gruposPorFecha) {
                    
                    if (gruposExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposExtracto.get(fechaMayor);
                        
                        // Verificar coincidencia de totales
                        const diferencia = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        
                        
                        if (diferencia < 0.01) { // Tolerancia mínima
                            const refExtracto = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].operacion : '';
                            const refMayor = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : '';
                            
                            
                            // Marcar todas las filas del Mayor como conciliadas
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: refExtracto
                                });
                                conciliados++;
                                const glosaSafe = item.glosa ? item.glosa.substring(0, 30) : '';
                            });
                            
                            // Marcar todas las filas del Extracto como conciliadas
                            grupoExtracto.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados++;
                                const movSafe = item.movimiento ? item.movimiento.substring(0, 30) : '';
                                // Extracto conciliado
                            });
                        } else {
                            // Diferencia mayor a tolerancia
                        }
                    } else {
                    }
                }
                
                // SBP Paso 5 completado
                
                return {
                    candidatos: candidatosPROT + candidatosDEV + candidatosExtracto,
                    grupos: gruposFormados + gruposExtracto.size,
                    conciliados: conciliados
                };
            },

            procesarPaso6BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 BBVA - DEPÓSITOS BANCARIOS:
                
                Mayor: 
                1. Agrupar por criterio: NUMDOC
                2. FDOC + DEBE
                3. Siempre en la glosa del mayor: "DEPOSITO BANCARIO"
                
                Extracto BBVA:
                1. F. Operación + |Importe|
                
                HEADERS BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR CANDIDATOS MAYOR (INICIA CON DEPOSITO BANCARIO) ===
                const candidatosMayorDepositos = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar si inicia con "DEPOSITO BANCARIO" (más flexible que includes)
                    if (glosa.startsWith('DEPOSITO BANCARIO')) {
                        candidatosMayor++;
                        candidatosMayorDepositos.push({
                            indice: i,
                            fila: filaMayor,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob,
                            fechaNormalizada: this.normalizarFecha(fdoc)
                        });
                        
                        if (candidatosMayor <= 10) {
                        }
                    }
                }
                
                
                // === 2. AGRUPAR MAYOR POR NUMDOC ===
                const gruposPorNumdoc = new Map();
                
                candidatosMayorDepositos.forEach(candidato => {
                    if (!gruposPorNumdoc.has(candidato.numdoc)) {
                        gruposPorNumdoc.set(candidato.numdoc, {
                            numdocOriginal: candidato.numdoc,
                            filas: []
                        });
                    }
                    gruposPorNumdoc.get(candidato.numdoc).filas.push(candidato);
                });
                
                gruposFormados = gruposPorNumdoc.size;
                
                // === 3. PROCESAR EXTRACTO BBVA (TODOS LOS REGISTROS PENDIENTES) ===
                const extractoDisponible = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operación (Col A)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    const concepto = (filaExtracto[4] || '').toString(); // Concepto (Col E)
                    
                    candidatosExtracto++;
                    extractoDisponible.push({
                        indice: i,
                        fila: filaExtracto,
                        fOperacion: fOperacion,
                        importe: importe,
                        importeAbsoluto: Math.abs(importe),
                        concepto: concepto,
                        fechaNormalizada: this.normalizarFecha(fOperacion)
                    });
                    
                    if (candidatosExtracto <= 10) {
                        // Extracto candidato procesado
                    }
                }
                
                
                // === 4. DETALLE DE GRUPOS MAYOR ===
                let contadorGrupo = 1;
                for (const [numdoc, grupo] of gruposPorNumdoc) {
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                    });
                    if (grupo.filas.length > 3) {
                    }
                    contadorGrupo++;
                    if (contadorGrupo > 5) break;
                }
                
                // === 5. MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===
                
                for (const [numdoc, grupo] of gruposPorNumdoc) {
                    // Para cada fila del grupo, buscar match en extracto
                    for (const filaMayor of grupo.filas) {
                        // Skip si ya fue procesada
                        if (estadosFilas.has(filaMayor.indice)) continue;
                        
                        // Buscar match en extracto
                        for (const itemExtracto of extractoDisponible) {
                            // Skip si ya fue procesado
                            if (estadosExtracto.has(itemExtracto.indice)) continue;
                            
                            // Comparar fecha y monto
                            const fechasCoinciden = filaMayor.fechaNormalizada === itemExtracto.fechaNormalizada;
                            const diff = Math.abs(filaMayor.debe - itemExtracto.importeAbsoluto);
                            const montosCoinciden = diff < 0.01;
                            
                            if (fechasCoinciden && montosCoinciden) {
                                
                                // Conciliar ambos registros
                                const refMayor = `BBVA-P6-${itemExtracto.fOperacion}`;
                                const refExtracto = `${filaMayor.comprob}`;
                                
                                estadosFilas.set(filaMayor.indice, {
                                    estado: 'P6 - Conciliada',
                                    ref: refMayor
                                });
                                
                                estadosExtracto.set(itemExtracto.indice, {
                                    estado: 'P6 - Conciliada',
                                    ref: refExtracto
                                });
                                
                                conciliados++;
                                break; // Salir del bucle de extracto para esta fila de Mayor
                            }
                        }
                    }
                }
                

                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    grupos: gruposFormados,
                    conciliados: conciliados
                };
            },

            procesarPaso6(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 6 - DEPÓSITOS BANCARIOS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO ESPECÍFICO POR BANCO:
                
                BCP (General):
                - ETAPA 6A: NUMDOC (Mayor) ↔ Operación - Número (Extracto col G/índice 6)
                - ETAPA 6B: FDOC + DEBE (Mayor) ↔ FECHA + MONTO (Extracto)
                
                SANT (Santander) - MAPEO ESPECÍFICO:
                - FDOC + DEBE (Mayor) ↔ Fecha (Columna A) + Importe (Columna G, valor absoluto)
                - Fecha formato: dd/mm/aaaa
                
                BBVA - MAPEO ESPECÍFICO:
                - Mayor: Agrupar por NUMDOC, FDOC+DEBE
                - Extracto: F. Operación + |Importe|
                - Glosa del mayor: inicia con "DEPOSITO BANCARIO"
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // Verificar si es cuenta BBVA, IBK, DET o BN
                
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    return this.procesarPaso6BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                    return this.procesarPaso6IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                    return this.procesarPaso6DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                    return this.procesarPaso6BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                
                // === VERIFICAR SI ES SANTANDER PARA MAPEO ESPECÍFICO ===
                const esSantander = cuentaConfig && cuentaConfig.alias === 'SANT';
                
                let candidatosDepositos = 0;
                let conciliadosEtapa6A = 0;
                let conciliadosEtapa6B = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios del PASO 6
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        if (candidatosDepositos <= 5) {
                        }
                    }
                }
                
                
                if (candidatosDepositos === 0) {
                    return { candidatos: 0, conciliados: 0, etapa6a: 0, etapa6b: 0 };
                }
                
                // ETAPA 6A: Mapeo por NUMDOC vs Operación-Número
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en otra etapa
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por NUMDOC vs Operación-Número
                    const matchExtracto = this.buscarMatchPorNUMDOC(candidato.numdoc, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6A++;
                        
                    }
                }
                
                // ETAPA 6B: Mapeo específico según banco
                if (esSantander) {
                } else {
                }
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en ETAPA 6A
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    let matchExtracto;
                    
                    if (esSantander) {
                        // MAPEO ESPECÍFICO SANTANDER: Columnas A (Fecha) y G (Importe)
                        matchExtracto = this.buscarMatchSantanderPaso6(candidato.fdoc, candidato.debe, extractoProcesable, estadosExtracto);
                    } else {
                        // MAPEO BCP: Usando índices dinámicos
                        matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    }
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6B++;
                        
                    }
                }
                
                const totalConciliados = conciliadosEtapa6A + conciliadosEtapa6B;
                
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: totalConciliados,
                    etapa6a: conciliadosEtapa6A,
                    etapa6b: conciliadosEtapa6B
                };
            },

            buscarMatchPorNUMDOC(numdocMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6A:
                - Compara NUMDOC (Mayor normalizado) vs Operación - Número (Extracto col G/índice 6)
                - Retorna datos del match si se encuentra
                */
                
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                    const operacionNormalizada = this.normalizarTexto(operacionNumero);
                    
                    // Comparar NUMDOC vs Operación-Número (ambos normalizados)
                    const coincide = numdocMayor && operacionNormalizada && numdocMayor === operacionNormalizada;
                    
                    if (candidatosRevisados <= 5) {
                    }
                    
                    if (coincide) {
                        return {
                            encontrado: true,
                            indice: i,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchPorFechaYMonto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6B:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Reutiliza la lógica del Paso 4 con normalización
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                    
                    // Normalizar fecha y monto del extracto - CORREGIDO: usar misma función que Mayor
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw); // Usar formato YYYY-MM-DD como Mayor
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    if (candidatosRevisados <= 5) {
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchSantanderPaso6(fdocMayor, debeMayor, extractoProcesable, estadosExtracto) {
                /*
                Busca un match específico para SANTANDER en PASO 6:
                - Compara FDOC (Mayor) vs FECHA (Extracto Columna A/índice 0)
                - Compara DEBE (Mayor) vs IMPORTE (Extracto Columna G/índice 6 en VALOR ABSOLUTO)
                - Fecha formato: dd/mm/aaaa
                - Retorna datos del match si se encuentra
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    candidatosRevisados++;
                    
                    // === MAPEO ESPECÍFICO SANTANDER ===
                    // Columna A (índice 0): Fecha 
                    // Columna G (índice 6): Importe (valor absoluto)
                    const fechaExtracto = filaExtracto[0] || ''; // Columna A
                    const importeExtracto = filaExtracto[6] || '0'; // Columna G
                    const referenciaExtracto = filaExtracto[3] || ''; // Columna D - Referencia
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    // Verificar coincidencias: FECHA exacta + MONTO absoluto exacto
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const montosCoinciden = Math.abs(debeMayor - montoExtractoAbs) < 0.01; // Tolerancia para decimales
                    
                    if (fechasCoinciden && montosCoinciden) {
                        
                        return {
                            encontrado: true,
                            indice: i,
                            filaCompleta: filaExtracto,
                            fecha: fechaExtracto,
                            monto: montoExtractoAbs,
                            operacionNumero: referenciaExtracto || `SANT-${i}`
                        };
                    }
                    
                    if (candidatosRevisados <= 3) {
                    }
                }
                
                return { encontrado: false };
            },

            procesarPaso7BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 7 BBVA - MAPEO DIRECTO:
                
                Mayor: 
                1. FDOC + DEBE (todos los registros pendientes)
                
                Extracto BBVA:
                1. F. Operación + |Importe|
                
                HEADERS BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada" para registros mapeados
                */
                
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR CANDIDATOS MAYOR (TODOS LOS PENDIENTES) ===
                const candidatosMayorPendientes = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString();
                    
                    candidatosMayor++;
                    candidatosMayorPendientes.push({
                        indice: i,
                        fila: filaMayor,
                        fdoc: fdoc,
                        debe: debe,
                        comprob: comprob,
                        libro: libro,
                        glosa: glosa,
                        fechaNormalizada: this.normalizarFecha(fdoc)
                    });
                    
                    if (candidatosMayor <= 10) {
                    }
                }
                
                
                // === 2. PROCESAR EXTRACTO BBVA (TODOS LOS REGISTROS PENDIENTES) ===
                const extractoDisponible = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operación (Col A)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    const concepto = (filaExtracto[4] || '').toString(); // Concepto (Col E)
                    
                    candidatosExtracto++;
                    extractoDisponible.push({
                        indice: i,
                        fila: filaExtracto,
                        fOperacion: fOperacion,
                        importe: importe,
                        importeAbsoluto: Math.abs(importe),
                        concepto: concepto,
                        fechaNormalizada: this.normalizarFecha(fOperacion)
                    });
                    
                    if (candidatosExtracto <= 10) {
                        // Extracto candidato procesado
                    }
                }
                
                
                // === 3. MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===
                
                for (const candidatoMayor of candidatosMayorPendientes) {
                    // Skip si ya fue procesado
                    if (estadosFilas.has(candidatoMayor.indice)) continue;
                    
                    // Buscar match en extracto
                    for (const itemExtracto of extractoDisponible) {
                        // Skip si ya fue procesado
                        if (estadosExtracto.has(itemExtracto.indice)) continue;
                        
                        // Comparar fecha y monto
                        const fechasCoinciden = candidatoMayor.fechaNormalizada === itemExtracto.fechaNormalizada;
                        const diff = Math.abs(candidatoMayor.debe - itemExtracto.importeAbsoluto);
                        const montosCoinciden = diff < 0.01;
                        
                        if (fechasCoinciden && montosCoinciden) {
                            
                            // Conciliar ambos registros
                            const refMayor = `BBVA-P7-${itemExtracto.fOperacion}`;
                            const refExtracto = `${candidatoMayor.comprob}`;
                            
                            estadosFilas.set(candidatoMayor.indice, {
                                estado: 'P7 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(itemExtracto.indice, {
                                estado: 'P7 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados++;
                            break; // Salir del bucle de extracto para esta fila de Mayor
                        }
                    }
                }
                
                
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    conciliados: conciliados
                };
            },

            procesarPaso7(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 7 - OPERACIONES LIBRO 3:
                
                CUENTA ESTÁNDAR (BCP, SANTANDER):
                CRITERIOS DE FILTRADO:
                - LIBRO = "03"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                BBVA - MAPEO ESPECÍFICO:
                - Mayor: FDOC + DEBE (todos los registros pendientes)
                - Extracto: F. Operación + |Importe|
                
                MAPEO ÚNICO:
                - FDOC + DEBE (Mayor) ↔ FECHA + |MONTO| (Extracto)
                - Normalización de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada" para ambos registros
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // Verificar si es cuenta BBVA o IBK
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    return this.procesarPaso7BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && cuentaConfig.alias === 'IBK') {
                    return this.procesarPaso7IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                }
                
                
                let candidatosLibro3 = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="03" pendientes
                const candidatosPaso7 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 7
                    const esLibro03 = String(libro || '').trim() === '03';
                    
                    if (esLibro03) {
                        candidatosLibro3++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso7.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // if (candidatosLibro3 <= 5) {
                        // }
                    }
                }
                
                
                if (candidatosLibro3 === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+DEBE vs FECHA+MONTO
                
                for (const candidato of candidatosPaso7) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+DEBE vs FECHA+MONTO (reutilizar función del Paso 6)
                    const matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                    }
                }
                
                
                return {
                    candidatos: candidatosLibro3,
                    conciliados: conciliados
                };
            },

            procesarPaso8(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 8 - OPERACIONES MÚLTIPLES LIBROS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO ÚNICO:
                - FDOC + HABER (Mayor) ↔ FECHA + |MONTO| (Extracto)
                - Valor absoluto para monto extracto (como Paso 5)
                - Normalización de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para ambos registros
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // ⭐ VERIFICAR SI ES BBVA, IBK O DET PARA USAR LÓGICA ESPECÍFICA
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && cuentaConfig.alias === 'IBK';
                const esDET = cuentaConfig && cuentaConfig.alias === 'DET';
                
                if (esBBVA) {
                    return this.procesarPaso8BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    return this.procesarPaso8IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else if (esDET) {
                    return this.procesarPaso8DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                
                let candidatosLibro02 = 0;
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Identificar candidatos de múltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 8
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '02') candidatosLibro02++;
                        else if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // if (candidatosPaso8.length <= 5) {
                        // }
                    }
                }
                
                const totalCandidatos = candidatosPaso8.length;
                
                
                if (totalCandidatos === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+HABER vs FECHA+MONTO
                
                for (const candidato of candidatosPaso8) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+HABER vs FECHA+MONTO
                    const matchExtracto = this.buscarMatchPorFechaYMontoHaber(candidato.fdoc, candidato.haber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                    }
                }
                
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchPorFechaYMontoHaber(fdocMayor, haberMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 8 (HABER):
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara HABER (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchPorFechaYMonto pero usa HABER y enfatiza Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                    
                    // Normalizar fecha y monto del extracto - CORREGIDO: usar misma función que Mayor
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO (como Paso 5)
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(haberMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchBBVAPaso8(fdocMayor, haberMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto BBVA para PASO 8:
                - Compara FDOC (Mayor) vs F. Operación (Extracto col A)
                - Compara HABER (Mayor) vs |Importe| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                
                ESTRUCTURA EXTRACTO BBVA:
                - Columna A (índice 0): F. Operación (fecha)
                - Columna D (índice 3): Importe (monto)
                - Columna G (índice 6): Operación - Número
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // ⭐ MAPEO ESPECÍFICO BBVA CORREGIDO:
                    // Columna A (índice 0): F. Operación (fecha)
                    // Columna F (índice 5): Importe (monto) 
                    // Columna D (índice 3): Nº. Doc.
                    const fechaOperacionRaw = filaExtracto[0] || ''; // F. Operación
                    const importeRaw = filaExtracto[5] || '0'; // Importe (índice 5)
                    const operacionNumero = filaExtracto[3] || ''; // Nº. Doc. (índice 3)
                    
                    // Normalizar fecha y monto del extracto BBVA
                    const fechaOperacionNormalizada = this.normalizarFecha(fechaOperacionRaw);
                    const importeRaw_parsed = this.normalizarMonto(importeRaw);
                    const importe = Math.abs(importeRaw_parsed); // VALOR ABSOLUTO
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaOperacionNormalizada && fechaMayorNormalizada === fechaOperacionNormalizada;
                    const diferenciaMonto = Math.abs(haberMayor - importe);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    if (candidatosRevisados <= 5) {
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaOperacionNormalizada,
                            monto: importe,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            procesarPaso8BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 BBVA - OPERACIONES MÚLTIPLES LIBROS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO ÚNICO BBVA:
                - FDOC + HABER (Mayor) ↔ F. Operación + |Importe| (Extracto)
                - Valor absoluto para monto extracto
                - Normalización de fechas y montos
                - Coincidencia exacta
                
                ESTRUCTURA EXTRACTO BBVA:
                - Columna A (índice 0): F. Operación (fecha)
                - Columna F (índice 5): Importe (monto)
                - Columna D (índice 3): Nº. Doc.
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para ambos registros
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8 BBVA
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Identificar candidatos de múltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 8 BBVA
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '02') candidatosLibro02++;
                        else if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        if (candidatosPaso8.length <= 5) {
                        }
                    }
                }
                
                const totalCandidatos = candidatosPaso8.length;
                
                
                if (totalCandidatos === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO BBVA: FDOC+HABER vs F. Operación+|Importe|
                
                for (const candidato of candidatosPaso8) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+HABER vs F. Operación+|Importe|
                    const matchExtracto = this.buscarMatchBBVAPaso8(candidato.fdoc, candidato.haber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                    }
                }
                
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 9 - OPERACIONES MÚLTIPLES LIBROS AGRUPADAS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                ESTRATEGIA ESPECÍFICA POR BANCO:
                
                BCP (General):
                1. Agrupar por NUMDOC los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por NUMDOC
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                SANT (Santander) - MAPEO ESPECÍFICO:
                1. Agrupar en Extracto por FECHA (Columna A)
                2. Sumar Total |IMPORTE| de cada grupo por FECHA
                3. Mapear: FDOC + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                */
                
                
                // === VERIFICAR SI ES SANTANDER, BBVA O IBK PARA MAPEO ESPECÍFICO ===
                const esSantander = cuentaConfig && cuentaConfig.alias === 'SANT';
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && cuentaConfig.alias === 'IBK';
                
                // ⭐ RESTRICCIÓN SBP: Solo procesar SBP PEN (1041301), excluir SBP USD (1041302)
                const esSBPUSD = cuentaConfig && cuentaConfig.codigo === '1041302';
                if (esSBPUSD) {
                    // SBP USD no debe procesarse en Paso 9, se procesará en Paso 12 con lógica agrupada
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // ⭐ FORZAR SANTANDER SI ES CUENTA 1041401
                const esCuentaSantander = cuentaConfig?.codigo === '1041401';
                const esRealmenteSantander = esSantander || esCuentaSantander;
                
                
                if (esRealmenteSantander) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                } else if (esBBVA) {
                    return this.procesarPaso9BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    return this.procesarPaso9IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else {
                }
                
                let candidatosLibro02 = 0;
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Agrupar filas por NUMDOC que cumplan criterios
                const gruposPorNUMDOC = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por NUMDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 9
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '02') candidatosLibro02++;
                        else if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        // if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                        // }
                        
                        // ⭐ AGRUPAR POR NUMDOC + FECHA (evitar mezclar fechas diferentes)
                        const numdocNormalizado = this.normalizarTexto(numdoc);
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const claveGrupo = `${numdocNormalizado}_${fechaNormalizada}`; // NUMDOC + FECHA
                        
                        if (!gruposPorNUMDOC.has(claveGrupo)) {
                            gruposPorNUMDOC.set(claveGrupo, {
                                numdoc: numdocNormalizado,
                                numdocOriginal: numdoc,
                                fdoc: fdoc, // Usar FDOC del primer registro para mapeo
                                fechaNormalizada: fechaNormalizada,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorNUMDOC.get(claveGrupo);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorNUMDOC.size;
                const totalCandidatos = candidatosLibro02 + candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                
                if (gruposFormados === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                let contadorGrupo = 104;
                const gruposObjetivoA = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo específicos
                    if (gruposObjetivoA.includes(numdocNormalizado)) {
                        // grupo.filas.forEach((fila, idx) => {
                        // });
                        contadorGrupo++;
                    }
                }
                
                
                contadorGrupo = 104;
                const gruposObjetivo = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    const esGrupoObjetivo = gruposObjetivo.includes(numdocNormalizado);
                    
                    if (esGrupoObjetivo) {
                    }
                    
                    // Buscar match en extracto usando FDOC y TOTAL HABER del grupo
                    const matchExtracto = this.buscarMatchExtractoPorGrupoNUMDOC(grupo.fdoc, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo);
                    
                    if (matchExtracto.encontrado) {
                        if (esGrupoObjetivo) {
                        }
                        
                        // Asignar estados a todas las filas del grupo
                        const refMayor = matchExtracto.operacionNumero; // Número de operación del extracto
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`; // Usar primer registro del grupo
                        
                        
                        // IMPORTANTE: Todas las filas del grupo reciben el MISMO número de operación del extracto
                        grupo.filas.forEach((item, idx) => {
                            estadosFilas.set(item.indice, {
                                estado: 'P9 - Conciliada',
                                ref: refMayor // Mismo número de operación para todas las filas del grupo
                            });
                            
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P9 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        
                        // grupo.filas.forEach((item, idx) => {
                        // });
                    } else {
                        if (esGrupoObjetivo) {
                        }
                    }
                    
                    if (esGrupoObjetivo) {
                        contadorGrupo++;
                    }
                }
                
                
                let gruposConciliados = 0;
                let gruposNoConciliados = 0;
                let numeroGrupo = 104;
                const gruposObjetivoTabla = ['11302', '1113', '11303', '1157', '900013']; // Redefinir para la tabla
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo específicos
                    if (gruposObjetivoTabla.includes(numdocNormalizado)) {
                        // Verificar si el grupo fue conciliado revisando el estado de la primera fila
                        const primeraFila = grupo.filas[0];
                        const estadoPrimeraFila = estadosFilas.get(primeraFila.indice);
                        const estado = estadoPrimeraFila && estadoPrimeraFila.estado === 'P9 - Conciliada' ? '✅ CONCILIADO' : '❌ PENDIENTE';
                        
                        if (estado === '✅ CONCILIADO') gruposConciliados++;
                        else gruposNoConciliados++;
                        
                        const grupoPadded = numeroGrupo.toString().padStart(5);
                        const numdocPadded = (numdocNormalizado || '').toString().padEnd(15);
                        const fdocPadded = (grupo.fdoc || '').toString().padEnd(15);
                        const haberPadded = (grupo.totalHaber || 0).toFixed(2).padStart(12);
                        const filasPadded = (grupo.filas?.length || 0).toString().padStart(11);
                        const estadoPadded = (estado || '').toString().padEnd(13);
                        
                    }
                    numeroGrupo++;
                }
                
                

                
                // ⚠️ VALORES POR DEFECTO PARA MANTENER COMPATIBILIDAD
                let conciliadosP9B = 0;
                let gruposP9BMayor = 0;
                let gruposP9BExtracto = 0;
                
                
                
                return {
                    candidatos: totalCandidatos,
                    grupos: gruposFormados,
                    conciliados: conciliados,
                    // Nuevas estadísticas para P9B
                    conciliadosP9B: conciliadosP9B,
                    gruposP9BMayor: gruposP9BMayor,
                    gruposP9BExtracto: gruposP9BExtracto,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto) {
                /*
                PASO 9 SANTANDER - AGRUPACIÓN POR FECHA:
                
                ESTRATEGIA ESPECÍFICA:
                1. Agrupar por FECHA en Mayor: FDOC de LIBRO "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Columna A
                3. Mapear: FECHA + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                4. Numerar grupos y usar número como #REF
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada"
                - Mayor: #REF = "GRUPO-[N]"
                - Extracto: #REF = "GRUPO-[N]"
                */
                
                
                // === 🔬 TEST DE NORMALIZACIÓN DE FECHAS ===
                // === 🔬 TEST DE NORMALIZACIÓN DE FECHAS Y VERIFICACIÓN COLUMNA L ===
                
                const coincide06 = this.normalizarFecha('6/6/2025') === this.normalizarFecha('06/06/2025');
                const coincide13 = this.normalizarFecha('13/6/2025') === this.normalizarFecha('13/06/2025');
                const coincide20 = this.normalizarFecha('20/6/2025') === this.normalizarFecha('20/06/2025');
                const coincide27 = this.normalizarFecha('27/6/2025') === this.normalizarFecha('27/06/2025');
                
                
                const registrosDisponibles = extractoProcesable ? extractoProcesable.filter((_, i) => !estadosExtracto.has(i)) : [];
                const registrosYaProcesados = extractoProcesable ? extractoProcesable.length - registrosDisponibles.length : 0;
                
                const estadosEnExtracto = {};
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) {
                        const estado = estadosExtracto.get(i).estado;
                        estadosEnExtracto[estado] = (estadosEnExtracto[estado] || 0) + 1;
                    } else {
                        estadosEnExtracto['Pendiente'] = (estadosEnExtracto['Pendiente'] || 0) + 1;
                    }
                }
                for (const [estado, cantidad] of Object.entries(estadosEnExtracto)) {
                }
                
                const estadosEnMayor = {};
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) {
                        const estado = estadosFilas.get(i).estado;
                        estadosEnMayor[estado] = (estadosEnMayor[estado] || 0) + 1;
                    } else {
                        estadosEnMayor['Pendiente'] = (estadosEnMayor['Pendiente'] || 0) + 1;
                    }
                }
                for (const [estado, cantidad] of Object.entries(estadosEnMayor)) {
                }
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // === 1. AGRUPAR POR FECHA EN MAYOR ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // ⭐ VERIFICAR ESTADO = "Pendiente" O VACÍO (INICIAL)
                    const estadoCol = String(filaMayor[filaMayor.length - 2] || ''); // Convertir a string
                    const esPendiente = estadoCol.trim() === 'Pendiente' || estadoCol.trim() === '';
                    
                    if (!esPendiente) {
                        if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 5) {
                        }
                        continue;
                    }
                    
                    if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const glosa = (filaMayor[idxM.glosa] || '').substring(0, 30);
                    }
                    
                    // Verificar criterios del PASO 9
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '02') candidatosLibro02++;
                        else if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        // ⭐ AGRUPAR POR FECHA (FDOC) - CORRECCIÓN PRINCIPAL
                        const fechaMayorNormalizada = this.normalizarFecha(fdoc);
                        
                        if (fdoc === '6/6/2025' || fdoc === '13/6/2025' || fdoc === '20/6/2025' || fdoc === '27/6/2025') {
                        }
                        
                        if (fechaMayorNormalizada) {
                            if (!gruposPorFechaMayor.has(fechaMayorNormalizada)) {
                                gruposPorFechaMayor.set(fechaMayorNormalizada, {
                                    fecha: fechaMayorNormalizada,
                                    fechaOriginal: fdoc,
                                    totalHaber: 0,
                                    filas: [],
                                    primerComprob: comprob,
                                    primerLibro: libro
                                });
                            }
                            
                            const grupo = gruposPorFechaMayor.get(fechaMayorNormalizada);
                            grupo.totalHaber += haber;
                            grupo.filas.push(i);
                            
                            // Mostrar ejemplos de los primeros 10 registros agregados a grupos
                            if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                                const numdoc = filaMayor[idxM.numdoc] || '';
                                const glosa = (filaMayor[idxM.glosa] || '').substring(0, 25);
                            }
                        }
                    }
                }
                
                const gruposMayorFormados = gruposPorFechaMayor.size;
                const totalCandidatos = candidatosLibro02 + candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                
                if (gruposMayorFormados === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR FECHA EN EXTRACTO SANTANDER ===
                const gruposPorFechaExtracto = new Map();
                let registrosSaltadosSinDatos = 0;
                let registrosProcesadosEnExtracto = 0;
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPECÍFICO SANTANDER ===
                    // Columna A (índice 0): Fecha
                    // Columna G (índice 6): Importe
                    const fechaExtracto = filaExtracto[0] || '';
                    const importeExtracto = filaExtracto[6] || '0';
                    
                    // ⭐ VERIFICAR QUE TENGA DATOS REALES
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    const tieneDatosReales = tieneFecha && tieneImporte;
                    
                    // SALTAR SI NO TIENE DATOS REALES
                    if (!tieneDatosReales) {
                        registrosSaltadosSinDatos++;
                        continue;
                    }
                    
                    // ⭐ EL REGISTRO YA FUE PROCESADO EN PASOS ANTERIORES (verificado arriba con estadosExtracto.has(i))
                    // NO necesitamos verificar columna L porque los estados se guardan en estadosExtracto Map
                    
                    if (registrosProcesadosEnExtracto <= 15) {
                        const referencia = filaExtracto[3] || '';
                        const descripcion = (filaExtracto[4] || '').substring(0, 20);
                    }
                    
                    registrosProcesadosEnExtracto++;
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    if (fechaExtracto === '06/06/2025' || fechaExtracto === '13/06/2025' || fechaExtracto === '20/06/2025' || fechaExtracto === '27/06/2025') {
                    }
                    
                    if (fechaExtractoNormalizada && montoExtractoAbs > 0) {
                        if (!gruposPorFechaExtracto.has(fechaExtractoNormalizada)) {
                            gruposPorFechaExtracto.set(fechaExtractoNormalizada, {
                                fecha: fechaExtractoNormalizada,
                                totalImporte: 0,
                                filas: [],
                                fechaOriginal: fechaExtracto
                            });
                        }
                        
                        const grupo = gruposPorFechaExtracto.get(fechaExtractoNormalizada);
                        grupo.totalImporte += montoExtractoAbs;
                        grupo.filas.push(i);
                        
                        if (gruposPorFechaExtracto.size <= 5) {
                        }
                    }
                }
                
                const gruposExtractoFormados = gruposPorFechaExtracto.size;
                
                
                
                // Obtener todas las fechas únicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFechaExtracto.keys())
                ]);
                
                for (const fecha of Array.from(todasFechas).sort()) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoSant = gruposPorFechaExtracto.get(fecha);
                    
                    const fechaCol = (fecha || '').toString().padEnd(10);
                    const mayorFdoc = grupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : ''.padEnd(11);
                    const mayorHaber = grupoMayor ? (grupoMayor.totalHaber || 0).toFixed(2).padStart(11) : ''.padStart(11);
                    const santFecha = grupoSant ? (grupoSant.fechaOriginal || '').toString().padEnd(10) : ''.padEnd(10);
                    const santImporte = grupoSant ? (grupoSant.totalImporte || 0).toFixed(2).padStart(11) : ''.padStart(11);
                    
                    let status = '';
                    let diferencia = '';
                    
                    if (grupoMayor && grupoSant) {
                        const diff = Math.abs(grupoMayor.totalHaber - grupoSant.totalImporte);
                        const coincide = diff < 0.01;
                        status = coincide ? '✅ MATCH' : '❌ DIFF';
                        diferencia = diff.toFixed(2);
                    } else if (grupoMayor && !grupoSant) {
                        status = '🔸 SOLO MAYOR';
                        diferencia = '---';
                    } else if (!grupoMayor && grupoSant) {
                        status = '🔹 SOLO SANT';
                        diferencia = '---';
                    }
                    
                    status = status.padEnd(11);
                    diferencia = diferencia.padStart(7);
                    
                }
                
                
                
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const fila = filasFiltradasMayor[indice];
                        const estadoMayor = estadosFilas.has(indice) ? estadosFilas.get(indice).estado : 'Pendiente';
                        const numdoc = fila[idxM.numdoc] || '';
                        const glosa = (fila[idxM.glosa] || '').substring(0, 20);
                    }
                    if (grupo.filas.length > 3) {
                    }
                }
                
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const item = extractoProcesable[indice];
                        const fila = item.fila;
                        const estadoSant = estadosExtracto.has(indice) ? estadosExtracto.get(indice).estado : 'Pendiente';
                        const referencia = fila[3] || '';
                        const importe = fila[6] || '';
                    }
                    if (grupo.filas.length > 3) {
                    }
                }
                
                // === MOSTRAR TABLA DE GRUPOS MAYOR ===
                
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    const fechaOrig = (grupo.fechaOriginal || '').toString().padEnd(11);
                    const fechaNorm = (fecha || '').toString().padEnd(10);
                    const haber = (grupo.totalHaber || 0).toFixed(2).padStart(9);
                    const filas = (grupo.filas?.length || 0).toString().padStart(7);
                }
                
                // === MOSTRAR TABLA DE GRUPOS EXTRACTO ===
                
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    const fechaOrig = (grupo.fechaOriginal || '').toString().padEnd(11);
                    const fechaNorm = (fecha || '').toString().padEnd(10);
                    const importe = (grupo.totalImporte || 0).toFixed(2).padStart(9);
                    const filas = (grupo.filas?.length || 0).toString().padStart(7);
                }
                
                // === 3. MAPEAR GRUPOS POR FECHA Y MONTO ===
                let numeroGrupo = 1;
                
                for (const [fechaMayor, grupoMayor] of gruposPorFechaMayor) {
                    
                    if (gruposPorFechaExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposPorFechaExtracto.get(fechaMayor);
                        
                        // Verificar si montos coinciden
                        const diferencia = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        const montosCoinciden = diferencia < 0.01; // Tolerancia para decimales
                        
                        
                        if (montosCoinciden) {
                            // ⭐ USAR NÚMERO DE GRUPO COMO REFERENCIA
                            const refGrupo = `GRUPO-${numeroGrupo}`;
                            
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P9 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const indiceExtracto of grupoExtracto.filas) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P9 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                        }
                    } else {
                    }
                }
                
                
                
                return {
                    candidatos: totalCandidatos,
                    grupos: Math.max(gruposMayorFormados, gruposExtractoFormados),
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso12Santander(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 SANTANDER - AGRUPACIÓN POR FECHA (DESPUÉS DE ITF):
                
                ESTRATEGIA ESPECÍFICA:
                1. Agrupar por FECHA en Mayor: FDOC de LIBRO "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Columna A
                3. Mapear: FECHA + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                4. Numerar grupos y usar número como #REF
                
                IMPORTANTE: Se ejecuta DESPUÉS del Paso 11 (ITF) para saltar registros ya conciliados
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada"
                - Mayor: #REF = "GRUPO-[N]"
                - Extracto: #REF = "GRUPO-[N]"
                */
                
                // ⭐ VERIFICAR QUE ES SANTANDER (PEN o USD)
                const esSantander = cuentaConfig && (cuentaConfig.codigo === '1041401' || cuentaConfig.codigo === '1041402');
                
                if (!esSantander) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // Diagnóstico específico para SANT.USD
                const esSANTUSD = cuentaConfig && cuentaConfig.codigo === '1041402';
                if (esSANTUSD) {
                }
                
                
                // === 🔬 TEST DE NORMALIZACIÓN DE FECHAS Y VERIFICACIÓN COLUMNA L ===
                
                const coincide06 = this.normalizarFecha('6/6/2025') === this.normalizarFecha('06/06/2025');
                const coincide13 = this.normalizarFecha('13/6/2025') === this.normalizarFecha('13/06/2025');
                const coincide20 = this.normalizarFecha('20/6/2025') === this.normalizarFecha('20/06/2025');
                const coincide27 = this.normalizarFecha('27/6/2025') === this.normalizarFecha('27/06/2025');
                
                
                const registrosDisponibles = extractoProcesable ? extractoProcesable.filter((_, i) => !estadosExtracto.has(i)) : [];
                const registrosYaProcesados = extractoProcesable ? extractoProcesable.length - registrosDisponibles.length : 0;
                
                const estadosEnExtracto = {};
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) {
                        const estado = estadosExtracto.get(i).estado;
                        estadosEnExtracto[estado] = (estadosEnExtracto[estado] || 0) + 1;
                    } else {
                        estadosEnExtracto['Pendiente'] = (estadosEnExtracto['Pendiente'] || 0) + 1;
                    }
                }
                for (const [estado, cantidad] of Object.entries(estadosEnExtracto)) {
                }
                
                const estadosEnMayor = {};
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) {
                        const estado = estadosFilas.get(i).estado;
                        estadosEnMayor[estado] = (estadosEnMayor[estado] || 0) + 1;
                    } else {
                        estadosEnMayor['Pendiente'] = (estadosEnMayor['Pendiente'] || 0) + 1;
                    }
                }
                for (const [estado, cantidad] of Object.entries(estadosEnMayor)) {
                }
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let totalCandidatos = 0;
                
                // === 1. AGRUPAR POR FECHA EN MAYOR ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // ⭐ VERIFICAR ESTADO = "Pendiente" O VACÍO (INICIAL)
                    const estadoCol = String(filaMayor[filaMayor.length - 2] || ''); // Convertir a string
                    const esPendiente = estadoCol.trim() === 'Pendiente' || estadoCol.trim() === '';
                    
                    if (!esPendiente) {
                        continue; // Saltar si no es pendiente
                    }
                    
                    // Verificar criterios SANTANDER: LIBRO en 03, 09, 14, 15
                    const esLibroObjetivo = ['03', '09', '14', '15'].includes(String(libro || '').trim());
                    
                    if (!esLibroObjetivo) continue;
                    
                    totalCandidatos++;
                    
                    // Contadores por libro
                    if (String(libro || '').trim() === '03') candidatosLibro03++;
                    else if (String(libro || '').trim() === '09') candidatosLibro09++;
                    else if (String(libro || '').trim() === '14') candidatosLibro14++;
                    else if (String(libro || '').trim() === '15') candidatosLibro15++;
                    
                    // Normalizar fecha para agrupación
                    const fechaNormalizada = this.normalizarFecha(fdoc);
                    
                    if (!gruposPorFechaMayor.has(fechaNormalizada)) {
                        gruposPorFechaMayor.set(fechaNormalizada, {
                            fechaOriginal: fdoc,
                            totalHaber: 0,
                            filas: []
                        });
                    }
                    
                    const grupo = gruposPorFechaMayor.get(fechaNormalizada);
                    grupo.totalHaber += haber;
                    grupo.filas.push(i);
                }
                
                const gruposMayorFormados = gruposPorFechaMayor.size;
                
                
                if (gruposMayorFormados === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR FECHA EN EXTRACTO SANTANDER ===
                const gruposPorFechaExtracto = new Map();
                let registrosSaltadosSinDatos = 0;
                let registrosProcesadosEnExtracto = 0;
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPECÍFICO SANTANDER ===
                    // Columna A (índice 0): Fecha
                    // Columna G (índice 6): Importe
                    const fechaExtracto = filaExtracto[0] || '';
                    const importeExtracto = filaExtracto[6] || '0';
                    
                    // ⭐ VERIFICAR QUE TENGA DATOS REALES
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    const tieneDatosReales = tieneFecha && tieneImporte;
                    
                    // SALTAR SI NO TIENE DATOS REALES
                    if (!tieneDatosReales) {
                        registrosSaltadosSinDatos++;
                        continue;
                    }
                    
                    // ⭐ EL REGISTRO YA FUE PROCESADO EN PASOS ANTERIORES (verificado arriba con estadosExtracto.has(i))
                    // NO necesitamos verificar columna L porque los estados se guardan en estadosExtracto Map
                    
                    if (registrosProcesadosEnExtracto <= 15) {
                        const referencia = filaExtracto[3] || '';
                        const descripcion = (filaExtracto[4] || '').substring(0, 20);
                    }
                    
                    registrosProcesadosEnExtracto++;
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    if (!gruposPorFechaExtracto.has(fechaExtractoNormalizada)) {
                        gruposPorFechaExtracto.set(fechaExtractoNormalizada, {
                            fechaOriginal: fechaExtracto,
                            totalImporte: 0,
                            filas: []
                        });
                    }
                    
                    const grupo = gruposPorFechaExtracto.get(fechaExtractoNormalizada);
                    grupo.totalImporte += montoExtractoAbs;
                    grupo.filas.push(i);
                    
                    if (gruposPorFechaExtracto.size <= 5) {
                    }
                }
                
                const gruposExtractoFormados = gruposPorFechaExtracto.size;
                
                
                
                // Obtener todas las fechas únicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFechaExtracto.keys())
                ]);
                
                let conciliados = 0;
                let numeroGrupo = 1;
                
                
                
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const fila = filasFiltradasMayor[indice];
                        const estadoMayor = estadosFilas.has(indice) ? estadosFilas.get(indice).estado : 'Pendiente';
                        const numdoc = fila[idxM.numdoc] || '';
                        const glosa = (fila[idxM.glosa] || '').substring(0, 20);
                    }
                    if (grupo.filas.length > 3) {
                    }
                }
                
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const item = extractoProcesable[indice];
                        const fila = item.fila;
                        const estadoSant = estadosExtracto.has(indice) ? estadosExtracto.get(indice).estado : 'Pendiente';
                        const referencia = fila[3] || '';
                        const importe = fila[6] || '';
                    }
                    if (grupo.filas.length > 3) {
                    }
                }
                
                // === MAPEO Y CONCILIACIÓN ===
                for (const fecha of todasFechas) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoExtracto = gruposPorFechaExtracto.get(fecha);
                    
                    const tieneGrupoMayor = grupoMayor !== undefined;
                    const tieneGrupoExtracto = grupoExtracto !== undefined;
                    
                    let status = '';
                    let diferencia = '';
                    
                    if (tieneGrupoMayor && tieneGrupoExtracto) {
                        const diff = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        if (diff < 0.01) {
                            status = 'MATCH ✅';
                            diferencia = '0.00';
                            
                            // === CONCILIAR REGISTROS ===
                            const refGrupo = `GRUPO-${numeroGrupo}`;
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P12 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const indiceExtracto of grupoExtracto.filas) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P12 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                            status = 'DIFF ❌';
                            diferencia = diff.toFixed(2);
                        }
                    } else if (tieneGrupoMayor) {
                        status = 'MAYOR SOLO';
                        diferencia = '-';
                    } else {
                        status = 'SANT SOLO';
                        diferencia = '-';
                    }
                    
                    // Formatear datos para tabla
                    const fechaStr = (fecha || '').toString().padEnd(10);
                    const mayorStr = tieneGrupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : '           ';
                    const mayorHaber = tieneGrupoMayor ? (grupoMayor.totalHaber || 0).toFixed(2).padStart(11) : '           ';
                    const santStr = tieneGrupoExtracto ? (grupoExtracto.fechaOriginal || '').toString().padEnd(10) : '          ';
                    const santImporte = tieneGrupoExtracto ? (grupoExtracto.totalImporte || 0).toFixed(2).padStart(11) : '           ';
                    const statusStr = status.padEnd(11);
                    const difStr = diferencia.toString().padStart(7);
                    
                }
                
                
                
                
                return {
                    candidatos: totalCandidatos,
                    grupos: Math.max(gruposMayorFormados, gruposExtractoFormados),
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchExtractoPorGrupoNUMDOC(fdocGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo = false) {
                /*
                Busca un match en el extracto para PASO 9 (grupos por NUMDOC):
                - Compara FDOC del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchExtractoPorGrupo del Paso 5 pero para agrupación por NUMDOC
                */
                
                if (esGrupoObjetivo) {
                    
                    // Mostrar primeras 5 líneas del extracto con fechas normalizadas
                    for (let i = 0; i < Math.min(5, extractoProcesable.length); i++) {
                        if (!estadosExtracto.has(i)) {
                            const fila = extractoProcesable[i].fila;
                            const fechaRaw = fila[idxE.fecha] || '';
                            const fechaNorm = this.normalizarFecha(fechaRaw);
                            const montoRaw = fila[idxE.monto] || '';
                        } else {
                        }
                    }
                    
                    // Buscar específicamente la fecha objetivo en todo el extracto
                    const fechaObjetivo = this.normalizarFecha(fdocGrupo);
                    let encontradas = 0;
                    const lineasObjetivo = [];
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        const fila = extractoProcesable[i].fila;
                        const fechaRaw = fila[idxE.fecha] || '';
                        const fechaNorm = this.normalizarFecha(fechaRaw);
                        if (fechaNorm === fechaObjetivo) {
                            const montoRaw = fila[idxE.monto] || '';
                            const montoNorm = Math.abs(this.normalizarMonto(montoRaw));
                            const procesada = estadosExtracto.has(i) ? '[PROCESADA]' : '[DISPONIBLE]';
                            const diferencia = Math.abs(totalHaber - montoNorm);
                            const coincide = diferencia === 0 ? '🎯 MATCH!' : `Dif: ${diferencia.toFixed(2)}`;
                            if (!estadosExtracto.has(i)) {
                                lineasObjetivo.push({indice: i, monto: montoNorm, diferencia});
                            }
                            encontradas++;
                        }
                    }
                    if (encontradas === 0) {
                    } else {
                    }
                }
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                const fechaGrupoNormalizada = this.normalizarFecha(fdocGrupo);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupoNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto < 0.01; // Tolerancia para errores de floating point
                    
                    if (esGrupoObjetivo && (fechasCoinciden || (fechasCoinciden && montosCoinciden))) {
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            procesarPaso10(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, datosSaldo = null, estadosSaldo = null) {
                /*
                PASO 10 - OPERACIONES DE CHEQUES (2 ETAPAS):
                
                ETAPA 10A - MAPEO MAYOR VS EXTRACTO:
                CRITERIOS DE FILTRADO:
                - Mayor: LIBRO = "02" + ESTADO = "Pendiente"
                - Extracto: "Descripción operación" empieza con "CHEQUE" o "CERT. CHQ"
                
                MAPEO:
                - NUMDOC (Mayor) ↔ últimos 8 caracteres de "Descripción operación" (Extracto)
                - HABER (Mayor) ↔ |MONTO| (Extracto en valor absoluto)
                
                ESTADOS RESULTANTES:
                - "P10A - Conciliada" para ambos registros
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                
                ETAPA 10B - MAPEO EXTRACTO VS SALDO:
                CRITERIOS DE FILTRADO:
                - Extracto: "Descripción operación" inicia con "CHEQUE" + ESTADO = "Pendiente"
                - Saldo: ESTADO = "Pendiente"
                
                MAPEO:
                - Últimos 8 caracteres de Descripción operación (Extracto) ↔ NUMDOC (Saldo)
                
                ESTADOS RESULTANTES:
                - "P10B - Conciliada" para ambos registros
                - Saldo: #REF = "Operación - Número" del extracto
                - Extracto: #REF = "libro - comprobante" (columnas L y M de saldo)
                */
                
                
                // ========================================
                // ETAPA 10A: MAPEO MAYOR VS EXTRACTO
                // ========================================
                let candidatosLibro02 = 0;
                let candidatosExtractoCheques = 0;
                let conciliados10A = 0;
                let conciliados10B = 0;
                
                // Identificar candidatos LIBRO="02" pendientes
                const candidatosPaso10 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 10A
                    const esLibro02 = String(libro || '').trim() === '02';
                    
                    if (esLibro02) {
                        candidatosLibro02++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso10.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: this.normalizarTexto(numdoc),
                            numdocOriginal: numdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                
                // Filtrar extracto por descripción que empiece con "CHEQUE" o "CERT. CHQ"
                const extractoCheques = [];
                
                if (extractoProcesable && Array.isArray(extractoProcesable)) {
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        // Solo revisar filas no procesadas del extracto
                        if (estadosExtracto.has(i)) continue;
                        
                        const itemExtracto = extractoProcesable[i];
                        const filaExtracto = itemExtracto.fila;
                        
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                        
                        // Verificar si empieza con "CHEQUE" o "CERT. CHQ"
                        const esCheque = descripcionOperacion.startsWith('CHEQUE') || descripcionOperacion.startsWith('CERT. CHQ');
                        
                        if (esCheque) {
                            candidatosExtractoCheques++;
                            
                            // Extraer últimos 8 caracteres de la descripción
                            const ultimos8Chars = descripcionOperacion.slice(-8);
                            const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                            const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                            
                            extractoCheques.push({
                                indiceOriginal: i,
                                descripcion: descripcionOperacion,
                                ultimos8: this.normalizarTexto(ultimos8Chars),
                                monto: Math.abs(this.normalizarMonto(montoExtractoRaw)), // VALOR ABSOLUTO
                                operacionNumero: operacionNumero,
                                filaCompleta: filaExtracto
                            });
                        }
                    }
                }
                
                
                // ETAPA 10A: MAPEO MAYOR vs EXTRACTO
                if (candidatosLibro02 > 0 && candidatosExtractoCheques > 0) {
                    
                    for (const candidato of candidatosPaso10) {
                        // Saltar si ya fue procesado
                        if (estadosFilas.has(candidato.indice)) continue;
                        
                        // Buscar match en extracto filtrado
                        const matchExtracto = this.buscarMatchPorNUMDOCyCheque(candidato.numdoc, candidato.haber, extractoCheques, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            const refMayor = matchExtracto.operacionNumero;
                            const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                            
                            // Asignar estados ETAPA 10A
                            estadosFilas.set(candidato.indice, {
                                estado: 'P10A - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indiceOriginal, {
                                estado: 'P10A - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados10A++;
                            
                        }
                    }
                }
                
                // ========================================
                // ETAPA 10B: MAPEO EXTRACTO VS SALDO
                // ========================================
                
                
                if (datosSaldo && datosSaldo.length > 1 && estadosSaldo) {
                    // Mapear índices del saldo
                    const headerSaldo = datosSaldo[0] || [];
                    const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                        cuenta: ['CUENTA'], 
                        numdoc: ['NUMDOC'], 
                        debe: ['DEBE'], 
                        haber: ['HABER'], 
                        fdoc: ['FDOC'], 
                        libro: ['LIBRO'], // Columna L
                        comprobante: ['COMPROBANTE', 'COMPROB'] // Columna M
                    });
                    
                    const filasSaldo = datosSaldo.slice(1);
                    
                    // Filtrar extracto cheques pendientes después de ETAPA 10A
                    const extractoChequesParaSaldo = extractoCheques.filter(item => !estadosExtracto.has(item.indiceOriginal));
                    
                    
                    // MAPEO: Últimos 8 chars extracto ↔ NUMDOC saldo
                    for (const extractoItem of extractoChequesParaSaldo) {
                        for (let idx = 0; idx < filasSaldo.length; idx++) {
                            // Solo procesar filas saldo pendientes
                            if (estadosSaldo.has(idx) && estadosSaldo.get(idx).estado !== 'Pendiente') continue;
                            
                            const filaSaldo = filasSaldo[idx];
                            const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                            const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                            
                            // Comparar últimos 8 chars extracto vs NUMDOC saldo
                            if (extractoItem.ultimos8 && numdocSaldoNormalizado && extractoItem.ultimos8 === numdocSaldoNormalizado) {
                                const operacionNumero = extractoItem.operacionNumero;
                                const libroSaldo = filaSaldo[indicesSaldo.libro] || filaSaldo[11] || ''; // Columna L
                                const comprobanteSaldo = filaSaldo[indicesSaldo.comprobante] || filaSaldo[12] || ''; // Columna M
                                const refExtracto = `${libroSaldo}-${comprobanteSaldo}`;
                                
                                // Asignar estados ETAPA 10B
                                estadosSaldo.set(idx, {
                                    estado: 'P10B - Conciliada',
                                    ref: operacionNumero
                                });
                                
                                estadosExtracto.set(extractoItem.indiceOriginal, {
                                    estado: 'P10B - Conciliada',
                                    ref: refExtracto
                                });
                                
                                conciliados10B++;
                                
                                
                                break; // Solo uno por extracto
                            }
                        }
                    }

                    
                } else {
                }
                
                
                return {
                    candidatos: candidatosLibro02,
                    candidatosExtracto: candidatosExtractoCheques,
                    conciliados10A: conciliados10A,
                    conciliados10B: conciliados10B,
                    conciliados: conciliados10A + conciliados10B
                };
            },

            aplicarEstadosASaldo(datosSaldo, estadosSaldo) {
                /*
                Aplica los estados del Map estadosSaldo a las columnas ESTADO y #REF del archivo saldo.
                - datosSaldo: Array con header + filas de datos del saldo
                - estadosSaldo: Map con índices y estados {estado, ref}
                */
                
                if (!datosSaldo || datosSaldo.length <= 1 || !estadosSaldo || estadosSaldo.size === 0) {
                    return;
                }
                
                // Obtener el header para determinar las posiciones de ESTADO y #REF
                const header = datosSaldo[0];
                
                // Buscar las posiciones de ESTADO y #REF en el header
                let indiceEstado = -1;
                let indiceRef = -1;
                
                for (let i = 0; i < header.length; i++) {
                    const colUpper = String(header[i]).toUpperCase();
                    if (colUpper === 'ESTADO') {
                        indiceEstado = i;
                    } else if (colUpper === '#REF' || colUpper === 'REF') {
                        indiceRef = i;
                    }
                }
                
                // Si no se encontraron las columnas, usar las últimas dos columnas
                if (indiceEstado === -1) {
                    indiceEstado = header.length - 2;
                }
                if (indiceRef === -1) {
                    indiceRef = header.length - 1;
                }
                
                let estadosAplicados = 0;
                
                // Procesar cada fila de datos (saltar header)
                for (let i = 1; i < datosSaldo.length; i++) {
                    const indiceData = i - 1; // Índice en el Map (0-based para filas de datos)
                    
                    if (estadosSaldo.has(indiceData)) {
                        const estadoInfo = estadosSaldo.get(indiceData);
                        const fila = datosSaldo[i];
                        
                        // Asegurar que la fila tiene suficientes columnas
                        while (fila.length < header.length) {
                            fila.push('');
                        }
                        
                        // Actualizar columnas ESTADO y #REF en las posiciones correctas
                        if (indiceEstado >= 0) {
                            fila[indiceEstado] = estadoInfo.estado || 'Pendiente';
                        }
                        if (indiceRef >= 0) {
                            fila[indiceRef] = estadoInfo.ref || '';
                        }
                        
                        estadosAplicados++;
                        
                    }
                }
                
            },

            buscarMatchPorNUMDOCyCheque(numdocMayor, haberMayor, extractoCheques, estadosExtracto) {
                /*
                Busca un match en el extracto filtrado para PASO 10 (cheques):
                - Compara NUMDOC (Mayor normalizado) vs últimos 8 caracteres de descripción (Extracto)
                - Compara HABER (Mayor) vs |MONTO| (Extracto en valor absoluto)
                - Retorna datos del match si se encuentra
                */
                
                
                let candidatosRevisados = 0;
                
                for (const itemExtracto of extractoCheques) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(itemExtracto.indiceOriginal)) continue;
                    
                    candidatosRevisados++;
                    
                    // Comparar NUMDOC vs últimos 8 caracteres y HABER vs |MONTO|
                    const numdocCoincide = numdocMayor && itemExtracto.ultimos8 && numdocMayor === itemExtracto.ultimos8;
                    const diferenciaMonto = Math.abs(haberMayor - itemExtracto.monto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    // }
                    
                    if (numdocCoincide && montosCoinciden) {
                        return {
                            encontrado: true,
                            indiceOriginal: itemExtracto.indiceOriginal,
                            descripcion: itemExtracto.descripcion,
                            ultimos8: itemExtracto.ultimos8,
                            monto: itemExtracto.monto,
                            operacionNumero: itemExtracto.operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            procesarPaso11(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 11 - ITF (IMPUESTO A LAS TRANSACCIONES FINANCIERAS):
                
                ESTRATEGIA ESPECÍFICA POR BANCO:
                
                BCP (General):
                - Mayor: LIBRO = "09" + GLOSA empieza con "ITF" + CUENTA específica + ESTADO = "Pendiente"
                - Extracto: "Descripción operación" contiene "IMPUESTO ITF"
                - Mapeo: Suma total MAYOR vs suma total EXTRACTO POR CUENTA
                
                SANT (Santander) - MAPEO ESPECÍFICO:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER
                - Extracto: Descripción contiene "CARGO POR ITF", agrupar todos
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                BBVA - MAPEO ESPECÍFICO:
                - Mayor: GLOSA contiene "ITF" + HABER
                - Extracto: Concepto contiene "ITF", identificar total de operaciones
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                IBK - MAPEO ESPECÍFICO:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER (estándar)
                - Extracto: Movimiento contiene "ITF" + valor absoluto de ABONO
                - Mapeo: Suma HABER (Mayor) vs suma |ABONO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                
                // === VERIFICAR SI ES SANTANDER, BBVA, SBP, IBK O BN PARA MAPEO ESPECÍFICO ===
                const esSantander = cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD');
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
                const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
                const esBN = cuentaConfig && cuentaConfig.alias === 'BN';
                
                if (esSantander) {
                    const esSANTUSD = cuentaConfig && cuentaConfig.codigo === '1041402';
                    if (esSANTUSD) {
                    }
                    return this.procesarPaso11Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto);
                } else if (esBBVA) {
                    const esBBVAUSD = cuentaConfig && cuentaConfig.codigo === '1041202';
                    if (esBBVAUSD) {
                    }
                    return this.procesarPaso11BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    return this.procesarPaso11IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
                } else if (esSBP) {
                    const esSBPUSD = cuentaConfig && cuentaConfig.codigo === '1041302';
                    if (esSBPUSD) {
                    }
                    return this.procesarPaso11SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esBN) {
                    return this.procesarPaso11BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else {
                    const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                    if (esBCPUSD) {
                    }
                }
                
                let candidatosLibro09ITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // Obtener código de cuenta específica para filtrado
                const codigoCuentaEspecifica = cuentaConfig ? cuentaConfig.codigo : null;
                
                // Identificar candidatos LIBRO="09" + GLOSA empieza con "ITF" + CUENTA específica
                const candidatosMayorITF = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const cuentaMayor = (filaMayor[idxM.cuenta] || '').toString();
                    
                    // Verificar criterios del PASO 11 + FILTRO POR CUENTA ESPECÍFICA
                    const esLibro09 = String(libro || '').trim() === '09';
                    const esGlosaITF = glosa.startsWith('ITF');
                    const esCuentaEspecifica = codigoCuentaEspecifica ? (cuentaMayor === codigoCuentaEspecifica) : true;
                    
                    // Diagnóstico específico para BCP.USD - mostrar primeras 20 filas
                    const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                    if (esBCPUSD && i < 20) {
                    }
                    
                    if (esLibro09 && esGlosaITF && esCuentaEspecifica) {
                        candidatosLibro09ITF++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosMayorITF.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        if (candidatosLibro09ITF <= 5) {
                        }
                        
                        // Diagnóstico específico para BCP.USD
                        const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                        if (esBCPUSD && candidatosLibro09ITF <= 10) {
                        }
                    }
                }
                
                
                if (candidatosLibro09ITF === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // Filtrar extracto por descripción que contenga "IMPUESTO ITF"
                const extractoITF = [];
                
                if (extractoProcesable && Array.isArray(extractoProcesable)) {
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        // Solo revisar filas no procesadas del extracto
                        if (estadosExtracto.has(i)) continue;
                        
                        const itemExtracto = extractoProcesable[i];
                        const filaExtracto = itemExtracto.fila;
                        
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                        
                        // Verificar si contiene "IMPUESTO ITF"
                        const esImpuestoITF = descripcionOperacion.includes('IMPUESTO ITF');
                        
                        if (esImpuestoITF) {
                            candidatosExtractoITF++;
                            
                            const fechaExtracto = filaExtracto[idxE.fecha] || '';
                            const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                            const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                            
                            extractoITF.push({
                                indiceOriginal: i,
                                descripcion: descripcionOperacion,
                                fecha: this.normalizarFecha(fechaExtracto),
                                monto: Math.abs(this.normalizarMonto(montoExtractoRaw)), // VALOR ABSOLUTO
                                operacionNumero: operacionNumero,
                                filaCompleta: filaExtracto
                            });
                            
                            if (candidatosExtractoITF <= 5) {
                            }
                        }
                    }
                }
                
                
                if (candidatosExtractoITF === 0) {
                    return { candidatos: candidatosLibro09ITF, conciliados: 0 };
                }
                
                // AGRUPACIÓN Y MAPEO POR CUENTA: Suma total de ITFs para cuenta específica
                const totalMayorITF = candidatosMayorITF.reduce((suma, item) => suma + (item.debe + item.haber), 0);
                const totalExtractoITF = extractoITF.reduce((suma, item) => suma + item.monto, 0);
                
                // Diagnóstico detallado para BCP.USD
                const esBCPUSD_calc = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_calc) {
                    candidatosMayorITF.forEach((item, idx) => {
                    });
                    extractoITF.forEach((item, idx) => {
                    });
                }
                
                
                // Verificar si los totales coinciden (con tolerancia para errores de punto flotante)
                const diferenciaTotales = Math.abs(totalMayorITF - totalExtractoITF);
                const totalesCoinciden = diferenciaTotales < 0.01; // Tolerancia de 1 centavo
                
                // Diagnóstico específico para BCP.USD
                const esBCPUSD_prec = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_prec) {
                }
                
                
                if (totalesCoinciden) {
                    // CONCILIACIÓN EXITOSA: Asignar estados a TODOS los registros de ambos grupos
                    const refMayor = extractoITF.length > 0 ? extractoITF[0].operacionNumero : 'ITF-GLOBAL';
                    const refExtracto = candidatosMayorITF.length > 0 ? `${candidatosMayorITF[0].libro}-${candidatosMayorITF[0].comprob}` : '09-ITF';
                    
                    // Asignar estados a TODOS los registros del mayor ITF
                    candidatosMayorITF.forEach((item, idx) => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor // Mismo número de operación para todos
                        });
                        
                    });
                    
                    // Asignar estados a TODOS los registros del extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indiceOriginal, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                        
                    });
                    
                    conciliados = candidatosMayorITF.length + extractoITF.length; // Total de registros conciliados
                    
                } else {
                }
                
                // Diagnóstico específico para BCP.USD
                const esBCPUSD_res = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_res) {
                }
                
                
                return {
                    candidatos: candidatosLibro09ITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorITF,
                    totalExtracto: totalExtractoITF,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto) {
                /*
                PASO 11 SANTANDER - ITF ESPECÍFICO:
                
                ESTRATEGIA ESPECÍFICA:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER
                - Extracto: Descripción contiene "CARGO POR ITF", agrupar todos
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                
                let candidatosLibro09ITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                const candidatosMayorITF = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios SANT PASO 11: LIBRO "09" + GLOSA contiene "ITF"
                    const esLibro09 = String(libro || '').trim() === '09';
                    const esGlosaITF = glosa.includes('ITF');
                    
                    if (esLibro09 && esGlosaITF) {
                        candidatosLibro09ITF++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosMayorITF.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            comprob: comprob
                        });
                        
                    }
                }
                
                
                if (candidatosLibro09ITF === 0) {
                    return { candidatos: 0, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "CARGO POR ITF" EN EXTRACTO SANTANDER ===
                const extractoITF = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPECÍFICO SANTANDER ===
                    // Columna E (índice 4): Descripción - buscar "CARGO POR ITF" o "I.T.F."
                    // Columna G (índice 6): Importe
                    const descripcionExtracto = (filaExtracto[4] || '').toString().toUpperCase(); // Columna E - Descripcion
                    const importeExtracto = filaExtracto[6] || '0'; // Columna G
                    const referenciaExtracto = filaExtracto[3] || ''; // Columna D - Referencia
                    
                    // Verificar si contiene "CARGO POR ITF" o "I.T.F."
                    const esCargoITF = descripcionExtracto.includes('CARGO POR ITF') || descripcionExtracto.includes('I.T.F.');
                    
                    if (esCargoITF) {
                        candidatosExtractoITF++;
                        
                        const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                        
                        extractoITF.push({
                            indiceOriginal: i,
                            descripcion: descripcionExtracto,
                            monto: montoExtractoAbs,
                            referencia: referenciaExtracto,
                            filaCompleta: filaExtracto
                        });
                        
                    }
                }
                
                
                if (candidatosExtractoITF === 0) {
                    return { candidatos: candidatosLibro09ITF, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 3. MAPEAR: SUMA HABER vs SUMA |IMPORTE| ===
                const totalMayorHaber = candidatosMayorITF.reduce((suma, item) => suma + item.haber, 0);
                const totalExtractoImporte = extractoITF.reduce((suma, item) => suma + item.monto, 0);
                
                
                // Verificar si los totales coinciden
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                const totalesCoinciden = diferenciaTotales < 0.01; // Tolerancia para decimales
                
                
                if (totalesCoinciden) {
                    // CONCILIACIÓN EXITOSA: Asignar estados a TODOS los registros
                    const refMayor = extractoITF.length > 0 ? extractoITF[0].referencia : 'SANT-ITF';
                    const refExtracto = candidatosMayorITF.length > 0 ? `${candidatosMayorITF[0].libro}-${candidatosMayorITF[0].comprob}` : '09-ITF';
                    
                    // Asignar estados a TODOS los registros del mayor ITF
                    candidatosMayorITF.forEach((item, idx) => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor
                        });
                    });
                    
                    // Asignar estados a TODOS los registros del extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indiceOriginal, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                    });
                    
                    conciliados = candidatosMayorITF.length + extractoITF.length;
                    
                } else {
                }
                
                return {
                    candidatos: candidatosLibro09ITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 BBVA - ITF ESPECÍFICO:
                
                ESTRATEGIA ESPECÍFICA:
                - Mayor: GLOSA contiene "ITF" + HABER
                - Extracto: Concepto contiene "ITF", identificar total de operaciones
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                HEADERS BBVA: F. Operación, F. Valor, Código, Nº. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                // Paso 11 BBVA ITF
                // Estadísticas iniciales BBVA ITF
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                const candidatosMayor = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar si GLOSA contiene "ITF" y tiene HABER
                    if (glosa.includes('ITF') && haber > 0) {
                        candidatosMayorITF++;
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            glosa: glosa,
                            haber: haber,
                            debe: debe,
                            comprob: comprob,
                            libro: libro
                        });
                        
                        if (candidatosMayorITF <= 10) {
                        }
                    }
                }
                
                
                if (candidatosMayorITF === 0) {
                    return { candidatos: 0, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "ITF" EN EXTRACTO BBVA ===
                const extractoITF = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operación (Col A)
                    const concepto = (filaExtracto[4] || '').toString().toUpperCase(); // Concepto (Col E)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    
                    // Verificar si Concepto contiene "ITF"
                    if (concepto.includes('ITF')) {
                        candidatosExtractoITF++;
                        extractoITF.push({
                            indice: i,
                            fila: filaExtracto,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: importe,
                            importeAbsoluto: Math.abs(importe)
                        });
                        
                        if (candidatosExtractoITF <= 10) {
                            // Extracto ITF procesado
                        }
                    }
                }
                
                
                if (candidatosExtractoITF === 0) {
                    // No se encontraron candidatos ITF
                    return { candidatos: candidatosMayorITF, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 3. MAPEAR: SUMA HABER vs SUMA |IMPORTE| ===
                // Etapa 3: Mapeo total
                const totalMayorHaber = candidatosMayor.reduce((suma, item) => suma + item.haber, 0);
                const totalExtractoImporte = extractoITF.reduce((suma, item) => suma + item.importeAbsoluto, 0);
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                
                // Totales ITF calculados
                
                // Verificar si los totales coinciden (diferencia < 0.01)
                if (diferenciaTotales < 0.01) {
                    // Totales coinciden, conciliando
                    
                    // Conciliar todos los registros del Mayor ITF
                    candidatosMayor.forEach((candidato, idx) => {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `BBVA-ITF-${idx + 1}`
                        });
                    });
                    
                    // Conciliar todos los registros del Extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `ITF-${candidatosMayor[0]?.libro || 'XX'}-${candidatosMayor[0]?.comprob || 'XXXX'}`
                        });
                    });
                    
                    conciliados = candidatosMayor.length + extractoITF.length;
                    
                } else {
                }
                
                
                return {
                    candidatos: candidatosMayorITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 SBP (SCOTIABANK) - ITF ESPECÍFICO:
                
                Mayor (ESTÁNDAR): 
                - LIBRO = "09" + GLOSA contiene "ITF" + ESTADO = "Pendiente"
                - Suma total HABER de todos los registros ITF
                
                Extracto SBP (ESPECÍFICO):
                - Movimiento contiene "IMPUESTO" 
                - IDENTIFICAR TOTAL DE OPERACIONES "IMPUESTO"
                - Suma total |IMPORTE| de todos los registros IMPUESTO
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada" para todos los registros si totales coinciden
                */
                
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR (LÓGICA ESTÁNDAR) ===
                const candidatosITFMayor = [];
                let totalMayorHaber = 0;
                
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                if (i < 10) {
                    const glosaSafe = glosa ? glosa.substring(0, 40) : '';
                }
                    
                    // Verificar criterios ITF: LIBRO = "09" + GLOSA contiene "ITF"
                    const esITF = String(libro || '').trim() === '09' && glosa.includes('ITF') && haber > 0;
                    
                    if (esITF) {
                        candidatosMayorITF++;
                        totalMayorHaber += haber;
                        
                        
                        candidatosITFMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                
                // === 2. IDENTIFICAR IMPUESTO EN EXTRACTO SBP ===
                const candidatosImpuestoExtracto = [];
                let totalExtractoImporte = 0;
                
                // Analizando extracto SBP
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const movimiento = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                    const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0');
                    const operacion = filaExtracto[idxE.operacion] || '';
                    
                    if (j < 10) {
                    }
                    
                    // Verificar criterios IMPUESTO: Movimiento contiene "IMPUESTO"
                    if (movimiento.includes('IMPUESTO') && importe !== 0) {
                        candidatosExtractoITF++;
                        totalExtractoImporte += Math.abs(importe);
                        
                        // Extracto impuesto procesado
                        
                        candidatosImpuestoExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            movimiento: movimiento,
                            importe: Math.abs(importe),
                            operacion: operacion
                        });
                    }
                }
                
                
                // === 3. MAPEAR TOTALES MAYOR vs EXTRACTO ===
                // Mapeando totales SBP
                
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                
                // Comparando totales SBP
                
                if (diferenciaTotales < 0.01 && candidatosMayorITF > 0 && candidatosExtractoITF > 0) {
                    const refExtracto = candidatosImpuestoExtracto.length > 0 ? candidatosImpuestoExtracto[0].operacion : '';
                    const refMayor = candidatosITFMayor.length > 0 ? `${candidatosITFMayor[0].libro}-${candidatosITFMayor[0].comprob}` : '';
                    
                    
                    // Marcar todos los ITF del Mayor como conciliados
                    candidatosITFMayor.forEach(item => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                        conciliados++;
                        const glosaSafe = item.glosa ? item.glosa.substring(0, 30) : '';
                    });
                    
                    // Marcar todos los IMPUESTO del Extracto como conciliados
                    candidatosImpuestoExtracto.forEach(item => {
                        estadosExtracto.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor
                        });
                        conciliados++;
                        const movSafe = item.movimiento ? item.movimiento.substring(0, 30) : '';
                        // Extracto ITF conciliado
                    });
                } else {
                    // No match por diferencia o candidatos insuficientes
                }
                
                // SBP Paso 11 completado
                
                return {
                    candidatos: candidatosMayorITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso12(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 12 - CONCILIACIÓN POR AGRUPACIÓN DE MONEDAS:
                
                ESTRATEGIA:
                - Etapa 12A: FECHA exacta + MONTO exacto (tolerancia exacta)
                - Etapa 12B: Agrupación por moneda (PEN/USD)
                
                ETAPA 12B - CRITERIOS POR MONEDA:
                
                PEN (Soles):
                - Mayor: Agrupa por COMPROB, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Referencia, mapea por Fecha + |Total importe|
                
                USD (Dólares):
                - Mayor: Agrupa por FDOC, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Fecha, mapea por Fecha + |Total importe|
                
                CRITERIOS:
                - Solo registros PENDIENTES de cualquier libro
                - Normalización completa de fechas y montos
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliación A" (tolerancia exacta)
                - "P12 - Conciliación B" (agrupación por moneda)
                
                REFERENCIAS:
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                
                let conciliadosEtapa12A = 0;
                let conciliadosEtapa12B = 0;
                
                // Identificar candidatos PENDIENTES (cualquier libro)
                const candidatosPendientes = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Determinar monto principal (DEBE o HABER, el que sea mayor)
                    const montoPrincipal = Math.max(debe, haber);
                    
                    if (montoPrincipal > 0) {
                        candidatosPendientes.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            montoPrincipal: montoPrincipal,
                            comprob: comprob
                        });
                    }
                }
                
                
                if (candidatosPendientes.length === 0) {
                    return { etapa12a: 0, etapa12b: 0, totalConciliados: 0 };
                }
                
                // ETAPA 12A: Tolerancia Exacta
                conciliadosEtapa12A = this.procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                
                // ETAPA 12B: Agrupación por Moneda (PEN/USD)
                conciliadosEtapa12B = this.procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                
                const totalConciliados = conciliadosEtapa12A + conciliadosEtapa12B;
                
                
                return {
                    candidatos: candidatosPendientes.length,
                    etapa12a: conciliadosEtapa12A,
                    etapa12b: conciliadosEtapa12B,
                    totalConciliados: totalConciliados
                };
            },

            procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12A - TOLERANCIA EXACTA:
                - FECHA exacta + MONTO exacto (sin tolerancia)
                - Estado: "P12 - Conciliación A"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchPorToleranciaExacta(candidato.fdoc, candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliación A',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliación A',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                    }
                }
                
                return conciliados;
            },
            
            agruparExtractoPorReferencia(extractoProcesable, idxE, estadosExtracto) {
                /*
                Agrupa registros del extracto por Referencia para PEN
                */
                const grupos = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue; // Saltar si ya está procesado
                    
                    const fila = extractoProcesable[i];
                    const referencia = fila[idxE.referencia] || '';
                    const fecha = fila[idxE.fecha] || '';
                    const monto = Math.abs(parseFloat(fila[idxE.monto]) || 0);
                    
                    if (!grupos.has(referencia)) {
                        grupos.set(referencia, {
                            indices: [],
                            fecha: fecha,
                            totalImporte: 0
                        });
                    }
                    
                    grupos.get(referencia).indices.push(i);
                    grupos.get(referencia).totalImporte += monto;
                }
                
                return grupos;
            },
            
            agruparExtractoPorFecha(extractoProcesable, idxE, estadosExtracto) {
                /*
                Agrupa registros del extracto por Fecha para USD
                */
                const grupos = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue; // Saltar si ya está procesado
                    
                    const fila = extractoProcesable[i];
                    const fecha = fila[idxE.fecha] || '';
                    const monto = Math.abs(parseFloat(fila[idxE.monto]) || 0);
                    
                    if (!grupos.has(fecha)) {
                        grupos.set(fecha, {
                            indices: [],
                            totalImporte: 0
                        });
                    }
                    
                    grupos.get(fecha).indices.push(i);
                    grupos.get(fecha).totalImporte += monto;
                }
                
                return grupos;
            },
            
            buscarMatchGrupoExtractoPEN(fdoc, totalHaber, gruposExtracto) {
                /*
                Busca coincidencia para PEN: FDOC + TOTAL HABER vs Fecha + |Total importe|
                */
                for (const [referencia, grupo] of gruposExtracto) {
                    // Mapear FDOC con Fecha y TOTAL HABER con |Total importe|
                    if (fdoc === grupo.fecha && Math.abs(totalHaber - grupo.totalImporte) < 0.01) {
                        return {
                            encontrado: true,
                            referencia: referencia,
                            indices: grupo.indices
                        };
                    }
                }
                
                return { encontrado: false };
            },
            
            buscarMatchGrupoExtractoUSD(fdoc, totalHaber, gruposExtracto) {
                /*
                Busca coincidencia para USD: FDOC + TOTAL HABER vs Fecha + |Total importe|
                */
                for (const [fecha, grupo] of gruposExtracto) {
                    // Mapear FDOC con Fecha y TOTAL HABER con |Total importe|
                    if (fdoc === fecha && Math.abs(totalHaber - grupo.totalImporte) < 0.01) {
                        return {
                            encontrado: true,
                            fecha: fecha,
                            indices: grupo.indices
                        };
                    }
                }
                
                return { encontrado: false };
            },

            procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12B - AGRUPACIÓN POR MONEDA:
                
                PEN (Soles):
                - Mayor: Agrupa por COMPROB, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Referencia, mapea por Fecha + |Total importe|
                
                USD (Dólares):
                - Mayor: Agrupa por FDOC, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Fecha, mapea por Fecha + |Total importe|
                
                - Estado: "P12 - Conciliación B"
                */
                let conciliados = 0;
                
                // Separar candidatos por moneda (asumiendo que PEN es por defecto)
                const candidatosPEN = [];
                const candidatosUSD = [];
                
                for (const candidato of candidatosPendientes) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Determinar moneda basándose en algún criterio (aquí asumimos PEN por defecto)
                    // En una implementación real, esto debería basarse en un campo de moneda
                    const esUSD = this.esMonedaUSD(candidato.fila);
                    
                    if (esUSD) {
                        candidatosUSD.push(candidato);
                    } else {
                        candidatosPEN.push(candidato);
                    }
                }
                
                // Procesar PEN (Soles)
                if (candidatosPEN.length > 0) {
                    conciliados += this.procesarAgrupacionPEN(candidatosPEN, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                }
                
                // Procesar USD (Dólares)
                if (candidatosUSD.length > 0) {
                    conciliados += this.procesarAgrupacionUSD(candidatosUSD, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                }
                
                return conciliados;
            },

            esMonedaUSD(filaMayor) {
                /*
                Determina si un registro del Mayor corresponde a moneda USD
                Basándose en criterios específicos del banco SBP
                */
                // Implementación básica - en la práctica debería basarse en un campo específico
                // Por ahora, asumimos que ciertos libros o cuentas indican USD
                const cuenta = filaMayor[2] || ''; // Asumiendo que la cuenta está en la columna 2
                const glosa = filaMayor[8] || ''; // Asumiendo que la glosa está en la columna 8
                
                // Criterios para identificar USD (ajustar según la estructura real)
                return cuenta.includes('USD') || glosa.includes('USD') || glosa.includes('DOLAR');
            },
            
            procesarAgrupacionPEN(candidatosPEN, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                AGRUPACIÓN PEN (Soles):
                - Mayor: Agrupa por COMPROB, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Referencia, mapea por Fecha + |Total importe|
                */
                let conciliados = 0;
                
                // Agrupar Mayor por COMPROB
                const gruposMayorPEN = new Map();
                for (const candidato of candidatosPEN) {
                    const comprob = candidato.comprob;
                    if (!gruposMayorPEN.has(comprob)) {
                        gruposMayorPEN.set(comprob, {
                            candidatos: [],
                            fdoc: candidato.fdoc,
                            totalHaber: 0
                        });
                    }
                    gruposMayorPEN.get(comprob).candidatos.push(candidato);
                    gruposMayorPEN.get(comprob).totalHaber += candidato.haber;
                }
                
                // Agrupar Extracto por Referencia
                const gruposExtractoPEN = this.agruparExtractoPorReferencia(extractoProcesable, idxE, estadosExtracto);
                
                // Mapear grupos: FDOC + TOTAL HABER vs Fecha + |Total importe|
                for (const [comprob, grupoMayor] of gruposMayorPEN) {
                    const matchExtracto = this.buscarMatchGrupoExtractoPEN(grupoMayor.fdoc, grupoMayor.totalHaber, gruposExtractoPEN);
                    
                    if (matchExtracto.encontrado) {
                        // Conciliar todos los candidatos del grupo
                        for (const candidato of grupoMayor.candidatos) {
                            if (!estadosFilas.has(candidato.indice)) {
                                const refMayor = matchExtracto.referencia;
                                const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                                
                                estadosFilas.set(candidato.indice, {
                                    estado: 'P12 - Conciliación B',
                                    ref: refMayor
                                });
                                
                                conciliados++;
                            }
                        }
                        
                        // Marcar registros del extracto como conciliados
                        for (const indiceExtracto of matchExtracto.indices) {
                            if (!estadosExtracto.has(indiceExtracto)) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P12 - Conciliación B',
                                    ref: `LIBRO-${comprob}`
                                });
                            }
                        }
                    }
                }
                
                return conciliados;
            },
            
            procesarAgrupacionUSD(candidatosUSD, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                AGRUPACIÓN USD (Dólares):
                - Mayor: Agrupa por FDOC, mapea por FDOC + TOTAL HABER
                - Extracto: Agrupa por Fecha, mapea por Fecha + |Total importe|
                */
                let conciliados = 0;
                
                // Agrupar Mayor por FDOC
                const gruposMayorUSD = new Map();
                for (const candidato of candidatosUSD) {
                    const fdoc = candidato.fdoc;
                    if (!gruposMayorUSD.has(fdoc)) {
                        gruposMayorUSD.set(fdoc, {
                            candidatos: [],
                            totalHaber: 0
                        });
                    }
                    gruposMayorUSD.get(fdoc).candidatos.push(candidato);
                    gruposMayorUSD.get(fdoc).totalHaber += candidato.haber;
                }
                
                // Agrupar Extracto por Fecha
                const gruposExtractoUSD = this.agruparExtractoPorFecha(extractoProcesable, idxE, estadosExtracto);
                
                // Mapear grupos: FDOC + TOTAL HABER vs Fecha + |Total importe|
                for (const [fdoc, grupoMayor] of gruposMayorUSD) {
                    const matchExtracto = this.buscarMatchGrupoExtractoUSD(fdoc, grupoMayor.totalHaber, gruposExtractoUSD);
                    
                    if (matchExtracto.encontrado) {
                        // Conciliar todos los candidatos del grupo
                        for (const candidato of grupoMayor.candidatos) {
                            if (!estadosFilas.has(candidato.indice)) {
                                const refMayor = matchExtracto.fecha;
                                const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                                
                                estadosFilas.set(candidato.indice, {
                                    estado: 'P12 - Conciliación B',
                                    ref: refMayor
                                });
                                
                                conciliados++;
                            }
                        }
                        
                        // Marcar registros del extracto como conciliados
                        for (const indiceExtracto of matchExtracto.indices) {
                            if (!estadosExtracto.has(indiceExtracto)) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P12 - Conciliación B',
                                    ref: `LIBRO-${fdoc}`
                                });
                            }
                        }
                    }
                }
                
                return conciliados;
            },

            buscarMatchPorToleranciaExacta(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12A: FECHA exacta + MONTO exacto (tolerancia ±0.01)
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // FECHA exacta + MONTO exacto
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.01; // Tolerancia exacta
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferencia: diferenciaMonto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },
            
            buscarMatchPorToleranciaAmpliada(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12A: FECHA exacta + MONTO con tolerancia ±5.0
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // FECHA exacta + MONTO tolerancia ±5.0
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 5.0; // Tolerancia ampliada
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferencia: diferenciaMonto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchPorFechasAproximadas(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12B: MONTO exacto (±0.1) + FECHA ±2 días
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                if (!fechaMayorNormalizada) return { encontrado: false };
                
                const fechaMayorObj = new Date(fechaMayorNormalizada);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    if (!fechaExtractoNormalizada) continue;
                    const fechaExtractoObj = new Date(fechaExtractoNormalizada);
                    
                    // MONTO exacto + FECHA ±2 días
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    const diferenciaDias = Math.abs((fechaMayorObj - fechaExtractoObj) / (1000 * 60 * 60 * 24));
                    const fechasAproximadas = diferenciaDias <= 2; // ±2 días
                    
                    if (montosCoinciden && fechasAproximadas) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferenciaDias: diferenciaDias,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchSoloMonto(montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12C: Solo MONTO exacto (±0.1), ignorar fechas completamente
                */
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // Solo MONTO exacto (ignorar fechas)
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    if (montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchExtractoPorGrupo(fechaGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 5 (grupos):
                - Compara fecha del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto están en negativo, se usa Math.abs()
                */
                
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operación Número
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupo === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchExtracto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 4:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto están en negativo, se usa Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                let candidatosRevisados = 0;
                let mejoresMatches = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Saltar si ya está procesado
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila; // Acceder a la fila dentro del objeto
                    const fechaExtracto = filaExtracto[0] || ''; // Columna A
                    const montoExtractoRaw = this.normalizarMonto(filaExtracto[3] || '0'); // Columna D
                    const montoExtracto = Math.abs(montoExtractoRaw); // VALOR ABSOLUTO para extracto
                    const operacionNumero = filaExtracto[6] || ''; // Columna G
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMontos = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMontos === 0; // Exacto para PASO 4
                    
                    candidatosRevisados++;
                    
                    if (fechasCoinciden || montosCoinciden || candidatosRevisados <= 2) {
                        
                        if (fechasCoinciden || montosCoinciden) {
                            mejoresMatches.push({
                                indice: i,
                                fechaMatch: fechasCoinciden,
                                montoMatch: montosCoinciden,
                                diferenciaMonto: diferenciaMontos,
                                fechaExtracto: fechaExtracto,
                                montoExtracto: montoExtracto
                            });
                        }
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtracto,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                if (mejoresMatches.length > 0) {
                    mejoresMatches.slice(0, 3).forEach((match, idx) => {
                    });
                }
                
                return {
                    encontrado: false,
                    indice: -1,
                    fecha: '',
                    monto: 0,
                    operacionNumero: ''
                };
            },

            // Nueva función para formato dd/mm/aaaa
            normalizarFechaP9B(fechaRaw) {
                /*
                Normaliza fechas a formato DD/MM/YYYY para P9B
                Maneja múltiples formatos de entrada y los convierte a DD/MM/YYYY
                */
                if (!fechaRaw) return '';
                
                const fechaStr = fechaRaw.toString().trim();
                if (!fechaStr) return '';
                
                // Detectar si es un número serial de Excel
                const numeroSerial = parseFloat(fechaStr);
                if (!isNaN(numeroSerial) && numeroSerial > 1 && numeroSerial < 100000 && !fechaStr.includes('/') && !fechaStr.includes('-') && !fechaStr.includes('.')) {
                    const fechaConvertida = this.convertirSerialExcelAFecha(numeroSerial);
                    // Convertir YYYY-MM-DD a DD/MM/YYYY
                    if (fechaConvertida && fechaConvertida.includes('-')) {
                        const [ano, mes, dia] = fechaConvertida.split('-');
                        return `${dia}/${mes}/${ano}`;
                    }
                    return fechaConvertida;
                }
                
                // Limpiar y detectar separadores
                const separadores = ['-', '/', '.'];
                let separador = null;
                
                for (const sep of separadores) {
                    if (fechaStr.includes(sep)) {
                        separador = sep;
                        break;
                    }
                }
                
                if (!separador) return '';
                
                const partes = fechaStr.split(separador);
                if (partes.length !== 3) return '';
                
                let dia, mes, ano;
                const [p1, p2, p3] = partes.map(p => parseInt(p, 10));
                
                // Detectar formato
                if (p1 > 1900 && p1 < 2100 && separador === '.') {
                    // Formato DET: YYYY.MM.DD
                    ano = p1; mes = p2; dia = p3;
                } else if (p1 > 31) {
                    // Formato YYYY-MM-DD o YYYY-DD-MM
                    ano = p1;
                    if (p2 > 12) { mes = p3; dia = p2; } 
                    else { mes = p2; dia = p3; }
                } else if (p3 > 31 || (p3 > 24 && p3 < 100)) {
                    // Formato DD-MM-YYYY o MM-DD-YYYY
                    ano = p3 < 100 ? 2000 + p3 : p3;
                    if (p1 > 12) { dia = p1; mes = p2; } 
                    else if (p2 > 12) { dia = p2; mes = p1; } 
                    else { dia = p1; mes = p2; } // Asumir DD-MM-YYYY
                } else {
                    return '';
                }
                
                // Validar rangos
                if (mes < 1 || mes > 12 || dia < 1 || dia > 31 || ano < 1900) return '';
                
                // Formatear como DD/MM/YYYY
                const diaStr = dia.toString().padStart(2, '0');
                const mesStr = mes.toString().padStart(2, '0');
                
                return `${diaStr}/${mesStr}/${ano}`;
            },

            // Función para ordenar fechas en formato DD/MM/YYYY
            ordenarPorFechaP9B(fecha1, fecha2) {
                /*
                Compara dos fechas en formato DD/MM/YYYY para ordenamiento
                Retorna: -1 si fecha1 < fecha2, 1 si fecha1 > fecha2, 0 si son iguales
                */
                if (!fecha1 || !fecha2) return 0;
                
                const [dia1, mes1, ano1] = fecha1.split('/').map(Number);
                const [dia2, mes2, ano2] = fecha2.split('/').map(Number);
                
                // Comparar año, luego mes, luego día
                if (ano1 !== ano2) return ano1 - ano2;
                if (mes1 !== mes2) return mes1 - mes2;
                return dia1 - dia2;
            },

            normalizarFecha(fechaRaw) {
                /*
                Normaliza fechas a formato YYYY-MM-DD para comparación
                Maneja múltiples formatos de entrada:
                - DD/MM/YYYY, DD-MM-YYYY
                - YYYY/MM/DD, YYYY-MM-DD
                - DD/MM/YY, etc.
                - Números seriales de Excel (45809 = días desde 1900-01-01)
                */
                
                // if (fechaRaw && fechaRaw.toString().includes('2025.06')) {
                // }
                
                if (!fechaRaw) return '';
                
                const fechaStr = fechaRaw.toString().trim();
                if (!fechaStr) return '';
                
                // Detectar si es un número serial de Excel (5 dígitos aproximadamente)
                const numeroSerial = parseFloat(fechaStr);
                if (!isNaN(numeroSerial) && numeroSerial > 1 && numeroSerial < 100000 && !fechaStr.includes('/') && !fechaStr.includes('-') && !fechaStr.includes('.')) {
                    const fechaConvertida = this.convertirSerialExcelAFecha(numeroSerial);
                    // if (numeroSerial >= 45800 && numeroSerial <= 45900) {
                    // }
                    return fechaConvertida;
                }
                
                // Limpiar y detectar separadores para fechas normales
                const separadores = ['-', '/', '.'];
                let separador = null;
                
                for (const sep of separadores) {
                    if (fechaStr.includes(sep)) {
                        separador = sep;
                        break;
                    }
                }
                
                if (!separador) {
                    return '';
                }
                
                const partes = fechaStr.split(separador);
                if (partes.length !== 3) {
                    return '';
                }
                
                let dia, mes, ano;
                
                // Detectar formato basado en longitud y valores
                const [p1, p2, p3] = partes.map(p => parseInt(p, 10));
                
                // if (fechaStr.includes('2025.06.30')) {
                // }
                
                // FORMATO DET ESPECÍFICO: aaaa.mm.dd (ejemplo: 2025.06.03)
                if (p1 > 1900 && p1 < 2100 && separador === '.') {
                    // Formato DET: YYYY.MM.DD
                    ano = p1;
                    mes = p2;
                    dia = p3;
                    // if (fechaStr.includes('2025.06.30')) {
                    // }
                } else if (p1 > 31) {
                    // Formato YYYY-MM-DD o YYYY-DD-MM
                    ano = p1;
                    if (p2 > 12) {
                        mes = p3;
                        dia = p2;
                    } else {
                        mes = p2;
                        dia = p3;
                    }
                } else if (p3 > 31 || (p3 > 24 && p3 < 100)) {
                    // Formato DD-MM-YYYY o MM-DD-YYYY
                    ano = p3 < 100 ? 2000 + p3 : p3;
                    if (p1 > 12) {
                        dia = p1;
                        mes = p2;
                    } else if (p2 > 12) {
                        dia = p2;
                        mes = p1;
                    } else {
                        // Asumir DD-MM-YYYY
                        dia = p1;
                        mes = p2;
                    }
                } else {
                    return '';
                }
                
                // Validar rangos
                if (mes < 1 || mes > 12 || dia < 1 || dia > 31 || ano < 1900) {
                    return '';
                }
                
                // Formatear con ceros a la izquierda
                const mesStr = mes.toString().padStart(2, '0');
                const diaStr = dia.toString().padStart(2, '0');
                
                const resultado = `${ano}-${mesStr}-${diaStr}`;
                
                // if (fechaStr.includes('2025.06.30')) {
                // }
                
                return resultado;
            },

            convertirSerialExcelAFecha(serial) {
                /*
                Convierte números seriales de Excel a fechas
                Excel usa 1899-12-30 como día 0, 1900-01-01 como día 2 (bug histórico)
                */
                
                // Fecha base de Excel: 1899-12-30 00:00:00 (día 0)
                const fechaBase = new Date(1899, 11, 30, 0, 0, 0, 0);
                
                // Agregar los días directamente
                const fechaResultado = new Date(fechaBase.getTime() + serial * 24 * 60 * 60 * 1000);
                
                // Formatear a YYYY-MM-DD
                const año = fechaResultado.getFullYear();
                const mes = (fechaResultado.getMonth() + 1).toString().padStart(2, '0');
                const dia = fechaResultado.getDate().toString().padStart(2, '0');
                
                return `${año}-${mes}-${dia}`;
            },

            procesarPaso3(filaMayor, extracto, idxM, idxE, todasLasFilasMayor, saldoData = null, indiceFilaActual = -1) {
        /*
        PASO 3 - PROCESAMIENTO DE DOCUMENTOS ANULADOS (3 ETAPAS):
        
        ETAPA 3a: Filtrar por GLOSA contiene "ANULADO" (se hace en el bucle principal)
        ETAPA 3b: Mayor vs Saldo por NUMDOC → ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        ETAPA 3c: Mayor interno por NUMDOC + coincidencia exacta (SEGUNDO):
        - DEBE → ESTADO="P3 - Conciliada", REF="Anula a [valor_comprob]" 
        - HABER → ESTADO="P3 - Conciliada", REF="Anulado por [valor_comprob]"
        */
        
        const glosa = filaMayor[idxM.glosa] || '';
        
        // ETAPA 3a: Verificar si tiene "ANULADO" en GLOSA
        if (!glosa.toUpperCase().includes("ANULADO")) {
            return { estado: '', ref: '', etapa: 0 };
        }
        
        const fecha = filaMayor[idxM.fdoc];
        const montoDebe = this.normalizarMonto(filaMayor[idxM.debe] || 0);
        const montoHaber = this.normalizarMonto(filaMayor[idxM.haber] || 0);
        const numdoc = filaMayor[idxM.numdoc] || '';
        const comprob = filaMayor[idxM.comprob] || '';
        
        // Determinar si está en DEBE o HABER y el monto a buscar
        const estaEnDebe = montoDebe > 0;
        const montoABuscar = estaEnDebe ? montoDebe : montoHaber;
        
        
        // ETAPA 3b: MAPEAR MAYOR VS SALDO POR NUMDOC → ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        if (saldoData && saldoData.length > 1) {
            // Mapear índices del saldo
            const headerSaldo = saldoData[0] || [];
            const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                cuenta: ['CUENTA'], numdoc: ['NUMDOC'], debe: ['DEBE'], haber: ['HABER'], 
                fdoc: ['FDOC'], comprobante: ['COMPROBANTE', 'COMPROB']
            });
            
            const filasSaldo = saldoData.slice(1);
            
            // Normalizar NUMDOC del mayor para comparación
            const numdocMayorNormalizado = this.normalizarTexto(numdoc);
            
            for (let idx = 0; idx < filasSaldo.length; idx++) {
                const filaSaldo = filasSaldo[idx];
                const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                const debeSaldoRaw = filaSaldo[indicesSaldo.debe] || '';
                const haberSaldoRaw = filaSaldo[indicesSaldo.haber] || '';
                
                // Normalizar y parsear montos
                const debeSaldo = this.normalizarMonto(debeSaldoRaw);
                const haberSaldo = this.normalizarMonto(haberSaldoRaw);
                
                // Columna M (índice 12) para Comprobante
                const comprobanteSaldo = filaSaldo[12] || filaSaldo[indicesSaldo.comprobante] || '';
                
                // Buscar por NUMDOC normalizado (ORIGINAL + VARIANTES "A")
                if (numdocMayorNormalizado && numdocSaldoNormalizado && 
                    (numdocMayorNormalizado === numdocSaldoNormalizado || this.compararNumdocConVarianteA(numdocMayorNormalizado, numdocSaldoNormalizado))) {
                    
                    // Comparar tanto DEBE como HABER del saldo con el monto del mayor
                    const diferenciaDebe = Math.abs(montoABuscar - debeSaldo);
                    const diferenciaHaber = Math.abs(montoABuscar - haberSaldo);
                    
                    
                    // Si cualquiera de las dos diferencias es exacta, es un match
                    if (diferenciaDebe === 0 || diferenciaHaber === 0) {
                        const mejorMatch = diferenciaDebe < diferenciaHaber ? 'DEBE' : 'HABER';
                        const mejorDiferencia = Math.min(diferenciaDebe, diferenciaHaber);
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: 'Anulado Saldo', 
                            etapa: 2,
                            indiceParejaEncontrada: idx,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: 'Anulado Mayor'
                        };
                    } else {
                    }
                }
            }
            
        } else {
        }
        
        // ETAPA 3c: MAPEAR DENTRO DEL MAYOR POR NUMDOC CON DEBE/HABER (SEGUNDO)
        
        let candidatosEncontrados = 0;
        const numdocMayorNormalizado = this.normalizarTexto(numdoc);
        const candidatosDetalle = [];
        
        for (let i = 0; i < todasLasFilasMayor.length; i++) {
            const otraFila = todasLasFilasMayor[i];
            
            // Saltar la misma fila
            if (otraFila === filaMayor) continue;
            
            const otroMontoDebe = this.normalizarMonto(otraFila[idxM.debe] || 0);
            const otroMontoHaber = this.normalizarMonto(otraFila[idxM.haber] || 0);
            const otroNumdocRaw = otraFila[idxM.numdoc] || '';
            const otroNumdocNormalizado = this.normalizarTexto(otroNumdocRaw);
            const otroComprob = otraFila[idxM.comprob] || '';
            const otraGlosa = otraFila[idxM.glosa] || '';
            
            // Criterios: mismo NUMDOC normalizado (ORIGINAL + VARIANTES "A")
            const coincidenNumdoc = numdocMayorNormalizado && otroNumdocNormalizado && 
                (numdocMayorNormalizado === otroNumdocNormalizado || this.compararNumdocConVarianteA(numdocMayorNormalizado, otroNumdocNormalizado));
            
            if (coincidenNumdoc) {
                candidatosEncontrados++;
                
                // Verificar si está en la columna contraria y con el mismo monto (exacto)
                const montoAComparar = estaEnDebe ? otroMontoHaber : otroMontoDebe;
                const diferenciaMonto = Math.abs(montoAComparar - montoABuscar);
                const coincideMonto = diferenciaMonto === 0;
                
                // Guardar detalles del candidato
                candidatosDetalle.push({
                    fila: i + 1,
                    numdoc: otroNumdocRaw,
                    debe: otroMontoDebe,
                    haber: otroMontoHaber,
                    comprob: otroComprob,
                    montoComparar: montoAComparar,
                    diferencia: diferenciaMonto,
                    coincide: coincideMonto
                });
                
                
                if (coincideMonto) {
                    
                    // Determinar estados según DEBE/HABER y usar COMPROB de la pareja
                    if (estaEnDebe) {
                        // Este registro está en DEBE → "Anula a [comprob_de_la_pareja]"
                        // La pareja está en HABER → "Anulado por [comprob_de_este]"
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anula a ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anulado por ${comprob}`
                        };
                    } else {
                        // Este registro está en HABER → "Anulado por [comprob_de_la_pareja]"
                        // La pareja está en DEBE → "Anula a [comprob_de_este]"
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anulado por ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anula a ${comprob}`
                        };
                    }
                }
            }
        }
        
        if (candidatosDetalle.length > 0) {
            candidatosDetalle.forEach((cand, idx) => {
            });
        }
        
        // Si llegamos aquí, no se pudo procesar la anulación
        return { 
            estado: '', 
            ref: '', 
            etapa: 0,
            indiceParejaEncontrada: -1,
            estadoPareja: '',
            refPareja: ''
        };
                        },

            // === FUNCIÓN PARA COMPARAR NUMDOC SOLO CON VARIANTES "A" ===
            compararNumdocConVarianteA(numdoc1, numdoc2) {
                // Esta función SOLO maneja variantes "A", NO comparaciones exactas
                const num1 = (numdoc1 || '').toString().trim().toUpperCase();
                const num2 = (numdoc2 || '').toString().trim().toUpperCase();
                
                if (!num1 || !num2) return false;
                
                // Solo verificar variantes "A" (NO comparación exacta)
                // Ejemplo: "25-85A" ↔ "25-85" o "25-85" ↔ "25-85A"
                
                // Verificar si num1 termina en "A" y num2 es su base
                if (num1.endsWith('A')) {
                    const baseNum1 = num1.slice(0, -1); // Remover la "A"
                    if (baseNum1 === num2) {
                        return true;
                    }
                }
                
                // Verificar si num2 termina en "A" y num1 es su base  
                if (num2.endsWith('A')) {
                    const baseNum2 = num2.slice(0, -1); // Remover la "A"
                    if (baseNum2 === num1) {
                        return true;
                    }
                }
                
                // Si no hay variante "A", retorna false
                return false;
            },
     
            buscarIndicesColumnas(headers, mapeo) {
         const indices = {};
         for (const [clave, posiblesNombres] of Object.entries(mapeo)) {
            let encontrado = false;
             for (let i = 0; i < headers.length; i++) {
                 const header = (headers[i] || '').toString().toUpperCase().trim();
                if (posiblesNombres.some(nombre => header.includes(nombre.toUpperCase()))) {
                         indices[clave] = i;
                    encontrado = true;
                         break;
                     }
                 }
            if (!encontrado) indices[clave] = -1;
         }
         return indices;
            },
     
            // Función para normalizar texto (eliminar espacios, convertir a mayúsculas)
            normalizarTexto(texto) {
                if (!texto) return '';
                let normalizado = texto.toString().trim().toUpperCase().replace(/\s+/g, '');
                
                // Si es un número puro, eliminar ceros a la izquierda pero mantener al menos un dígito
                if (/^\d+$/.test(normalizado)) {
                    normalizado = normalizado.replace(/^0+/, '') || '0';
                }
                
                return normalizado;
            },
            
            // Función para normalizar y parsear montos
            normalizarMonto(montoRaw) {
                if (!montoRaw) return 0;
                
                // Convertir a string y limpiar espacios
                let montoStr = montoRaw.toString().trim().replace(/\s+/g, '');
                
                // Si está vacío después de limpiar, retornar 0
                if (!montoStr) return 0;
                
                // Detectar diferentes formatos de números
                let montoLimpio;
                let tipoFormato = '';
                
                // NUEVO: Manejar números negativos
                const esNegativo = montoStr.startsWith('-');
                if (esNegativo) {
                    montoStr = montoStr.substring(1);
                }
                
                // Formato 1: Solo números con coma decimal (18956,26)
                if (/^\d+,\d+$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(',', '.');
                    tipoFormato = 'europeo simple';
                }
                // Formato 2: Formato europeo con separador de miles punto y decimal coma (46.744,48)
                else if (/^\d{1,3}(\.\d{3})+,\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                    tipoFormato = 'europeo con separador miles';
                }
                // Formato 3: Formato americano con separador de miles coma y decimal punto (46,744.48)
                else if (/^\d{1,3}(,\d{3})+\.\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/,/g, '');
                    tipoFormato = 'americano con separador miles';
                }
                // Formato 4: Solo punto decimal (18956.26)
                else if (/^\d+\.\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'decimal punto';
                }
                // Formato 5: Solo números enteros (18956)
                else if (/^\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'entero';
                }
                // MEJORADO: Formato mixto problemático - detectar contexto
                else if (montoStr.includes(',') && montoStr.includes('.')) {
                    // Si hay más puntos que comas, probablemente sea europeo (46.744,48)
                    const puntos = (montoStr.match(/\./g) || []).length;
                    const comas = (montoStr.match(/,/g) || []).length;
                    
                    if (puntos > comas) {
                        // Europeo: punto separador miles, coma decimal
                        montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                        tipoFormato = 'mixto - europeo detectado';
                    } else {
                        // Americano: coma separador miles, punto decimal
                        montoLimpio = montoStr.replace(/,/g, '');
                        tipoFormato = 'mixto - americano detectado';
                    }
                }
                // Por defecto: eliminar todo excepto números y punto
                else {
                    montoLimpio = montoStr.replace(/[^0-9.]/g, '');
                    tipoFormato = 'limpieza general';
                }
                
                let monto = parseFloat(montoLimpio);
                if (isNaN(monto)) monto = 0;
                
                // Aplicar signo negativo si corresponde
                if (esNegativo) monto = -monto;
                
                const resultado = monto;
                
                // if (montoStr.includes('46744') || montoStr.includes('46.744') || 
                //     montoStr.includes('18956') || montoStr.includes('27788') ||
                //     resultado === 0 || tipoFormato.includes('mixto') || tipoFormato === 'limpieza general') {
                // }
                
                return resultado;
            },

            // === FACTORY DE ESTRATEGIAS POR CUENTA ===
            
            // Ejecutar estrategia específica por cuenta y paso (simplificado)
            executeAccountStrategy(codigoCuenta, numeroPaso, ...args) {
                const estrategia = this.getEstrategiaProcesamiento(codigoCuenta, numeroPaso);
                
                // Por ahora, usar lógica existente con estrategia como parámetro adicional
                // En el futuro aquí se implementará la lógica específica por banco
                return this[`procesarPaso${numeroPaso}`](...args);
            },
            
            // Procesar lógica específica por cuenta (preparado para futuro)
            processAccountSpecificLogic(codigoCuenta, paso, data) {
                const config = this.cuentasConfig[codigoCuenta];
                if (!config || !config.activo) {
                    return null;
                }
                
                const estrategia = config.pasos[`paso${paso}`];
                
                // Placeholder para futuras implementaciones específicas
                switch (estrategia) {
                    case 'anulaciones_bcp02':
                        return this.procesarAnulacionesBCP02(data);
                    case 'depositos_bancarios_bcp02':
                        return this.procesarDepositosBCP02(data);
                    case 'anulaciones_santander':
                        return this.procesarAnulacionesSantander(data);
                    case 'anulaciones_ibk':
                        return this.procesarAnulacionesIBK(data);
                    default:
                        return null; // Usar lógica estándar
                }
            },

            procesarPaso9BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 9 BBVA - AGRUPACIÓN POR COMISIONES:
                
                CRITERIOS DE FILTRADO:
                - GLOSA debe contener "COMISION REC" (Mayor)
                - Concepto debe contener "COMISION REC" (BBVA Extracto)
                
                ESTRATEGIA:
                1. Agrupar por FDOC + TOTAL HABER (Mayor)
                2. Agrupar por F. Operación + |Total importe| (BBVA Extracto)
                3. Comparar grupos por fecha y monto total
                
                MAPEO:
                - FDOC + TOTAL HABER (Mayor) ↔ F. Operación + |Total importe| (BBVA Extracto)
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada" para ambos registros
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                
                let candidatosComisionRec = 0;
                let gruposMayorFormados = 0;
                let gruposExtractoFormados = 0;
                let conciliados = 0;
                
                // === 1. AGRUPAR POR COMISIONES EN MAYOR ===
                const gruposPorComisionMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const libro = filaMayor[idxM.libro] || '';
                    const comprob = filaMayor[idxM.comprob] || '';
                    const glosa = filaMayor[idxM.glosa] || '';
                    
                    // Verificar si GLOSA contiene "COMISION REC"
                    const glosaUpper = glosa.toString().toUpperCase().trim();
                    const esComisionRec = glosaUpper.includes('COMISION REC');
                    
                    if (esComisionRec) {
                        // Contar candidatos de comisión
                        candidatosComisionRec++;
                        
                        if (candidatosComisionRec <= 3) {
                        }
                        
                        // Crear clave de agrupación solo por FECHA (no por monto individual)
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const claveGrupo = fechaNormalizada;
                        
                        if (!gruposPorComisionMayor.has(claveGrupo)) {
                            gruposPorComisionMayor.set(claveGrupo, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorComisionMayor.get(claveGrupo);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            haber: haber,
                            libro: libro,
                            comprob: comprob,
                            glosa: glosa
                        });
                    }
                }
                
                gruposMayorFormados = gruposPorComisionMayor.size;
                
                
                let grupoNumMayor = 1;
                for (const [fecha, grupo] of gruposPorComisionMayor.entries()) {
                    if (grupoNumMayor <= 3) {
                    }
                    grupoNumMayor++;
                }
                
                if (gruposMayorFormados === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR COMISIONES EN EXTRACTO BBVA ===
                const gruposPorComisionExtracto = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPECÍFICO BBVA CORREGIDO ===
                    // Columna A (índice 0): F. Operación
                    // Columna F (índice 5): Importe
                    // Columna D (índice 3): Nº. Doc.
                    // Columna E (índice 4): Concepto
                    const fechaOperacion = filaExtracto[0] || '';
                    const importe = filaExtracto[5] || '0'; // Índice 5 - Importe
                    const operacionNumero = filaExtracto[3] || ''; // Índice 3 - Nº. Doc.
                    const concepto = filaExtracto[4] || ''; // Índice 4 - Concepto
                    
                    // Verificar si concepto CONTIENE "COMISION REC"
                    const conceptoUpper = concepto.toString().toUpperCase().trim();
                    const esComisionRecExtracto = conceptoUpper.includes('COMISION REC');
                    
                    if (esComisionRecExtracto) {
                        const fechaNormalizada = this.normalizarFecha(fechaOperacion);
                        const montoOriginal = this.normalizarMonto(importe); // SIN valor absoluto aún
                        
                        if (gruposPorComisionExtracto.size < 3) {
                        }
                        
                        // Crear clave de agrupación solo por FECHA (no por monto individual)
                        const claveGrupo = fechaNormalizada;
                        
                        if (!gruposPorComisionExtracto.has(claveGrupo)) {
                            gruposPorComisionExtracto.set(claveGrupo, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fechaOperacion,
                                totalImporte: 0, // Suma directa SIN valor absoluto
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorComisionExtracto.get(claveGrupo);
                        grupo.totalImporte += montoOriginal; // Sumar con signo original
                        grupo.filas.push({
                            indice: i,
                            fila: filaExtracto,
                            fecha: fechaOperacion,
                            importe: importe,
                            montoOriginal: montoOriginal,
                            operacionNumero: operacionNumero,
                            concepto: concepto
                        });
                    }
                }
                
                gruposExtractoFormados = gruposPorComisionExtracto.size;
                
                
                let grupoNum = 1;
                for (const [fecha, grupo] of gruposPorComisionExtracto.entries()) {
                    if (grupoNum <= 3) {
                    }
                    grupoNum++;
                }
                
                if (gruposExtractoFormados === 0) {
                    return { candidatos: candidatosComisionRec, grupos: gruposMayorFormados, conciliados: 0 };
                }
                
                // === 3. COMPARAR GRUPOS Y CONCILIAR ===
                
                for (const [claveMayor, grupoMayor] of gruposPorComisionMayor.entries()) {
                    // Buscar grupo correspondiente en extracto
                    const grupoExtracto = gruposPorComisionExtracto.get(claveMayor);
                    
                    if (grupoExtracto) {
                        // PASO 3: Comparar aplicando valor absoluto AL TOTAL del extracto
                        const totalMayor = grupoMayor.totalHaber;
                        const totalExtractoAbsoluto = Math.abs(grupoExtracto.totalImporte);
                        const diferenciaMonto = Math.abs(totalMayor - totalExtractoAbsoluto);
                        const montosCoinciden = diferenciaMonto === 0;
                        
                        
                        if (montosCoinciden) {
                            // CONCILIACIÓN EXITOSA: Asignar estados a TODOS los registros de ambos grupos
                            const refMayor = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].operacionNumero : 'COMISION-GLOBAL';
                            const refExtracto = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : 'COMISION-MAYOR';
                            
                            // Asignar estados a TODOS los registros del mayor
                            grupoMayor.filas.forEach((item, idx) => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refMayor
                                });
                                
                            });
                            
                            // Asignar estados a TODOS los registros del extracto
                            grupoExtracto.filas.forEach((item, idx) => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refExtracto
                                });
                                
                            });
                            
                            conciliados += grupoMayor.filas.length + grupoExtracto.filas.length;
                            
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosComisionRec,
                    grupos: gruposMayorFormados,
                    conciliados: conciliados,
                    comisionRec: candidatosComisionRec
                };
            },

            procesarPaso12BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 BBVA (PEN/USD) - AGRUPACIÓN POR FDOC + TOTAL HABER:
                
                NUEVA ESTRATEGIA:
                1. Mayor: Agrupar por FDOC + sumar TOTAL HABER de todos los libros pendientes
                2. Extracto: Agrupar por F. Operación (columna A) + |Importe| (columna F)
                3. Mapear: FDOC+TOTAL_HABER ↔ F.Operación+|Importe|
                
                CRITERIO:
                - Coincidencia exacta de montos agrupados (tolerancia 0.01)
                - Procesa TODOS los pendientes de TODOS los libros
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada" para todos los registros del grupo
                - Mayor: #REF = F. Operación del Extracto
                - Extracto: #REF = "FDOC-GRUPO" del Mayor
                */
                
                
                let gruposMayor = 0;
                let gruposExtracto = 0;
                let conciliados = 0;
                
                // === 1. AGRUPAR PENDIENTES DEL MAYOR POR FDOC ===
                const gruposPorFDOC = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const fdoc = this.normalizarFecha(filaMayor[idxM.fdoc] || '');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const libro = filaMayor[idxM.libro] || '';
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Solo considerar registros con HABER > 0
                    if (haber > 0 && fdoc) {
                        const claveGrupo = fdoc; // Agrupar por FDOC
                        
                        if (!gruposPorFDOC.has(claveGrupo)) {
                            gruposPorFDOC.set(claveGrupo, {
                                fdoc: fdoc,
                                totalHaber: 0,
                                registros: [],
                                libros: new Set()
                            });
                        }
                        
                        const grupo = gruposPorFDOC.get(claveGrupo);
                        grupo.totalHaber += haber;
                        grupo.registros.push({
                            indice: i,
                            fila: filaMayor,
                            haber: haber,
                            libro: libro,
                            comprob: comprob
                        });
                        grupo.libros.add(libro);
                    }
                }
                
                gruposMayor = gruposPorFDOC.size;
                
                // Mostrar grupos del Mayor
                for (const [fdoc, grupo] of gruposPorFDOC) {
                }
                
                if (gruposMayor === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR PENDIENTES DEL EXTRACTO POR F. OPERACIÓN ===
                const gruposPorOperacion = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Columna A (índice 0): F. Operación
                    // Columna F (índice 5): Importe
                    const fOperacion = (filaExtracto[0] || '').toString().trim();
                    const importe = filaExtracto[5] || '0';
                    
                    const montoOriginal = this.normalizarMonto(importe);
                    const montoAbsoluto = Math.abs(montoOriginal);
                    
                    if (montoAbsoluto > 0 && fOperacion) {
                        const claveGrupo = fOperacion; // Agrupar por F. Operación
                        
                        if (!gruposPorOperacion.has(claveGrupo)) {
                            gruposPorOperacion.set(claveGrupo, {
                                fOperacion: fOperacion,
                                totalImporte: 0,
                                registros: []
                            });
                        }
                        
                        const grupo = gruposPorOperacion.get(claveGrupo);
                        grupo.totalImporte += montoAbsoluto;
                        grupo.registros.push({
                            indice: i,
                            fila: filaExtracto,
                            importe: montoAbsoluto,
                            importeOriginal: montoOriginal
                        });
                    }
                }
                
                gruposExtracto = gruposPorOperacion.size;
                
                // Mostrar grupos del Extracto
                for (const [fOperacion, grupo] of gruposPorOperacion) {
                }
                
                if (gruposExtracto === 0) {
                    return { candidatos: gruposMayor, grupos: gruposMayor + gruposExtracto, conciliados: 0 };
                }
                
                // === 3. MAPEO DE GRUPOS: FDOC+TOTAL_HABER ↔ F.OPERACIÓN+|IMPORTE| ===
                const gruposUsadosExtracto = new Set();
                
                for (const [fdocMayor, grupoMayor] of gruposPorFDOC) {
                    const totalHaberMayor = grupoMayor.totalHaber;
                    
                    // Buscar coincidencia en extracto
                    for (const [fOperacionExtracto, grupoExtracto] of gruposPorOperacion) {
                        if (gruposUsadosExtracto.has(fOperacionExtracto)) continue;
                        
                        const totalImporteExtracto = grupoExtracto.totalImporte;
                        const diferencia = Math.abs(totalHaberMayor - totalImporteExtracto);
                        
                        if (diferencia < 0.01) { // Tolerancia de 1 centavo
                            // CONCILIACIÓN DE GRUPOS EXITOSA
                            
                            // Asignar estados a todos los registros del grupo Mayor
                            for (const registroMayor of grupoMayor.registros) {
                                estadosFilas.set(registroMayor.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: fOperacionExtracto
                                });
                                conciliados++;
                            }
                            
                            // Asignar estados a todos los registros del grupo Extracto
                            for (const registroExtracto of grupoExtracto.registros) {
                                estadosExtracto.set(registroExtracto.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: `FDOC-${fdocMayor}`
                                });
                                conciliados++;
                            }
                            
                            gruposUsadosExtracto.add(fOperacionExtracto);
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: gruposMayor + gruposExtracto,
                    grupos: gruposMayor + gruposExtracto,
                    conciliados: conciliados
                };
            },

            procesarPaso12SBPDirecto(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 SBP.USD - MAPEO DIRECTO POR MONTOS:
                
                ESTRATEGIA SIMPLIFICADA:
                1. Tomar todos los pendientes del Mayor (cualquier DEBE o HABER no cero)
                2. Tomar todos los pendientes del Extracto SBP
                3. Mapear: MONTO Mayor (DEBE o HABER) ↔ |Monto| Extracto SBP
                
                CRITERIO:
                - Coincidencia exacta de montos (tolerancia 0.01)
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada" para ambos registros
                - Mayor: #REF = Referencia del Extracto
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // Console.log para cuenta 1041302
                if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                }
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let conciliados = 0;
                
                // === 1. RECOPILAR PENDIENTES DEL MAYOR ===
                const pendientesMayor = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Tomar el monto no cero (DEBE o HABER)
                    let montoMayor = 0;
                    if (debe !== 0) montoMayor = debe;
                    else if (haber !== 0) montoMayor = haber;
                    
                    if (montoMayor !== 0) {
                        candidatosMayor++;
                        
                        pendientesMayor.push({
                        indice: i,
                            fila: filaMayor,
                            monto: montoMayor,
                            comprob: comprob,
                            libro: libro,
                            tipo: debe !== 0 ? 'DEBE' : 'HABER'
                        });
                        
                        // Log específico para cuenta 1041302
                        if (cuentaConfig && cuentaConfig.codigo === '1041302' && candidatosMayor <= 5) {
                            // Se registrará en grupos mayor
                        }
                    }
                }
                
                // Console.log para grupos mayor - cuenta 1041302
                if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                }
                
                if (candidatosMayor === 0) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. RECOPILAR PENDIENTES DEL EXTRACTO ===
                const pendientesExtracto = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Usar indicesExtracto para obtener los datos correctos
                    const importe = filaExtracto[idxE.monto] || '0';
                    const referencia = filaExtracto[idxE.operacion] || '';
                    const fecha = filaExtracto[idxE.fecha] || '';
                    

                    
                    const montoOriginal = this.normalizarMonto(importe);
                    const montoAbsoluto = Math.abs(montoOriginal);
                    
                    if (montoAbsoluto !== 0) {
                        candidatosExtracto++;
                        
                        pendientesExtracto.push({
                            indice: i,
                            fila: filaExtracto,
                            montoOriginal: montoOriginal,
                            montoAbsoluto: montoAbsoluto,
                            referencia: referencia
                        });
                        
                        if (candidatosExtracto <= 5) {
                        }
                    }
                }
                
                // Console.log para grupos extracto - cuenta 1041302
                if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                }
                
                if (candidatosExtracto === 0) {
                    return { candidatos: candidatosMayor, grupos: 0, conciliados: 0 };
                }
                
                // === 3. MAPEO DIRECTO POR MONTOS ===
                
                const usadosExtracto = new Set();
                
                for (const pendienteMayor of pendientesMayor) {
                    const montoMayor = pendienteMayor.monto;
                    
                    // Buscar coincidencia en extracto
                    for (const pendienteExtracto of pendientesExtracto) {
                        if (usadosExtracto.has(pendienteExtracto.indice)) continue;
                        
                        const montoExtracto = pendienteExtracto.montoAbsoluto;
                        const diferencia = Math.abs(montoMayor - montoExtracto);
                        
                        if (diferencia < 0.01) { // Tolerancia de 1 centavo
                            // Console.log para conciliación por fecha - cuenta 1041302
                            if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                            }
                            
                            // CONCILIACIÓN DIRECTA EXITOSA
                            const refMayor = pendienteExtracto.referencia || 'SBP-DIRECTO';
                            const refExtracto = `${pendienteMayor.libro}-${pendienteMayor.comprob}` || 'MAYOR-DIRECTO';
                            

                            
                            // Asignar estados
                            estadosFilas.set(pendienteMayor.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: refMayor
                                });
                                
                            estadosExtracto.set(pendienteExtracto.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: refExtracto
                                });
                                
                            usadosExtracto.add(pendienteExtracto.indice);
                            conciliados += 2;
                            
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    grupos: 0, // No usamos grupos en la versión simplificada
                    conciliados: conciliados
                };
            },

            // Métodos placeholder para futuras implementaciones específicas
            procesarAnulacionesBCP02(data) {
                // TODO: Implementar lógica específica BCP.02
                return { estado: 'Pendiente', ref: '' };
            },
            
            procesarDepositosBCP02(data) {
                // TODO: Implementar lógica específica BCP.02
                return { conciliados: 0 };
            },
            
            procesarAnulacionesSantander(data) {
                // TODO: Implementar lógica específica Santander
                return { estado: 'Pendiente', ref: '' };
            },

            procesarAnulacionesIBK(data) {
                // TODO: Implementar lógica específica IBK para anulaciones
                return { estado: 'Pendiente', ref: '' };
            },

            procesarPaso4IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 4 IBK - OPERACIONES BNA (DOS ETAPAS COMO OTROS BANCOS):
                
                ETAPA 1 - MAPEO EXTRACTO IBK vs MAYOR:
                CRITERIOS EXTRACTO:
                1. CRITERIO 1: Movimiento (Col E orig) = "FINANC. DE DOCS" Y Cargo (Col H orig) = "-8"
                   → Importe = Cargo + Abono = (-8) + 0 = -8 (negativo)
                   
                2. CRITERIO 2: Descripción (Col F orig) = "FCD ABON.CTA" 
                   → Importe = Cargo + Abono = 0 + (+monto) = +monto (positivo)
                   
                3. Agrupar por Fecha de operación (Col B orig) del mismo día
                4. Para cada fila del grupo: Cargo + Abono, luego sumar todo el grupo
                
                CRITERIOS MAYOR:
                - DES_TDOP="Bna" + LIBRO="04" + DEBE > 0
                - Agrupar por FDOC, sumar DEBE
                
                MAPEO: FDOC + DEBE (Mayor) vs Fecha + Total Grupo (Extracto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09):
                CRITERIOS:
                - Candidatos: LIBRO="04" + DEBE > 0 (pendientes de Etapa 1)
                - Destinos: LIBRO="09" + HABER > 0 
                - Mapeo: Mismo FDOC + DEBE = HABER (coincidencia exacta)
                
                ESTADOS RESULTANTES:
                - Etapa 1: "P4 - Conciliada", Extracto→Mayor, Mayor→Extracto  
                - Etapa 2: "P4 - Conciliada", L04→"09-COMPROB", L09→"04-COMPROB"
                
                ESTRUCTURA IBK ORIGINAL (extractoProcesable):
                A=vacío, B=Fecha operación, C=Fecha proceso, D=Nro operación, E=Movimiento, 
                F=Descripción, G=Canal, H=Cargo, I=Abono, J=Saldo contable
                
                ESTRUCTURA IBK REORGANIZADA (pestaña):
                A=Fecha operación, B=Fecha proceso, C=Nro operación, D=Movimiento, 
                E=Descripción, F=Canal, G=Cargo, H=Abono, I=Saldo, J=ESTADO, K=#REF
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { conciliados: 0 };
                }
                
                // PASO 1: Buscar TODOS los registros candidatos del grupo IBK
                const candidatosGrupoIBK = [];
                
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const item = extractoProcesable[i];
                    const fila = item.fila;
                    if (!fila || !Array.isArray(fila)) continue;
                    
                    // IBK estructura ORIGINAL: usar mapeo dinámico de índices
                    const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                    const fechaOperacion = fila[indicesIBK.fechaOperacion] || '';     // Fecha operación
                    const fechaProceso = fila[indicesIBK.fechaProceso] || '';       // Fecha proceso
                    const nroOperacion = fila[indicesIBK.nroOperacion] || '';       // Nro operación
                    const movimiento = (fila[indicesIBK.movimiento] || '').toString();  // Movimiento
                    const descripcion = (fila[indicesIBK.descripcion] || '').toString(); // Descripción
                    const canal = fila[indicesIBK.canal] || '';              // Canal
                    const cargo = (fila[indicesIBK.cargo] || '').toString();       // Cargo
                    const abono = fila[indicesIBK.abono] || '';              // Abono
                    const saldoContable = fila[indicesIBK.saldoContable] || '';      // Saldo contable
                    
                    if (i < 3) {
                    }
                    
                    let esCandidata = false;
                    let tipoRegistro = '';
                    
                    // Criterio 1: FINANC. DE DOCS en MOVIMIENTO (col D) Y cargo -8 (col G)
                    if (movimiento.trim() === 'FINANC. DE DOCS' && cargo && cargo.trim() === '-8') {
                        esCandidata = true;
                        tipoRegistro = 'FINANC_DOCS';
                    }
                    
                    // Criterio 2: FCD ABON.CTA en DESCRIPCIÓN (col E)
                    if (descripcion.trim() === 'FCD ABON.CTA') {
                        esCandidata = true;
                        tipoRegistro = 'FCD_ABON';
                    }
                    
                    if (esCandidata) {
                        const cargoNumerico = this.normalizarMonto(cargo || '0');
                        const abonoNumerico = this.normalizarMonto(abono || '0');
                        const importeFila = cargoNumerico + abonoNumerico; // Cargo + Abono para esta fila
                        
                        candidatosGrupoIBK.push({
                            tipo: tipoRegistro,
                            indice: i,
                            fechaOperacion: fechaOperacion,
                            fechaProceso: fechaProceso,
                            nroOperacion: nroOperacion,
                            movimiento: movimiento,
                            descripcion: descripcion,
                            canal: canal,
                            cargo: cargo,
                            cargoNumerico: cargoNumerico,
                            abono: abono,
                            abonoNumerico: abonoNumerico,
                            importeFila: importeFila, // Cargo + Abono
                            saldoContable: saldoContable,
                            fila: fila
                        });
                        
                    }
                }
                
                
                // PASO 2: Agrupar por fecha y calcular suma de importes (Cargo + Abono)
                const gruposPorFecha = new Map();
                
                
                candidatosGrupoIBK.forEach((candidato, idx) => {
                    const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
                    
                    
                    if (!fechaNormalizada || fechaNormalizada === '') {
                        return; // Skip este candidato
                    }
                    
                    if (!gruposPorFecha.has(fechaNormalizada)) {
                        gruposPorFecha.set(fechaNormalizada, {
                            fecha: fechaNormalizada,
                            fechaOriginal: candidato.fechaOperacion,
                            registros: [],
                            financDocs: [],
                            fcdAbon: [],
                            totalImporteGrupo: 0 // Suma de todos los importeFila del grupo
                        });
                    }
                    
                    const grupo = gruposPorFecha.get(fechaNormalizada);
                    grupo.registros.push(candidato);
                    grupo.totalImporteGrupo += candidato.importeFila; // Sumar Cargo + Abono de esta fila
                    
                    
                    if (candidato.tipo === 'FINANC_DOCS') {
                        grupo.financDocs.push(candidato);
                    } else if (candidato.tipo === 'FCD_ABON') {
                        grupo.fcdAbon.push(candidato);
                    }
                });
                
                
                // PASO 3: Formar grupos del MAYOR (IGUAL QUE OTRAS CUENTAS: DES_TDOP="Bna" + LIBRO="04")
                
                const gruposMayorPorFecha = new Map();
                let candidatosMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    if (!filaMayor || !Array.isArray(filaMayor)) continue;
                    
                    // USAR ÍNDICES ESTÁNDAR COMO OTRAS CUENTAS
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    
                    // FILTRO MAYOR IBK ESTÁNDAR: DES_TDOP="Bna" Y LIBRO="04" (igual que BCP/SANT)
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && String(libro || '').trim() === '04') {
                        candidatosMayor++;
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const importeMayor = debe; // Para IBK usar DEBE como importe principal (corregido)
                        
                        if (candidatosMayor <= 5) {
                        }
                        
                        if (!fechaNormalizada || fechaNormalizada === '') {
                            continue;
                        }
                        
                        if (!gruposMayorPorFecha.has(fechaNormalizada)) {
                            gruposMayorPorFecha.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                registros: [],
                                totalImporteMayor: 0
                            });
                        }
                        
                        const grupoMayor = gruposMayorPorFecha.get(fechaNormalizada);
                        grupoMayor.registros.push({
                            indice: i,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            importeMayor: importeMayor,
                            fila: filaMayor
                        });
                        grupoMayor.totalImporteMayor += importeMayor;
                    }
                }
                
                
                // PASO 4: Comparar grupos Extracto vs Mayor
                
                let conciliados = 0;
                const tolerancia = 0.01; // Tolerancia para diferencias de centavos
                
                gruposPorFecha.forEach((grupoExtracto, fechaExtracto) => {
                    const grupoMayor = gruposMayorPorFecha.get(fechaExtracto);
                    
                    
                    if (grupoMayor) {
                        
                        const diferencia = Math.abs(grupoExtracto.totalImporteGrupo - grupoMayor.totalImporteMayor);
                        
                        if (diferencia <= tolerancia) {
                            
                            // Marcar registros de extracto como conciliados
                            grupoExtracto.registros.forEach(regExtracto => {
                                estadosExtracto.set(regExtracto.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: `IBK-${fechaExtracto}`
                                });
                            });
                            
                            // Marcar registros de mayor como conciliados
                            grupoMayor.registros.forEach(regMayor => {
                                estadosFilas.set(regMayor.indice, {
                                    estado: 'P4 - Conciliada', 
                                    ref: `IBK-${fechaExtracto}`
                                });
                            });
                            
                            conciliados++;
                        } else {
                        }
                    } else {
                    }
                });
                
                const totalFinancDocs = candidatosGrupoIBK.filter(c => c.tipo === 'FINANC_DOCS').length;
                const totalFcdAbon = candidatosGrupoIBK.filter(c => c.tipo === 'FCD_ABON').length;
                
                
                gruposPorFecha.forEach((grupo, fecha) => {
                    
                    // Mostrar detalles de registros
                    if (grupo.financDocs.length > 0) {
                        grupo.financDocs.slice(0, 4).forEach((item, idx) => {
                        });
                    }
                    
                    if (grupo.fcdAbon.length > 0) {
                        grupo.fcdAbon.slice(0, 4).forEach((item, idx) => {
                        });
                    }
                });
                
                // TABLA COMPARATIVA FINAL
                
                // Crear lista de todas las fechas únicas
                const todasLasFechas = new Set([...gruposPorFecha.keys(), ...gruposMayorPorFecha.keys()]);
                
                todasLasFechas.forEach(fecha => {
                    const grupoExtracto = gruposPorFecha.get(fecha);
                    const grupoMayor = gruposMayorPorFecha.get(fecha);
                    
                    const totalExtracto = grupoExtracto ? grupoExtracto.totalImporteGrupo : 0;
                    const totalMayor = grupoMayor ? grupoMayor.totalImporteMayor : 0;
                    const cantExtracto = grupoExtracto ? grupoExtracto.registros.length : 0;
                    const cantMayor = grupoMayor ? grupoMayor.registros.length : 0;
                    const diferencia = Math.abs(totalExtracto - totalMayor);
                    
                    let estado = '';
                    if (!grupoExtracto && !grupoMayor) {
                        estado = 'Sin datos';
                    } else if (!grupoExtracto) {
                        estado = 'Solo Mayor';
                    } else if (!grupoMayor) {
                        estado = 'Solo Extracto';
                    } else if (diferencia <= 0.01) {
                        estado = '✅ CONCILIADO';
                    } else {
                        estado = '❌ Diferencia';
                    }
                    
                    const fechaCorta = fecha.substring(5); // MM-DD
                    const extractoStr = grupoExtracto ? `${totalExtracto.toFixed(2)}(${cantExtracto})` : 'N/A';
                    const mayorStr = grupoMayor ? `${totalMayor.toFixed(2)}(${cantMayor})` : 'N/A';
                    const difStr = diferencia > 0 ? diferencia.toFixed(2) : '0.00';
                    
                });
                
                // =======================================================
                // ETAPA 2: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliadosInternos = 0;
                
                // Buscar filas pendientes con LIBRO="04"
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    
                    // Solo filas con LIBRO="04" y DEBE > 0
                    if (String(libro || '').trim() === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        if (candidatosLibro04 <= 3) {
                        }
                        
                        // Buscar coincidencia en LIBRO="09" con HABER similar
                        for (let j = 0; j < filasFiltradasMayor.length; j++) {
                            if (i === j || estadosFilas.has(j)) continue;
                            
                            const otraFila = filasFiltradasMayor[j];
                            const otroLibro = otraFila[idxM.libro] || '';
                            const otroHaber = this.normalizarMonto(otraFila[idxM.haber] || '0');
                            const otroComprob = otraFila[idxM.comprob] || '';
                            const otroFdoc = otraFila[idxM.fdoc] || '';
                            
                            if (String(otroLibro || '').trim() === '09' && otroHaber > 0) {
                                candidatosLibro09++;
                                
                                // Verificar coincidencia de montos (exacto) y misma fecha
                                const diferencia = Math.abs(debe - otroHaber);
                                const mismoDia = this.normalizarFecha(fdoc) === this.normalizarFecha(otroFdoc);
                                const coincide = diferencia === 0 && mismoDia;
                                
                                if (candidatosLibro04 <= 3 && candidatosLibro09 <= 6) {
                                }
                                
                                if (coincide) {
                                    // Asignar estados a ambas filas
                                    estadosFilas.set(i, {
                                        estado: 'P4 - Conciliada',
                                        ref: `09-${otroComprob}`
                                    });
                                    
                                    estadosFilas.set(j, {
                                        estado: 'P4 - Conciliada', 
                                        ref: `04-${comprob}`
                                    });
                                    
                                    conciliadosInternos++;
                                    
                                    
                                    // Salir del bucle interno ya que encontramos el match
                                    break;
                                }
                            }
                        }
                    }
                }
                
                
                // ACTUALIZAR TABLA COMPARATIVA PARA INCLUIR ETAPA 2
                const totalConciliados = conciliados + conciliadosInternos;
                
                
                return { 
                    conciliados: totalConciliados, // Cantidad real total de conciliaciones
                    etapa1: conciliados, // Conciliaciones extracto vs mayor
                    etapa2: conciliadosInternos, // Conciliaciones internas mayor
                    gruposExtracto: gruposPorFecha,
                    gruposMayor: gruposMayorPorFecha,
                    totalCandidatos: candidatosGrupoIBK.length,
                    candidatosFinancDocs: totalFinancDocs,
                    candidatosFcdAbon: totalFcdAbon
                };
            },

            procesarPaso5IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 5 IBK - OPERACIONES FINANC. DE DOCS -78:
                
                CRITERIOS EXTRACTO IBK:
                1. Movimiento (Col E orig) = "FINANC. DE DOCS" 
                2. Cargo (Col H orig) = "-78.00" (específico para P5)
                3. Agrupar por Fecha de operación (Col B orig)
                4. Importe = |Cargo| = |-78.00| = 78.00 (valor absoluto)
                
                CRITERIOS MAYOR (ESTÁNDAR):
                - LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                - LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                - Agrupar por FDOC, sumar HABER
                
                MAPEO: FDOC + HABER (Mayor) vs Fecha + |Cargo| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                - Mayor → REF extracto, Extracto → REF "LIBRO-COMPROB"
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                
                // ETAPA 1: Buscar candidatos EXTRACTO IBK (FINANC. DE DOCS + Cargo -78)
                const candidatosExtractoIBK = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const item = extractoProcesable[i];
                    const fila = item.fila;
                    if (!fila || !Array.isArray(fila)) continue;
                    
                    // IBK estructura ORIGINAL: usar mapeo dinámico de índices
                    const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                    const fechaOperacion = fila[indicesIBK.fechaOperacion] || '';         // Fecha operación
                    const movimiento = (fila[indicesIBK.movimiento] || '').toString(); // Movimiento
                    const cargo = (fila[indicesIBK.cargo] || '').toString();      // Cargo
                    
                    // CRITERIO IBK P5: FINANC. DE DOCS con cargo -78
                    if (movimiento.trim() === 'FINANC. DE DOCS' && cargo.trim() === '-78') {
                        const cargoNumerico = this.normalizarMonto(cargo);
                        const importeAbsoluto = Math.abs(cargoNumerico); // |-78| = 78
                        
                        candidatosExtractoIBK.push({
                            indice: i,
                            fechaOperacion: fechaOperacion,
                            movimiento: movimiento,
                            cargo: cargo,
                            cargoNumerico: cargoNumerico,
                            importeAbsoluto: importeAbsoluto,
                            fila: fila
                        });
                        
                        if (candidatosExtractoIBK.length <= 5) {
                        }
                    }
                }
                
                // ETAPA 2: Agrupar extracto IBK por fecha
                const gruposExtractoPorFecha = new Map();
                
                candidatosExtractoIBK.forEach(candidato => {
                    const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
                    
                    if (!fechaNormalizada || fechaNormalizada === '') {
                        return;
                    }
                    
                    if (!gruposExtractoPorFecha.has(fechaNormalizada)) {
                        gruposExtractoPorFecha.set(fechaNormalizada, {
                            fecha: fechaNormalizada,
                            fechaOriginal: candidato.fechaOperacion,
                            registros: [],
                            totalImporte: 0
                        });
                    }
                    
                    const grupo = gruposExtractoPorFecha.get(fechaNormalizada);
                    grupo.registros.push(candidato);
                    grupo.totalImporte += candidato.importeAbsoluto; // Sumar |cargo|
                });
                
                
                // ETAPA 3: Formar grupos del MAYOR (ESTÁNDAR: PROT + DEV)
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                const gruposMayorPorFecha = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Criterios estándar P5: PROT (L04) + DEV (L03/L09)
                    const esPROT = String(libro || '').trim() === '04' && (glosa.startsWith('PROT') || glosa.includes('PROT'));
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && (glosa.startsWith('DEV') || glosa.includes('DEV'));
                    
                    if ((esPROT || esDEV) && haber > 0) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        
                        if (candidatosPROT + candidatosDEV <= 5) {
                        }
                        
                        if (!fechaNormalizada || fechaNormalizada === '') {
                            continue;
                        }
                        
                        if (!gruposMayorPorFecha.has(fechaNormalizada)) {
                            gruposMayorPorFecha.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                registros: [],
                                totalHaber: 0
                            });
                        }
                        
                        const grupo = gruposMayorPorFecha.get(fechaNormalizada);
                        grupo.registros.push({
                            indice: i,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob,
                            fila: filaMayor
                        });
                        grupo.totalHaber += haber;
                    }
                }
                
                
                // ETAPA 4: Comparar y conciliar grupos
                
                let conciliados = 0;
                const tolerancia = 0.01;
                
                gruposExtractoPorFecha.forEach((grupoExtracto, fechaExtracto) => {
                    const grupoMayor = gruposMayorPorFecha.get(fechaExtracto);
                    
                    
                    if (grupoMayor) {
                        
                        const diferencia = Math.abs(grupoExtracto.totalImporte - grupoMayor.totalHaber);
                        
                        if (diferencia <= tolerancia) {
                            
                            // Marcar registros de extracto como conciliados
                            grupoExtracto.registros.forEach(regExtracto => {
                                estadosExtracto.set(regExtracto.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: `P5-${fechaExtracto}`
                                });
                            });
                            
                            // Marcar registros de mayor como conciliados
                            grupoMayor.registros.forEach(regMayor => {
                                estadosFilas.set(regMayor.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: `IBK-P5-${fechaExtracto}`
                                });
                            });
                            
                            conciliados++;
                        } else {
                        }
                    } else {
                    }
                });
                
                
                return {
                    candidatos: candidatosExtractoIBK.length + candidatosPROT + candidatosDEV,
                    grupos: Math.max(gruposExtractoPorFecha.size, gruposMayorPorFecha.size),
                    conciliados: conciliados
                };
            },

            procesarPaso6IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 6 IBK - DEPÓSITOS BANCARIOS:
                
                CRITERIOS MAYOR (IGUAL QUE BCP):
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                DIFERENCIA IBK: 
                - Extracto usa columna ABONO (usando mapeo dinámico de índices) en lugar de MONTO estándar
                - En pestaña IBK: ABONO aparece en columna H pero el procesamiento usa el extracto original
                
                ETAPA 6A - Mapeo por NUMDOC:
                1. NUMDOC (Mayor) ↔ Operación - Número (Extracto usando mapeo dinámico)
                
                ETAPA 6B - Mapeo por FDOC+DEBE:
                2. FDOC + DEBE (Mayor) ↔ FECHA + ABONO (Extracto IBK usando mapeo dinámico)
                3. Validación: DEBE (Mayor) vs ABONO (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada"
                - Mayor: #REF = [Operación - Número del Extracto]  
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                
                let candidatosDepositos = 0;
                let conciliadosEtapa6A = 0;
                let conciliadosEtapa6B = 0;
                
                // ETAPA 1: Identificar candidatos MAYOR (LIBRO="01" + INICIA CON DEPOSITO BANCARIO)
                const candidatosPaso6 = [];
                
                //console.log(`🔍 [IBK PASO 6] Buscando depósitos bancarios para ${cuentaConfig.alias}`);
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // if (candidatosDepositos <= 5) {
                        // }
                    }
                }
                
                
                if (candidatosDepositos === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // ETAPA 6A: MAPEO POR NUMDOC vs OPERACIÓN-NÚMERO
                
                for (const candidato of candidatosPaso6) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar coincidencia por NUMDOC en extracto
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        const operacionNumero = this.normalizarTexto(filaExtracto[indicesIBK.nroOperacion] || '');
                        
                        if (candidato.numdoc && operacionNumero && candidato.numdoc === operacionNumero) {
                            // Conciliar por NUMDOC
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: operacionNumero
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliadosEtapa6A++;
                            break;
                        }
                    }
                }
                
                // ETAPA 6B: MAPEO POR FDOC+DEBE vs FECHA+ABONO
                
                for (const candidato of candidatosPaso6) {
                    if (estadosFilas.has(candidato.indice)) continue; // Ya conciliado en 6A
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    // Buscar coincidencia por FDOC+DEBE vs FECHA+ABONO
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura original: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        const fechaExtracto = filaExtracto[indicesIBK.fechaOperacion] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[indicesIBK.abono] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            const operacionNumero = filaExtracto[3] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: operacionNumero || `P6B-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada', 
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliadosEtapa6B++;
                            break;
                        }
                    }
                }
                
                const totalConciliados = conciliadosEtapa6A + conciliadosEtapa6B;
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: totalConciliados,
                    etapa6A: conciliadosEtapa6A,
                    etapa6B: conciliadosEtapa6B
                };
            },

            procesarPaso6DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 DET - DEPÓSITOS BANCARIOS:
                
                CRITERIOS MAYOR:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                MAPEO DET:
                - Mayor: FDOC + DEBE
                - Extracto DET: Fecha (columna B, índice 1) + Abono (columna H, índice 7)
                - Formato fecha: aaaa.mm.dd
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                
                let candidatosDepositos = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                    }
                }
                
                
                if (candidatosDepositos === 0) {
                    // for (let i = 0; i < Math.min(3, filasFiltradasMayor.length); i++) {
                    //     const fila = filasFiltradasMayor[i];
                    //     const libro = fila[idxM.libro] || '';
                    //     const glosa = (fila[idxM.glosa] || '').toString().toUpperCase();
                    // }
                }
                
                // MAPEO: FDOC+DEBE vs FECHA+ABONO
                for (const candidato of candidatosPaso6) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // DET estructura: B=Fecha(1), H=Abono(7)
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[7] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        // if (j < 3) {
                        // }
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        // if (j < 5 || fechaCoincide || montoCoincide) {
                        // }
                        
                        if (fechaCoincide && montoCoincide) {
                            const nroOperacion = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: nroOperacion || `P6-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: conciliados
                };
            },

            procesarPaso8DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 DET - OPERACIONES MÚLTIPLES LIBROS:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                
                MAPEO DET:
                - Mayor: FDOC + HABER
                - Extracto DET: Fecha (columna B, índice 1) + Cargo (columna G, índice 6)
                - Formato fecha: aaaa.mm.dd
                - Cargo puede estar en letras, convertir a número
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para registros mapeados
                */
                
                
                let candidatosEncontrados = 0;
                let conciliados = 0;
                
                // Libros objetivo para PASO 8
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Identificar candidatos LIBRO = 03, 09, 14, 15 + ESTADO = Pendiente
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    if (librosObjetivo.includes(String(libro || '').trim())) {
                        candidatosEncontrados++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                
                if (candidatosEncontrados === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+HABER vs FECHA+ABONO
                for (const candidato of candidatosPaso8) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // DET estructura: B=Fecha(1), G=Cargo(6) 
                        const fechaExtracto = filaExtracto[1] || '';
                        const cargoRaw = filaExtracto[6] || '';
                        
                        // Normalizar cargo (puede estar en letras)
                        const cargoExtracto = this.normalizarMonto(cargoRaw);
                        const cargoAbsoluto = Math.abs(cargoExtracto);
                        
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.haber - cargoAbsoluto) < 0.01;
                        
                        if (j < 5 || fechaCoincide || montoCoincide) {
                        }
                        
                        if (fechaCoincide && montoCoincide) {
                            const nroOperacion = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P8 - Conciliada',
                                ref: nroOperacion || `P8-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P8 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosEncontrados,
                    conciliados: conciliados
                };
            },

            procesarPaso11BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 BN - ITF ESPECÍFICO:
                
                CRITERIOS MAYOR:
                - LIBRO = "09"
                - GLOSA contiene "ITF"
                - HABER > 0
                - ESTADO = "Pendiente"
                
                CRITERIOS EXTRACTO BN:
                - Trans contiene "IMPT.ITF" (asumir columna C, índice 2)
                - Usar valor absoluto de Cargo (columna F, índice 5)
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |CARGO| (Extracto BN)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada" para todos los registros si totales coinciden
                */
                
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                const candidatosMayor = [];
                let totalHaberMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    
                    // Criterios: LIBRO = "09" + GLOSA contiene "ITF" + HABER > 0
                    const esLibro09 = String(libro || '').trim() === '09';
                    const contieneITF = glosa.includes('ITF');
                    const tieneHaber = haber > 0;
                    
                    if (esLibro09 && contieneITF && tieneHaber) {
                        candidatosMayorITF++;
                        totalHaberMayor += haber;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            fdoc: fdoc,
                            comprob: comprob
                        });
                    }
                }
                
                
                if (candidatosMayorITF === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "IMPT.ITF" EN EXTRACTO BN ===
                const candidatosExtracto = [];
                let totalCargoExtracto = 0;
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // BN estructura: C=Trans(2), F=Cargo(5)
                    const trans = (filaExtracto[2] || '').toString().toUpperCase();
                    const cargoRaw = filaExtracto[5] || '';
                    const cargoExtracto = this.normalizarMonto(cargoRaw);
                    const cargoAbsoluto = Math.abs(cargoExtracto);
                    
                    // Criterio: Trans contiene "IMPT.ITF"
                    const esImpuestoITF = trans.includes('IMPT.ITF') || trans.includes('IMPUESTO ITF') || trans.includes('ITF');
                    
                    if (esImpuestoITF && cargoAbsoluto > 0) {
                        candidatosExtractoITF++;
                        totalCargoExtracto += cargoAbsoluto;
                        
                        const fecha = filaExtracto[1] || '';
                        const nroOperacion = filaExtracto[0] || '';
                        
                        
                        candidatosExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            trans: trans,
                            cargo: cargoAbsoluto,
                            fecha: fecha,
                            nroOperacion: nroOperacion
                        });
                    }
                }
                
                
                if (candidatosExtractoITF === 0) {
                    return { candidatos: candidatosMayorITF, conciliados: 0 };
                }
                
                // === 3. COMPARAR TOTALES ===
                
                const diferenciaTotales = Math.abs(totalHaberMayor - totalCargoExtracto);
                const totalesCoinciden = diferenciaTotales < 0.01;
                
                
                if (totalesCoinciden) {
                    // === 4. CONCILIAR TODOS LOS REGISTROS ===
                    
                    const primeraRefExtracto = candidatosExtracto.length > 0 ? candidatosExtracto[0].nroOperacion : '';
                    const primeraRefMayor = candidatosMayor.length > 0 ? `${candidatosMayor[0].libro}-${candidatosMayor[0].comprob}` : '';
                    
                    // Conciliar todos los registros Mayor ITF
                    for (const candidato of candidatosMayor) {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefExtracto || `P11-ITF-${candidato.fdoc}`
                        });
                        conciliados++;
                    }
                    
                    // Conciliar todos los registros Extracto ITF
                    for (const candidato of candidatosExtracto) {
                        estadosExtracto.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefMayor || 'P11-ITF-BN'
                        });
                    }
                    
                } else {
                }
                
                
                return {
                    candidatos: candidatosMayorITF + candidatosExtractoITF,
                    conciliados: conciliados
                };
            },

            procesarPaso6BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 BN - DEPÓSITOS BANCARIOS:
                
                CRITERIOS MAYOR:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                MAPEO BN:
                - Mayor: FDOC + DEBE
                - Extracto BN: Fecha (columna B, índice 1) + Abono (columna G, índice 6)
                - Formato fecha: aaaa.mm.dd
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                
                let candidatosDepositos = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                    }
                }
                
                
                // MAPEO: FDOC+DEBE vs FECHA+ABONO
                for (const candidato of candidatosPaso6) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // BN estructura: B=Fecha(1), G=Abono(6)
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[6] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        if (j < 3) {
                        }
                        
                        if (fechaCoincide && montoCoincide) {
                            const refExtracto = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: refExtracto || `P6-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: conciliados
                };
            },

            procesarPaso7IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 7 IBK - OPERACIONES LIBRO 3:
                
                CRITERIOS MAYOR:
                - LIBRO = "03"
                - DEBE > 0 (solo registros con debe)
                - HABER = 0 (sin haber)
                - ESTADO = "Pendiente"
                
                DIFERENCIA IBK:
                - Extracto usa columna ABONO (usando mapeo dinámico de índices) en lugar de MONTO estándar
                - En pestaña IBK: ABONO aparece en columna H pero el procesamiento usa el extracto original
                
                MAPEO ÚNICO:
                - FDOC + DEBE (Mayor) ↔ FECHA + |ABONO| (Extracto IBK usando mapeo dinámico)
                - Validación: DEBE (Mayor) vs |ABONO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada"
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                
                let candidatosLibro3 = 0;
                let conciliados = 0;
                
                // ETAPA 1: Identificar candidatos MAYOR (LIBRO="03" con DEBE > 0 y HABER = 0)
                const candidatosPaso7 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    const esLibro03 = String(libro || '').trim() === '03';
                    
                    if (esLibro03) {
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        // Solo conciliar registros con DEBE > 0 y HABER = 0
                        const tieneDebeSinHaber = debe > 0 && Math.abs(haber) < 0.01;
                        
                        if (tieneDebeSinHaber) {
                            candidatosLibro3++;
                            candidatosPaso7.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                fdoc: fdoc,
                                debe: debe,
                                haber: haber,
                                comprob: comprob
                            });
                            
                            if (candidatosLibro3 <= 5) {
                            }
                        }
                    }
                }
                
                
                if (candidatosLibro3 === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // ETAPA 2: MAPEO FDOC+DEBE vs FECHA+|ABONO|
                
                for (const candidato of candidatosPaso7) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    // Buscar coincidencia en extracto IBK
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura original: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        const fechaExtracto = filaExtracto[indicesIBK.fechaOperacion] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[indicesIBK.abono] || '0');
                        const abonoAbsoluto = Math.abs(abonoExtracto); // |ABONO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoAbsoluto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            const operacionNumero = filaExtracto[3] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P7 - Conciliada',
                                ref: operacionNumero || `P7-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P7 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: candidatosLibro3,
                    conciliados: conciliados
                };
            },

            procesarPaso11IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 11 IBK - ITF ESPECÍFICO:
                
                CRITERIOS MAYOR (ESTÁNDAR):
                - LIBRO = "09"
                - GLOSA contiene "ITF"
                - HABER > 0
                - ESTADO = "Pendiente"
                
                CRITERIOS EXTRACTO IBK (ESPECÍFICO):
                - Movimiento contiene "ITF" (usando mapeo dinámico de índices)
                - Usar valor absoluto de CARGO (usando mapeo dinámico de índices)
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |CARGO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                const candidatosMayor = [];
                let totalHaberMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios: LIBRO=09 + GLOSA contiene ITF + HABER > 0
                    const esLibro09 = String(libro || '').trim() === '09';
                    const contieneITF = glosa.includes('ITF');
                    const tieneHaber = haber > 0;
                    
                    if (esLibro09 && contieneITF && tieneHaber) {
                        candidatosMayorITF++;
                        totalHaberMayor += haber;
                        
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        if (candidatosMayorITF <= 5) {
                        }
                    }
                }
                
                
                if (candidatosMayorITF === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR ITF EN EXTRACTO IBK ===
                const candidatosExtracto = [];
                let totalCargoExtracto = 0;
                
                //console.log(`🔍 [IBK PASO 11] Buscando ITF en extracto para ${cuentaConfig.alias}`);
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // IBK estructura original: usar mapeo dinámico de índices
                    const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                    const movimiento = (filaExtracto[indicesIBK.movimiento] || '').toString().toUpperCase();
                    const cargo = this.normalizarMonto(filaExtracto[indicesIBK.cargo] || '0');
                    const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                    
                    // if (j < 3) {
                    // }
                    
                    // Verificar criterio: Movimiento contiene "ITF"
                    const contieneITF = movimiento.includes('ITF');
                    
                    if (contieneITF && cargoAbsoluto > 0) {
                        candidatosExtractoITF++;
                        totalCargoExtracto += cargoAbsoluto;
                        
                        //console.log(`✅ [IBK PASO 11] ITF encontrado: Movimiento="${movimiento}", Cargo=${cargoAbsoluto}`);
                        
                        candidatosExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            movimiento: movimiento,
                            cargo: cargo,
                            cargoAbsoluto: cargoAbsoluto
                        });
                        
                        if (candidatosExtractoITF <= 5) {
                        }
                    }
                }
                
                
                if (candidatosExtractoITF === 0) {
                    return { candidatos: candidatosMayorITF, conciliados: 0 };
                }
                
                // === 3. COMPARACIÓN Y CONCILIACIÓN ===
                const tolerancia = 0.01;
                const diferencia = Math.abs(totalHaberMayor - totalCargoExtracto);
                
                
                if (diferencia <= tolerancia) {
                    // Conciliar todos los registros ITF
                    const primerComprobMayor = candidatosMayor[0]?.comprob || 'ITF';
                    const primeraRefExtracto = candidatosExtracto[0]?.fila[2] || 'ITF'; // Nro. Operación (C en IBK reorganizada)
                    
                    // Marcar todos los candidatos del Mayor como conciliados
                    for (const candidato of candidatosMayor) {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefExtracto
                        });
                        conciliados++;
                    }
                    
                    // Marcar todos los candidatos del Extracto como conciliados
                    for (const candidato of candidatosExtracto) {
                        estadosExtracto.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `09-${primerComprobMayor}`
                        });
                    }
                    
                } else {
                }
                
                
                return {
                    candidatos: candidatosMayorITF + candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalHaberMayor,
                    totalExtracto: totalCargoExtracto,
                    diferencia: diferencia
                };
            },

            procesarPaso8IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 8 IBK - OPERACIONES MÚLTIPLES LIBROS INDIVIDUALES:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                - HABER > 0 (solo salidas de dinero)
                
                CRITERIOS EXTRACTO IBK:
                - CARGO < 0 (solo cargos/débitos negativos)
                - ESTADO = "Pendiente"
                
                MAPEO INDIVIDUAL:
                - FDOC + HABER (Mayor) ↔ Fecha operación + |CARGO| (Extracto IBK)
                - Mapeo 1:1 sin agrupación
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada"
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Identificar candidatos de múltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        // ⭐ FILTRO IBK PASO 8: Solo registros con HABER > 0 (salidas de dinero)
                        if (haber > 0) {
                            // Contar por libro
                            if (String(libro || '').trim() === '03') candidatosLibro03++;
                            else if (String(libro || '').trim() === '09') candidatosLibro09++;
                            else if (String(libro || '').trim() === '14') candidatosLibro14++;
                            else if (String(libro || '').trim() === '15') candidatosLibro15++;
                            
                            candidatosPaso8.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                fdoc: fdoc,
                                haber: haber,
                                comprob: comprob
                            });
                        }
                    }
                }
                
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                if (totalCandidatos === 0) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // ANÁLISIS DE CANDIDATOS DEL EXTRACTO IBK
                const candidatosExtracto = [];
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    // Para IBK: itemExtracto.fila contiene la estructura original, no reorganizada
                    // Necesitamos reorganizar aquí: slice(1, 10) toma B-J del original
                    const filaOriginal = itemExtracto.fila;
                    if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                    
                    // Reorganizar IBK: B-J del original (índices 1-9) → A-I del reorganizado (índices 0-8)
                    const filaExtracto = filaOriginal.slice(1, 10); // B12-J12 → A1-I1
                    
                    if (j < 3) {
                    }
                    
                    // IBK estructura reorganizada: A=Fecha operación(0), G=Cargo(6)
                    const fechaExtracto = filaExtracto[0] || '';
                    const cargo = this.normalizarMonto(filaExtracto[6] || '0');
                    const cargoAbsoluto = Math.abs(cargo);
                    
                    // Para IBK: incluir TODOS los registros (cargo puede ser 0, positivo o negativo)
                    candidatosExtracto.push({
                        indice: j,
                        fechaOriginal: fechaExtracto,
                        fechaNormalizada: this.normalizarFecha(fechaExtracto),
                        cargoOriginal: cargo,
                        cargoAbsoluto: cargoAbsoluto,
                        operacion: filaExtracto[2] || ''
                    });
                }
                
                
                const fechasMayor = ['2025-06-02', '2025-06-04', '2025-06-05'];
                fechasMayor.forEach(fechaBuscada => {
                    const coincidencias = candidatosExtracto.filter(cand => cand.fechaNormalizada === fechaBuscada);
                    coincidencias.slice(0, 5).forEach((cand, idx) => {
                    });
                });
                
                candidatosExtracto.slice(0, 10).forEach((cand, idx) => {
                });
                if (candidatosExtracto.length > 10) {
                }
                
                // MAPEO: FDOC+HABER vs FECHA+|CARGO|
                
                let intentosMapeo = 0;
                
                for (const candidato of candidatosPaso8) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    if (intentosMapeo < 10) { // Aumentamos límite para ver todos los candidatos
                    }
                    
                    // Buscar coincidencia en extracto IBK
                    let intentosExtracto = 0;
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        // Para IBK: usar estructura ORIGINAL (extractoProcesable mantiene estructura original)
                        const filaOriginal = itemExtracto.fila;
                        if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                        
                        // IBK estructura ORIGINAL: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        const fechaExtracto = filaOriginal[indicesIBK.fechaOperacion] || '';  // Fecha operación
                        const nroOperacion = filaOriginal[indicesIBK.nroOperacion] || '';     // Nro operación  
                        const cargo = this.normalizarMonto(filaOriginal[indicesIBK.cargo] || '0'); // Cargo
                        
                        // ⭐ FILTRO IBK PASO 8: Solo registros con CARGO < 0 (cargos/débitos)
                        if (cargo >= 0) continue; // Saltar registros con cargo positivo o cero
                        
                        const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        if (intentosExtracto < 10) { // Aumentamos límite para ver más candidatos
                        }  
                        if (intentosExtracto < 10) { // Aumentamos límite para debug
                            intentosExtracto++;
                        }
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const tolerancia = 0.01;
                        const diferenciaMonto = Math.abs(candidato.haber - cargoAbsoluto);
                        const montoCoincide = diferenciaMonto < tolerancia;
                        
                        if (fechaCoincide && montoCoincide) {
                            // Para IBK: usar Nro. de operación (columna D = índice 3 original)
                            const refMayor = nroOperacion || `P8-${fechaMayorNormalizada}`;
                            const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P8 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P8 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados++;
                            break; // Salir del bucle extracto para este candidato Mayor (mapeo 1:1)
                        }
                    }
                    
                    intentosMapeo++;
                    // if (intentosMapeo >= 3) break; // Quitamos límite para ver todos los candidatos
                }
                
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 9 IBK - OPERACIONES MÚLTIPLES LIBROS AGRUPADAS:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                - HABER > 0 (solo salidas de dinero)
                - Agrupar por NUMDOC + FECHA → sumar TOTAL HABER
                
                CRITERIOS EXTRACTO IBK:
                - CARGO < 0 (solo cargos/débitos negativos)
                - ESTADO = "Pendiente"
                
                ESTRATEGIA:
                1. Agrupar Mayor por NUMDOC + FECHA → sumar TOTAL HABER (solo HABER > 0)
                2. Mapear: FDOC + TOTAL HABER (Grupo) ↔ Fecha operación + |CARGO| (Extracto IBK)
                3. Solo filas pendientes se incluyen en cada grupo
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada" para todas las filas del grupo
                - Mayor: #REF = [Operación - Número del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['02', '03', '09', '14', '15'];
                
                // Agrupar filas por NUMDOC que cumplan criterios
                const gruposPorNUMDOC = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por NUMDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // ⭐ FILTRO IBK PASO 9: Solo registros con HABER > 0 (igual que Paso 8)
                        if (haber > 0) {
                            // Contar por libro
                            if (String(libro || '').trim() === '03') candidatosLibro03++;
                            else if (String(libro || '').trim() === '09') candidatosLibro09++;
                            else if (String(libro || '').trim() === '14') candidatosLibro14++;
                            else if (String(libro || '').trim() === '15') candidatosLibro15++;
                            
                            // ⭐ AGRUPAR POR NUMDOC + FECHA (evitar mezclar fechas diferentes)
                            const numdocNormalizado = this.normalizarTexto(numdoc);
                            const fechaNormalizada = this.normalizarFecha(fdoc);
                            const claveGrupo = `${numdocNormalizado}_${fechaNormalizada}`; // NUMDOC + FECHA
                            
                            if (!gruposPorNUMDOC.has(claveGrupo)) {
                                gruposPorNUMDOC.set(claveGrupo, {
                                    numdoc: numdocNormalizado,
                                    numdocOriginal: numdoc,
                                    fdoc: fdoc, // Usar FDOC del primer registro para mapeo
                                    fechaNormalizada: fechaNormalizada,
                                    totalHaber: 0,
                                    filas: []
                                });
                            }
                            
                            const grupo = gruposPorNUMDOC.get(claveGrupo);
                            grupo.totalHaber += haber;
                            grupo.filas.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                numdoc: numdoc,
                                fdoc: fdoc,
                                haber: haber,
                                comprob: comprob
                            });
                        }
                    }
                }
                
                gruposFormados = gruposPorNUMDOC.size;
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                
                if (gruposFormados === 0) {
                    return { candidatos: totalCandidatos, grupos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+TOTAL HABER vs FECHA+|CARGO|
                
                for (const [numdoc, grupo] of gruposPorNUMDOC) {
                    // ⭐ FILTRAR SOLO FILAS PENDIENTES del grupo (no saltar todo el grupo)
                    const filasPendientes = grupo.filas.filter(f => !estadosFilas.has(f.indice));
                    if (filasPendientes.length === 0) continue; // Solo continuar si no hay filas pendientes
                    
                    // Recalcular total HABER solo con filas pendientes
                    const totalHaberPendiente = filasPendientes.reduce((sum, f) => sum + f.haber, 0);
                    
                    const fechaMayorNormalizada = this.normalizarFecha(grupo.fdoc);
                    
                    // Buscar coincidencia en extracto IBK
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        // Para IBK: usar estructura ORIGINAL (igual que Paso 8)
                        const filaOriginal = itemExtracto.fila;
                        if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                        
                        // IBK estructura ORIGINAL: usar mapeo dinámico de índices
                        const indicesIBK = this.obtenerMapeoIndicesIBK(cuentaConfig);
                        const fechaExtracto = filaOriginal[indicesIBK.fechaOperacion] || '';  // Fecha operación
                        const nroOperacion = filaOriginal[indicesIBK.nroOperacion] || '';     // Nro operación  
                        const cargo = this.normalizarMonto(filaOriginal[indicesIBK.cargo] || '0'); // Cargo
                        
                        // ⭐ FILTRO IBK PASO 9: Solo registros con CARGO < 0 (igual que Paso 8)
                        if (cargo >= 0) continue; // Saltar registros con cargo positivo o cero
                        
                        const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(totalHaberPendiente - cargoAbsoluto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            // Para IBK: usar Nro. de operación (columna D = índice 3 original)
                            const refMayor = nroOperacion || `P9-${fechaMayorNormalizada}`;
                            const primerComprob = grupo.filas[0]?.comprob || '';
                            const refExtracto = `${grupo.filas[0]?.libro || ''}-${primerComprob}`;
                            
                            // Conciliar solo las filas pendientes del grupo
                            for (const fila of filasPendientes) {
                                estadosFilas.set(fila.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados++;
                            }
                            
                            estadosExtracto.set(j, {
                                estado: 'P9 - Conciliada',
                                ref: refExtracto
                            });
                            
                            break;
                        }
                    }
                }
                
                
                return {
                    candidatos: totalCandidatos,
                    grupos: gruposFormados,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },
     
            async generateTwoExcelFiles(datosCompletos, baseFileName) {
                try {
                    const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
                    
                    // EJECUTAR PRIMERO: generateConciliacionFile para inicializar window.datosHojaTrabajoJSON
                    const conciliacionFileName = `conciliacion_${timestamp}.xlsx`;
                    const urlConciliacion = await this.generateConciliacionFile(datosCompletos, conciliacionFileName);
                    
                    // EJECUTAR SEGUNDO: generateDatosOriginalesFile que usa los datos JSON
                    const datosOriginalesFileName = `resumen_${timestamp}.xlsx`;
                    const urlDatosOriginales = this.generateDatosOriginalesFile(datosCompletos, datosOriginalesFileName);
                    
                    // ⚠️ COMENTADO: Los cheques NO van al OUTPUT CONCILIACIÓN
                    // Van solo al OUTPUT RESUMEN
                    
                    return {
                        datosOriginales: {
                            nombre: datosOriginalesFileName,
                            url: urlDatosOriginales,
                            descripcion: 'Resumen de cuentas bancarias configuradas'
                        },
                        conciliacion: {
                            nombre: conciliacionFileName,
                            url: urlConciliacion,
                            descripcion: 'Resultados de la conciliación bancaria'
                        }
                    };
                } catch (error) {
                    throw error;
                }
            },

            // === FUNCIONES AUXILIARES PARA CONCILIACIÓN BANCARIA ===
            
            obtenerCodigoCuentaPorPestaña(nombrePestaña) {
                // Mapeo de nombres de pestañas a códigos de cuenta
                const mapeo = {
                    'BCP.01': '1041501',
                    'BCP.02': '1041505', 
                    'BCP.USD': '1041502',
                    'SANT': '1041401',
                    'SANT.USD': '1041402',
                    'BBVA': '1041201',
                    'BBVA.USD': '1041202',
                    'SBP': '1041301',
                    'SBP.USD': '1041302',
                    'IBK': '1041101',
                    'IBK.USD': '1041102',
                    'DET': '1042101',
                    'BN': '1041601'
                };
                
                return mapeo[nombrePestaña] || 'DESCONOCIDO';
            },

            // Función para obtener mapeo de índices específico para IBK
            obtenerMapeoIndicesIBK(cuentaConfig) {
                // Validar que cuentaConfig existe y tiene alias
                if (!cuentaConfig || !cuentaConfig.alias) {
                    console.warn('obtenerMapeoIndicesIBK: cuentaConfig inválido', cuentaConfig);
                    // Fallback por defecto (estructura IBK.USD)
                    return {
                        fechaOperacion: 1,
                        fechaProceso: 2,
                        nroOperacion: 3,
                        movimiento: 4,
                        descripcion: 5,
                        canal: 6,
                        cargo: 7,
                        abono: 8,
                        saldoContable: 9
                    };
                }
                //Fecha de proceso	Nro. de operación	Movimiento	Descripción	Canal	Cargo	Abono	Saldo contable	ESTADO	#REF

                if (cuentaConfig.alias === 'IBK') {
                    // IBK.PEN: estructura real según archivo IBK.PEN.062025.xlsx
                    return {
                        fechaOperacion: 0,    // A=Fecha operación
                        fechaProceso: 1,      // B=Fecha proceso
                        nroOperacion: 2,      // C=Nro operación (CORREGIDO)
                        movimiento: 3,        // D=Movimiento
                        descripcion: 4,       // E=Descripción
                        canal: 5,            // F=Canal
                        cargo: 6,            // G=Cargo
                        abono: 7,            // H=Abono
                        saldoContable: 8     // I=Saldo contable
                    };
                } else if (cuentaConfig.alias === 'IBK.USD') {
                    // IBK.USD: estructura con columna vacía al inicio
                    return {
                        fechaOperacion: 1,    // B=Fecha operación (índice 1 porque A está vacía)
                        fechaProceso: 2,      // C=Fecha proceso
                        nroOperacion: 1,      // B=Nro operación (cambiado de D a B)
                        movimiento: 4,       // E=Movimiento
                        descripcion: 5,       // F=Descripción
                        canal: 6,            // G=Canal
                        cargo: 7,            // H=Cargo
                        abono: 8,            // I=Abono
                        saldoContable: 9     // J=Saldo contable
                    };
                }
                // Fallback por defecto (estructura IBK.USD)
                return {
                    fechaOperacion: 1,
                    fechaProceso: 2,
                    nroOperacion: 3,
                    movimiento: 4,
                    descripcion: 5,
                    canal: 6,
                    cargo: 7,
                    abono: 8,
                    saldoContable: 9
                };
            },

            obtenerSaldoBancoPorCuenta(codigoCuenta) {
                // Para cuentas USD, mostrar el valor original sin conversión
                const cuentasUSD = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                
                if (!this.conciliationResult || !this.conciliationResult.saldosExtractos) {
                    return 0;
                }
                
                const saldoExtracto = this.conciliationResult.saldosExtractos.get(codigoCuenta);
                
                if (saldoExtracto === undefined || saldoExtracto === null) {
                    return 0;
                }
                
                // Para todas las cuentas (USD y PEN), mostrar el valor original sin conversión
                return saldoExtracto;
            },

            obtenerSaldoLibrosPorCuenta(codigoCuenta) {
                if (!this.conciliationResult || !this.conciliationResult.saldosLibros) {
                    return 0;
                }
                
                const saldoLibros = this.conciliationResult.saldosLibros.get(codigoCuenta);
                return (saldoLibros !== undefined && saldoLibros !== null) ? saldoLibros : 0;
            },

            formatearFecha(fecha) {
                if (!fecha) return '';
                
                try {
                    // Si ya es una fecha válida en formato dd/mm/aaaa, devolverla tal como está
                    if (typeof fecha === 'string' && /^\d{1,2}\/\d{1,2}\/\d{4}$/.test(fecha)) {
                        return fecha;
                    }
                    
                    // Si es un objeto Date
                    if (fecha instanceof Date) {
                        const dia = fecha.getDate().toString().padStart(2, '0');
                        const mes = (fecha.getMonth() + 1).toString().padStart(2, '0');
                        const año = fecha.getFullYear();
                        return `${dia}/${mes}/${año}`;
                    }
                    
                    // Convertir a número para verificar si es un número de serie de Excel
                    let numeroFecha = null;
                    if (typeof fecha === 'string') {
                        numeroFecha = parseFloat(fecha);
                    } else if (typeof fecha === 'number') {
                        numeroFecha = fecha;
                    }
                    
                    // Si es un número de serie de Excel (entre 1 y 100000 aproximadamente)
                    if (numeroFecha !== null && !isNaN(numeroFecha) && numeroFecha > 1 && numeroFecha < 100000) {
                        // Convertir número de serie de Excel a fecha
                        // Excel cuenta desde 1 de enero de 1900, pero tiene un bug que cuenta 1900 como año bisiesto
                        // Por eso restamos 2 días: 1 por el día base y 1 por el bug del año bisiesto
                        const fechaExcel = new Date(1900, 0, numeroFecha - 1);
                        
                        if (!isNaN(fechaExcel.getTime())) {
                            const dia = fechaExcel.getDate().toString().padStart(2, '0');
                            const mes = (fechaExcel.getMonth() + 1).toString().padStart(2, '0');
                            const año = fechaExcel.getFullYear();
                            return `${dia}/${mes}/${año}`;
                        }
                    }
                    
                    // Si es un string que puede ser parseado como fecha
                    if (typeof fecha === 'string') {
                        const fechaObj = new Date(fecha);
                        if (!isNaN(fechaObj.getTime())) {
                            const dia = fechaObj.getDate().toString().padStart(2, '0');
                            const mes = (fechaObj.getMonth() + 1).toString().padStart(2, '0');
                            const año = fechaObj.getFullYear();
                            return `${dia}/${mes}/${año}`;
                        }
                    }
                    
                    // Si es un número (timestamp en milisegundos)
                    if (typeof fecha === 'number' && fecha > 100000) {
                        const fechaObj = new Date(fecha);
                        if (!isNaN(fechaObj.getTime())) {
                            const dia = fechaObj.getDate().toString().padStart(2, '0');
                            const mes = (fechaObj.getMonth() + 1).toString().padStart(2, '0');
                            const año = fechaObj.getFullYear();
                            return `${dia}/${mes}/${año}`;
                        }
                    }
                    
                    // Si no se puede formatear, devolver string vacío
                    return '';
                } catch (error) {
                    console.warn('Error al formatear fecha:', fecha, error);
                    return '';
                }
            },
            
            // === FUNCIÓN PARA APLICAR FORMATO DE FECHA A COLUMNAS EN EXCEL ===
            aplicarFormatoFecha(worksheet, numFilas, columnaLetra) {
                try {
                    // Formato de fecha Excel: dd/mm/yyyy (formato código 14)
                    const formatoFechaExcel = 'dd/mm/yyyy';
                    
                    for (let fila = 1; fila <= numFilas; fila++) {
                        const celda = columnaLetra + fila;
                        if (worksheet[celda]) {
                            // Aplicar formato de fecha a la celda
                            worksheet[celda].z = formatoFechaExcel;
                        }
                    }
                } catch (error) {
                    console.warn('Error al aplicar formato de fecha:', error);
                }
            },

            // === FUNCIÓN PARA OBTENER DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS DE SALDOS ===
            obtenerDepositosLibrosNoRegistrados(datosCompletos) {
                
                if (!datosCompletos.datosSaldo || !Array.isArray(datosCompletos.datosSaldo)) {
                    return [];
                }
                
                
                const depositos = [];
                const datosSaldo = datosCompletos.datosSaldo;
                
                // for (let i = 0; i < Math.min(5, datosSaldo.length); i++) {
                // }
                
                // Buscar header para identificar columnas
                let headerIndex = -1;
                for (let i = 0; i < datosSaldo.length; i++) {
                    if (Array.isArray(datosSaldo[i])) {
                        const fila = datosSaldo[i];
                        const tieneConcepto = fila.some(celda => celda && celda.toString().toUpperCase().includes('CONCEPTO'));
                        if (tieneConcepto) {
                            headerIndex = i;
                            break;
                        }
                    }
                }

                if (headerIndex === -1) {
                    return [];
                }
                
                const headers = datosSaldo[headerIndex];
                
                // Buscar columnas de manera más robusta
                const conceptoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CONCEPTO'));
                const fdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FDOC'));
                const numdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('NUMDOC'));
                const glosaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('GLOSA'));
                const debeCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('DEBE'));


                if (conceptoCol === -1) {
                    return [];
                }

                // Procesar filas de datos
                let filasRevisadas = 0;
                let depositosEncontrados = 0;
                
                for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                    const fila = datosSaldo[i];
                    if (!Array.isArray(fila)) continue;
                    
                    filasRevisadas++;
                    const concepto = fila[conceptoCol];
                    
                    if (concepto && concepto.toString().toUpperCase().includes('(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS')) {
                        depositosEncontrados++;
                        
                        // Verificar si está pendiente
                        const estado = fila[fila.length - 1]; // Última columna
                        const estadoAnterior = fila[fila.length - 2]; // Penúltima columna
                        
                        
                        // Criterio más flexible para determinar si está pendiente
                        const estaPendiente = !estado || 
                                            estado === '' || 
                                            estado.toString().toUpperCase().includes('PENDIENTE') ||
                                            !estado.toString().toUpperCase().includes('CONCILIADO');
                        
                        
                        if (estaPendiente) {
                            const deposito = {
                                fecha: this.formatearFecha(fila[fdocCol] || ''),
                                ref: fila[numdocCol] || '',
                                glosa: fila[glosaCol] || '',
                                importe: parseFloat(fila[debeCol]) || 0
                            };
                            depositos.push(deposito);
                        } else {
                        }
                    }
                }

                
                return depositos;
            },

            // === FUNCIÓN PARA OBTENER OMITIDOS DEL PASO 2 AGRUPADOS POR TÉRMINO ===
            obtenerOmitidosPaso2(datosCompletos, cuenta) {
                
                // USAR DATOS DEL MAYOR DISPONIBLES EN DATOSCOMPLETOS
                let datosOriginalesMayor = datosCompletos.datosMayor;
                
                if (!datosOriginalesMayor || !Array.isArray(datosOriginalesMayor)) {
                    return {};
                }
                
                const agrupados = {};
                const datosMayor = datosOriginalesMayor; // USAR DATOS ORIGINALES, NO PROCESADOS
                
                // Términos de exclusión del paso 2 (EXACTOS DEL PASO 2)
                const terminosExclusion = ["AMERICAN EXP", "CALIDDA", "DINERS", "MASTER CARD", "MERCADOPAGO", "VISANET"];
                
                // Inicializar totales por término
                terminosExclusion.forEach(termino => {
                    agrupados[termino] = 0;
                });
                
                // Buscar header para identificar columnas
                let headerIndex = -1;
                for (let i = 0; i < datosMayor.length; i++) {
                    if (Array.isArray(datosMayor[i])) {
                        const fila = datosMayor[i];
                        const tieneGlosa = fila.some(celda => celda && celda.toString().toUpperCase().includes('GLOSA'));
                        if (tieneGlosa) {
                            headerIndex = i;
                            break;
                        }
                    }
                }

                if (headerIndex === -1) {
                    return {};
                }
                
                const headers = datosMayor[headerIndex];
                
                // Buscar columnas (igual que el PASO 2 original)
                const glosaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('GLOSA'));
                const debeCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('DEBE'));
                const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA'));
                

                if (glosaCol === -1 || debeCol === -1 || cuentaCol === -1) {
                    return {};
                }

                // OBTENER FILAS DE DATOS (igual que el PASO 2: después del header)
                const dataRowsMayor = datosMayor.slice(headerIndex + 1);

                // PASO 1: FILTRAR POR CUENTA BCP.01 (1041501) - igual que el paso 2 original
                const codigoCuentaEspecifica = '1041501'; // BCP.01
                const filasFiltradasPorCuenta = dataRowsMayor.filter(fila => {
                    if (!Array.isArray(fila)) return false;
                    const cuentaFila = (fila[cuentaCol] || '').toString();
                    return cuentaFila === codigoCuentaEspecifica;
                });
                

                // PASO 2: IDENTIFICAR FILAS QUE SERÍAN OMITIDAS (REPLICAR LÓGICA EXACTA DEL PASO 2)
                let filasOmitidasPorPaso2 = 0;
                let matchesEncontrados = 0;

                filasFiltradasPorCuenta.forEach((fila, idx) => {
                    const glosa = (fila[glosaCol] || '').toString().toUpperCase();
                    
                    // REPLICAR LÓGICA EXACTA DEL PASO 2: some + startsWith
                    const seriaExcluida = terminosExclusion.some(termino => glosa.startsWith(termino.toUpperCase()));
                    
                    if (seriaExcluida) {
                        filasOmitidasPorPaso2++;
                        
                        // Encontrar cuál término específico coincidió
                        terminosExclusion.forEach(termino => {
                            if (glosa.startsWith(termino.toUpperCase())) {
                                const importe = parseFloat(fila[debeCol]) || 0;
                                matchesEncontrados++;
                                
                                agrupados[termino] += importe;
                            }
                        });
                    }
                });
                
                
                // Filtrar solo los términos que tienen monto > 0
                const resultadoFiltrado = {};
                Object.entries(agrupados).forEach(([termino, total]) => {
                    if (total > 0) {
                        resultadoFiltrado[termino] = total;
                    }
                });
                
                
                return resultadoFiltrado;
            },

            // === FUNCIÓN PARA OBTENER PENDIENTES MAYOR DEBE > 0 PARA CUALQUIER CUENTA ===
            obtenerPendientesMayorDebe(datosCompletos, codigoCuenta = '1041501') {
                
                if (!datosCompletos.datosMayor || !Array.isArray(datosCompletos.datosMayor)) {
                    return [];
                }
                
                const pendientes = [];
                const datosMayor = datosCompletos.datosMayor;
                
                
                // Buscar header para identificar columnas
                let headerIndex = -1;
                for (let i = 0; i < datosMayor.length; i++) {
                    if (Array.isArray(datosMayor[i])) {
                        const fila = datosMayor[i];
                        const tieneEstado = fila.some(celda => celda && celda.toString().toUpperCase().includes('ESTADO'));
                        if (tieneEstado) {
                            headerIndex = i;
                            break;
                        }
                    }
                }

                if (headerIndex === -1) {
                    return [];
                }
                
                const headers = datosMayor[headerIndex];
                
                // Buscar columnas
                const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA'));
                const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ESTADO'));
                const glosaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('GLOSA'));
                const fdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FDOC'));
                const numdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('NUMDOC'));
                const debeCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('DEBE'));


                if (cuentaCol === -1 || estadoCol === -1 || debeCol === -1) {
                    return [];
                }

                let filasRevisadas = 0;
                let candidatos = 0;
                let filtradasPorCuenta = 0;
                let pendientesEncontradas = 0;
                
                // Procesar filas de datos
                for (let i = headerIndex + 1; i < datosMayor.length; i++) {
                    const fila = datosMayor[i];
                    if (!Array.isArray(fila)) continue;
                    
                    filasRevisadas++;
                    
                    const cuenta = fila[cuentaCol];
                    const estado = fila[estadoCol];
                    const debe = parseFloat(fila[debeCol]) || 0;
                    
                    // FILTRO 1: SOLO CUENTA ESPECÍFICA
                    if (!cuenta || cuenta.toString().trim() !== codigoCuenta) {
                        continue;
                    }
                    
                    filtradasPorCuenta++;
                    
                    // FILTRO 2: Estado pendiente
                    const estaPendiente = estado && estado.toString().toUpperCase().includes('PENDIENTE');
                    
                    if (estaPendiente) {
                        pendientesEncontradas++;
                    }
                    
                    // FILTRO 3: DEBE > 0
                    if (estaPendiente && debe > 0) {
                        candidatos++;
                        const pendiente = {
                            fecha: this.formatearFecha(fila[fdocCol] || ''),
                            ref: fila[numdocCol] || '',
                            glosa: fila[glosaCol] || '',
                            importe: debe,
                            cuenta: cuenta.toString().trim()
                        };
                        pendientes.push(pendiente);
                    }
                    
                    if (pendientes.length >= 10) {
                        break;
                    }
                }
                
                
                return pendientes;
            },

            // === FUNCIÓN PARA OBTENER CHEQUES NO COBRADOS DE SALDOS ===
            obtenerChequesNoCobrados(datosCompletos, codigoCuenta) {
                //console.log('🔵 [CHEQUES ETAPA 1] Iniciando obtenerChequesNoCobrados para cuenta:', codigoCuenta);
                
                // Usar los datos procesados del OUTPUT SALDO en lugar del input
                let datosSaldo = null;
                
                if (this.outputWorkbook && this.outputWorkbook.Sheets['SALDO']) {
                    //console.log('🔵 [CHEQUES ETAPA 1] Leyendo desde outputWorkbook.Sheets[SALDO]');
                    const saldoSheet = this.outputWorkbook.Sheets['SALDO'];
                    datosSaldo = XLSX.utils.sheet_to_json(saldoSheet, { header: 1, defval: '' });
                } else {
                    //console.log('🔵 [CHEQUES ETAPA 1] Usando datosCompletos.resultado.datosSaldo (fallback)');
                    datosSaldo = datosCompletos?.resultado?.datosSaldo;
                }
                
                /*console.log('🔵 [CHEQUES ETAPA 1] Datos SALDO obtenidos:', {
                    existe: !!datosSaldo,
                    esArray: Array.isArray(datosSaldo),
                    filas: datosSaldo ? datosSaldo.length : 0
                });
                */
                if (!Array.isArray(datosSaldo) || datosSaldo.length === 0) {
                    //console.log('❌ [CHEQUES ETAPA 1] No hay datos SALDO disponibles');
                    return [];
                }
                
                const cheques = [];
                
                // Buscar header para identificar columnas
                let headerIndex = -1;
                for (let i = 0; i < datosSaldo.length; i++) {
                    if (Array.isArray(datosSaldo[i])) {
                        const fila = datosSaldo[i];
                        const tieneConcepto = fila.some(celda => celda && celda.toString().toUpperCase().includes('CONCEPTO'));
                        if (tieneConcepto) {
                            headerIndex = i;
                            break;
                        }
                    }
                }

                if (headerIndex === -1) {
                    //console.log('❌ [CHEQUES ETAPA 1] No se encontró header en SALDO');
                    return [];
                }
                
                //console.log('🔵 [CHEQUES ETAPA 1] Header encontrado en fila:', headerIndex);
                const headers = datosSaldo[headerIndex];
                
                // Buscar columnas según la estructura del SALDO OUTPUT PROCESADO
                const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA')); // Columna A (0)
                const conceptoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CONCEPTO REPORTE FINAL')); // Columna D (3) - "Concepto Reporte Final"
                const fdocCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'FDOC'); // Columna E (4)
                const numdocCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'NUMDOC'); // Columna G (6)
                const giradoCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'GIRADO'); // Columna N (13)
                // Intentar buscar HABER primero, si no existe buscar IMPORTE
                const haberCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'HABER'); // Columna H (7)
                const importeCol = haberCol !== -1 ? haberCol : headers.findIndex(h => h && h.toString().toUpperCase() === 'IMPORTE'); // Columna H o O
                const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'ESTADO'); // Columna P (15)

                /*console.log('🔵 [CHEQUES ETAPA 1] Columnas identificadas (índices):', {
                    cuentaCol,
                    conceptoCol,
                    fdocCol,
                    numdocCol,
                    giradoCol,
                    haberCol,
                    importeCol,
                    estadoCol
                });*/
                
                //console.log('🔵 [CHEQUES ETAPA 1] Headers completos:', headers);
                //console.log('🔵 [CHEQUES ETAPA 1] Buscando concepto exacto "Concepto" y estado "ESTADO"');

                if (conceptoCol === -1 || cuentaCol === -1 || estadoCol === -1) {
                    //console.log('❌ [CHEQUES ETAPA 1] Columnas necesarias no encontradas');
                    return [];
                }
                // Procesar filas de datos
                let filasRevisadas = 0;
                let chequesEncontrados = 0;
                let chequesPorCuenta = {};
                
                //console.log('🔵 [CHEQUES ETAPA 1] Iniciando procesamiento de filas...');
                
                for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                    const fila = datosSaldo[i];
                    if (!Array.isArray(fila)) continue;
                    
                    filasRevisadas++;
                    const cuenta = fila[cuentaCol];
                    const concepto = fila[conceptoCol];
                    const estado = fila[estadoCol];
                    
                    // Log de primeras 3 filas para diagnóstico
                    if (filasRevisadas <= 3) {
                        //console.log(`🔍 [CHEQUES ETAPA 1] Fila ${filasRevisadas}:`, {
                            cuenta: cuenta,
                            concepto: concepto,
                            estado: estado
                        });
                    }
                    
                    // CORREGIDO: Distribuir cheques según la cuenta que tengan
                    // Filtrar por concepto "(-) CHEQUES" (NO "(-) CHEQUES NO COBRADOS")
                    // SOLO para cuentas BCP.01 (1041501) y SBP (1041301)
                    const cuentaStr = cuenta ? cuenta.toString() : '';
                    const esCuentaValida = cuentaStr === '1041501' || cuentaStr === '1041301'; // BCP.01 o SBP
                    
                    const conceptoUpper = concepto ? concepto.toString().toUpperCase() : '';
                    const estadoStr = estado ? estado.toString().trim() : '';
                    
                    // CORREGIDO: Buscar "(-) CHEQUES" en columna Concepto (D)
                    const esCheque = conceptoUpper.includes('(-) CHEQUES');
                    // CORREGIDO: Filtrar SOLO los que tienen "Pendiente" exacto (no vacíos ni otros estados)
                    const estaPendiente = estadoStr === 'Pendiente';
                    
                    if (esCuentaValida && esCheque && estaPendiente) {
                        
                        chequesEncontrados++;
                        
                        // Solo agregar si coincide con la cuenta solicitada
                        if (cuentaStr === codigoCuenta) {
                            // Usar HABER si existe la columna, sino usar IMPORTE
                            const importeFinal = haberCol !== -1 
                                ? parseFloat(fila[haberCol]) || 0  // Si existe columna HABER, usar su valor (incluso si es 0)
                                : (importeCol !== -1 ? parseFloat(fila[importeCol]) || 0 : 0); // Si no existe HABER, usar IMPORTE
                            
                            const cheque = {
                                fecha: this.formatearFecha(fila[fdocCol] || ''), // FDOC (columna E)
                                ref: fila[numdocCol] || '', // NUMDOC (columna G)
                                glosa: fila[giradoCol] || '', // GIRADO (columna N)
                                importe: Math.abs(importeFinal) // HABER (si existe) o IMPORTE - valor absoluto
                            };
                            cheques.push(cheque);
                            
                            if (chequesEncontrados <= 5) {
                                const campoUsado = haberCol !== -1 ? 'HABER' : 'IMPORTE';
                                const valorOriginal = haberCol !== -1 ? fila[haberCol] : fila[importeCol];
                                //console.log(`✅ [CHEQUES ETAPA 1] Cheque ${chequesEncontrados} encontrado:`, {
                                    cuenta: cuentaStr,
                                    ref: cheque.ref,
                                    importe: cheque.importe,
                                    campoUsado: campoUsado,
                                    valorOriginal: valorOriginal,
                                    usarHaber: haberCol !== -1
                                });
                            }
                        }
                        
                        // Tracking por cuenta
                        if (!chequesPorCuenta[cuentaStr]) chequesPorCuenta[cuentaStr] = 0;
                        chequesPorCuenta[cuentaStr]++;
                    }
                }
                
                //console.log('🔵 [CHEQUES ETAPA 1] Resumen de procesamiento:', {
                    filasRevisadas,
                    totalChequesEncontrados: chequesEncontrados,
                    chequesPorCuenta,
                    chequesParaEstaCuenta: cheques.length,
                    cuentaSolicitada: codigoCuenta
                });
                
                return cheques;
            },

            // === FUNCIÓN PARA OBTENER PENDIENTES DEL LIBRO 02 ===
            obtenerPendientesLibro02(datosCompletos, codigoCuenta) {
                const pendientes = [];
                
                if (!datosCompletos.datosMayor || !Array.isArray(datosCompletos.datosMayor)) {
                    return pendientes;
                }
                
                const datosMayor = datosCompletos.datosMayor;
                
                // Buscar header para identificar columnas
                let headerIndex = -1;
                for (let i = 0; i < datosMayor.length; i++) {
                    if (Array.isArray(datosMayor[i])) {
                        const fila = datosMayor[i];
                        const tieneLibro = fila.some(celda => celda && celda.toString().toUpperCase().includes('LIBRO'));
                        const tieneEstado = fila.some(celda => celda && celda.toString().toUpperCase().includes('ESTADO'));
                        if (tieneLibro && tieneEstado) {
                            headerIndex = i;
                            break;
                        }
                    }
                }

                if (headerIndex === -1) {
                    return pendientes;
                }
                
                const headers = datosMayor[headerIndex];
                
                // Buscar columnas - CORREGIDO según especificaciones del usuario
                const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA'));
                const libroCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('LIBRO'));
                const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ESTADO'));
                const conceptoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('RAZON SOCI')); // CORREGIDO: era GLOSA
                const fechaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FDOC'));        // CORREGIDO: era FECHA
                const refCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('NUMDOC'));       // CORREGIDO: era REF
                const haberCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('HABER'));

                if (libroCol === -1 || estadoCol === -1 || cuentaCol === -1) {
                    return pendientes;
                }
                // Procesar filas de datos
                for (let i = headerIndex + 1; i < datosMayor.length; i++) {
                    const fila = datosMayor[i];
                    if (!Array.isArray(fila)) continue;
                    
                    const cuenta = fila[cuentaCol];
                    const libro = fila[libroCol];
                    const estado = fila[estadoCol];
                    
                    // Filtrar por cuenta específica, LIBRO 02 y estado Pendiente
                    if (cuenta && cuenta.toString() === codigoCuenta &&
                        libro && libro.toString() === '02' &&
                        estado && estado.toString().toUpperCase().includes('PENDIENTE')) {
                        
                        const importe = parseFloat(fila[haberCol]) || 0;
                        
                        // Solo agregar si el importe es positivo
                        if (importe > 0) {
                            const pendiente = {
                                fecha: this.formatearFecha(fila[fechaCol] || ''),
                                ref: fila[refCol] || '',
                                glosa: fila[conceptoCol] || '', // CORREGIDO: ahora usa RAZON SOCI
                                importe: importe
                            };
                            pendientes.push(pendiente);
                        }
                    }
                }

                return pendientes;
            },

            // === FUNCIÓN PARA OBTENER PENDIENTES DE EXTRACTOS (CARGOS EN BANCOS NO REGISTRADOS EN LIBROS) ===
            obtenerPendientesExtractos(datosCompletos, nombrePestaña, codigoCuenta) {
                
                // DET y BN son saldos manuales, no tienen extractos para procesar
                if (nombrePestaña === 'DET' || nombrePestaña === 'BN') {
                    return [];
                }
                
                const cargos = [];
                let datosExtracto = null;
                
                // Verificar si existe extractosPorCuenta
                if (!datosCompletos.extractosPorCuenta) {
                    return [];
                }
                
                // Buscar por código de cuenta en extractosPorCuenta
                if (datosCompletos.extractosPorCuenta.has(codigoCuenta)) {
                    const extractoInfo = datosCompletos.extractosPorCuenta.get(codigoCuenta);
                    
                    if (extractoInfo && extractoInfo.datosExtracto) {
                        datosExtracto = extractoInfo.datosExtracto;
                    }
                }

                if (!datosExtracto || !Array.isArray(datosExtracto)) {
                    return [];
                }

                // USAR MISMA LÓGICA QUE obtenerDepositosBancosNoRegistrados
                const obtenerColumnaEstado = (nombrePestaña) => {
                    const columnasEstado = {
                        'BCP.01': 11,   // Columna L
                        'BCP.02': 11,   // Columna L
                        'BCP.USD': 11,  // Columna L
                        'SANT': 11,     // Columna L
                        'SANT.USD': 11, // Columna L
                        'BBVA': 7,      // Columna H
                        'BBVA.USD': 7,  // Columna H
                        'SBP': 8,       // Columna I
                        'SBP.USD': 8,   // Columna I
                        'IBK': 9,       // Columna J
                        'IBK.USD': 9    // Columna J
                    };
                    return columnasEstado[nombrePestaña] || 11; // Default L si no se encuentra
                };

                // Función helper para obtener mapeo de columnas por banco
                const obtenerMapeoColumnas = (nombrePestaña) => {
                    const mapeoColumnas = {
                        // BCP: concepto, fecha, ref, importe (usando mapeo genérico actual)
                        'BCP.01': { concepto: 2, fecha: 1, ref: 6, importe: 3 },   // C, B, G, D
                        'BCP.02': { concepto: 2, fecha: 1, ref: 6, importe: 3 },   // C, B, G, D
                        'BCP.USD': { concepto: 2, fecha: 1, ref: 6, importe: 3 },  // C, B, G, D
                        
                        // SANT: concepto, fecha, ref, importe = E, A, D, G
                        'SANT': { concepto: 4, fecha: 0, ref: 3, importe: 6 },     // E, A, D, G
                        'SANT.USD': { concepto: 4, fecha: 0, ref: 3, importe: 6 }, // E, A, D, G
                        
                        // SBP: concepto, fecha, ref, importe = B, A, D, C
                        'SBP': { concepto: 1, fecha: 0, ref: 3, importe: 2 },      // B, A, D, C
                        'SBP.USD': { concepto: 1, fecha: 0, ref: 3, importe: 2 },  // B, A, D, C
                        
                        // IBK: concepto, fecha, ref, importe - usar mapeo dinámico
                        'IBK': { concepto: 3, fecha: 0, ref: 1, importe: 6 },      // D, A, B, G (dinámico según estructura)
                        'IBK.USD': { concepto: 4, fecha: 1, ref: 1, importe: 7 },  // E, B, B, H (dinámico según estructura)
                        
                        // BBVA: concepto, fecha, ref, importe = E, A, D, F (CORREGIDO)
                        'BBVA': { concepto: 4, fecha: 0, ref: 3, importe: 5 },     // E, A, D, F
                        'BBVA.USD': { concepto: 4, fecha: 0, ref: 3, importe: 5 }, // E, A, D, F
                        
                        // DET: concepto, fecha, ref, importe (estructura corregida con RUC)
                        'DET': { concepto: 2, fecha: 1, ref: 3, importe: 7 },      // C, B, D, H (Trans, Fecha, Documento, Abono)
                        
                        // BN: concepto, fecha, ref, importe (estructura pendiente de definir)  
                        'BN': { concepto: 2, fecha: 0, ref: 3, importe: 4 }        // C, A, D, E (temporal)
                    };
                    return mapeoColumnas[nombrePestaña] || { concepto: 2, fecha: 1, ref: 6, importe: 3 }; // Default BCP
                };

                const columnaEstado = obtenerColumnaEstado(nombrePestaña);
                const mapeoColumnas = obtenerMapeoColumnas(nombrePestaña);
                
                let filasRevisadas = 0;
                let filasPendientes = 0;
                let filasCargos = 0;

                // PROCESAR TODAS LAS FILAS (MISMA LÓGICA QUE obtenerDepositosBancosNoRegistrados)
                for (let i = 1; i < datosExtracto.length; i++) {
                    filasRevisadas++;
                    const fila = datosExtracto[i];
                    if (!Array.isArray(fila)) continue;
                    
                    const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                    const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                    const ref = (fila[mapeoColumnas.ref] || '').toString();
                    const fecha = (fila[mapeoColumnas.fecha] || '').toString();
                    
                    // Revisar columna de estado según el banco
                    const estadoColumna = (fila[columnaEstado] || '').toString();
                    
                    // IGUAL QUE obtenerDepositosBancosNoRegistrados: Solo procesar si la columna dice "Pendiente"
                    if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                        continue; // Saltar si no está pendiente
                    }
                    
                    filasPendientes++;
                    
                    // IGUAL QUE obtenerDepositosBancosNoRegistrados: En vez de importe > 0, buscar importe < 0 (cargos)
                    if (importe < 0) {
                        filasCargos++;
                        
                        cargos.push({
                            descripcion: descripcion || `Cargo ${ref}`,
                            fecha: this.formatearFecha(fecha),
                            referencia: ref,
                            importe: Math.abs(importe) // Convertir a positivo para mostrar
                        });
                        
                    }
                }
                
                return cargos;
            },

            // === FUNCIÓN PARA OBTENER DEPÓSITOS EN BANCOS NO REGISTRADOS EN LIBROS ===
            obtenerDepositosBancosNoRegistrados(datosCompletos, nombrePestaña, codigoCuenta) {
                
                // DET y BN son saldos manuales, no tienen extractos para procesar
                if (nombrePestaña === 'DET' || nombrePestaña === 'BN') {
                    return [];
                }
                
                const depositos = [];
                
                let datosExtracto = null;
                
                
                // Verificar si existe extractosPorCuenta
                if (!datosCompletos.extractosPorCuenta) {
                    return [];
                }
                
                
                // Buscar por código de cuenta en extractosPorCuenta
                if (datosCompletos.extractosPorCuenta.has(codigoCuenta)) {
                    const extractoInfo = datosCompletos.extractosPorCuenta.get(codigoCuenta);
                    
                    if (extractoInfo && extractoInfo.datosExtracto) {
                        datosExtracto = extractoInfo.datosExtracto;
                    } else {
                    }
                } else {
                }

                if (!datosExtracto || !Array.isArray(datosExtracto)) {
                    return [];
                }


                // Función helper para obtener columna de estado según el banco
                const obtenerColumnaEstado = (nombrePestaña) => {
                    const columnasEstado = {
                        'BCP.01': 11,   // Columna L
                        'BCP.02': 11,   // Columna L
                        'BCP.USD': 11,  // Columna L
                        'SANT': 11,     // Columna L
                        'SANT.USD': 11, // Columna L
                        'BBVA': 7,      // Columna H
                        'BBVA.USD': 7,  // Columna H
                        'SBP': 8,       // Columna I
                        'SBP.USD': 8,   // Columna I
                        'IBK': 9,       // Columna J
                        'IBK.USD': 9    // Columna J
                    };
                    return columnasEstado[nombrePestaña] || 11; // Default L si no se encuentra
                };

                // Función helper para obtener mapeo de columnas por banco
                const obtenerMapeoColumnas = (nombrePestaña) => {
                    const mapeoColumnas = {
                        // BCP: concepto, fecha, ref, importe (usando mapeo genérico actual)
                        'BCP.01': { concepto: 2, fecha: 1, ref: 6, importe: 3 },   // C, B, G, D
                        'BCP.02': { concepto: 2, fecha: 1, ref: 6, importe: 3 },   // C, B, G, D
                        'BCP.USD': { concepto: 2, fecha: 1, ref: 6, importe: 3 },  // C, B, G, D
                        
                        // SANT: concepto, fecha, ref, importe = E, A, D, G
                        'SANT': { concepto: 4, fecha: 0, ref: 3, importe: 6 },     // E, A, D, G
                        'SANT.USD': { concepto: 4, fecha: 0, ref: 3, importe: 6 }, // E, A, D, G
                        
                        // SBP: concepto, fecha, ref, importe = B, A, D, C
                        'SBP': { concepto: 1, fecha: 0, ref: 3, importe: 2 },      // B, A, D, C
                        'SBP.USD': { concepto: 1, fecha: 0, ref: 3, importe: 2 },  // B, A, D, C
                        
                        // IBK: concepto, fecha, ref, importe - usar mapeo dinámico
                        'IBK': { concepto: 3, fecha: 0, ref: 1, importe: 6 },      // D, A, B, G (dinámico según estructura)
                        'IBK.USD': { concepto: 4, fecha: 1, ref: 1, importe: 7 },  // E, B, B, H (dinámico según estructura)
                        
                        // BBVA: concepto, fecha, ref, importe = E, A, D, F (CORREGIDO)
                        'BBVA': { concepto: 4, fecha: 0, ref: 3, importe: 5 },     // E, A, D, F
                        'BBVA.USD': { concepto: 4, fecha: 0, ref: 3, importe: 5 }, // E, A, D, F
                        
                        // DET: concepto, fecha, ref, importe (estructura corregida con RUC)
                        'DET': { concepto: 2, fecha: 1, ref: 3, importe: 7 },      // C, B, D, H (Trans, Fecha, Documento, Abono)
                        
                        // BN: concepto, fecha, ref, importe (estructura pendiente de definir)  
                        'BN': { concepto: 2, fecha: 0, ref: 3, importe: 4 }        // C, A, D, E (temporal)
                    };
                    return mapeoColumnas[nombrePestaña] || { concepto: 2, fecha: 1, ref: 6, importe: 3 }; // Default BCP
                };

                const columnaEstado = obtenerColumnaEstado(nombrePestaña);
                const mapeoColumnas = obtenerMapeoColumnas(nombrePestaña);
                
                
                if (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') {
                    for (let debug = 1; debug <= Math.min(3, datosExtracto.length - 1); debug++) {
                        const filaDebug = datosExtracto[debug];
                        if (Array.isArray(filaDebug)) {
                        }
                    }
                }

                // LÓGICA PARA TODOS LOS BANCOS
                if (nombrePestaña === 'BCP.01') {
                    
                    // PARTE 1: AGRUPACIONES ESPECIALES (6 grupos máximo)
                    const gruposEspeciales = [
                        { nombre: 'TRANSF.BCO.CITIBANK', criterio: 'includes' },
                        { nombre: 'DE PROCESOS DE MEDIOS', criterio: 'includes' },
                        { nombre: 'CIA DE SERV', criterio: 'includes' },
                        { nombre: 'COMPAN', criterio: 'endsWith' },
                        { nombre: 'DE DINERS CLUB PERU S.', criterio: 'includes' },
                        { nombre: 'DE GAS NATURAL DE LIMA', criterio: 'includes' }
                    ];
                    
                    
                    // Crear UNA FILA por grupo (agrupación)
                    gruposEspeciales.forEach(grupo => {
                        let totalGrupo = 0;
                        let fechaGrupo = '';
                        let refGrupo = '';
                        let transaccionesEncontradas = [];
                        
                        
                        let filasRevisadas = 0;
                        let filasPendientes = 0;
                        let filasPositivas = 0;
                        let filasCoincidentes = 0;
                        
                        // Buscar TODAS las transacciones de este grupo para sumarlas
                        for (let i = 1; i < datosExtracto.length; i++) {
                            filasRevisadas++;
                            const fila = datosExtracto[i];
                            if (!Array.isArray(fila)) continue;
                            
                            const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                            const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                            const ref = (fila[mapeoColumnas.ref] || '').toString();
                            
                            // Revisar columna de estado según el banco
                            const estadoColumna = (fila[columnaEstado] || '').toString();
                            
                            // Solo procesar si la columna dice "Pendiente"
                            if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                                continue; // Saltar si no está pendiente
                            }
                            
                            
                            filasPendientes++;
                            if (importe > 0) filasPositivas++;
                            
                            // Verificar si coincide con el grupo
                            let coincide = false;
                            if (grupo.criterio === 'endsWith') {
                                coincide = descripcion.toUpperCase().endsWith(grupo.nombre.toUpperCase());
                            } else {
                                coincide = descripcion.toUpperCase().includes(grupo.nombre.toUpperCase());
                            }
                            if (coincide) filasCoincidentes++;
                            
                            // FILTRO: POSITIVO + COINCIDE (ya sabemos que está pendiente)
                            if (importe > 0 && coincide) {
                                totalGrupo += importe;
                                if (!fechaGrupo) fechaGrupo = (fila[mapeoColumnas.fecha] || '').toString(); // Primera fecha encontrada
                                if (!refGrupo) refGrupo = ref; // Primera referencia encontrada
                                transaccionesEncontradas.push({
                                    fila: i,
                                    descripcion: descripcion,
                                    importe: importe
                                });
                            }
                        }
                        
                        // Solo crear UNA FILA de agrupación si encontró transacciones
                        if (totalGrupo > 0) {
                            const agrupacion = {
                                descripcion: grupo.nombre, // Nombre del grupo, no las descripciones individuales
                                fecha: fechaGrupo,
                                ref: refGrupo,
                                importe: totalGrupo
                            };
                            
                            depositos.push(agrupacion);
                            transaccionesEncontradas.forEach(t => {
                            });
                        } else {
                        }
                        
                    });
                    
                    
                    // PARTE 2: TODOS LOS PENDIENTES POSITIVOS RESTANTES (que NO fueron agrupados)
                    
                    let pendientesIndividuales = 0;
                    let pendientesExcluidos = 0;
                    let totalFilasRevisadas = 0;
                    let totalFilasPendientes = 0;
                    let totalFilasPositivas = 0;
                    
                    for (let i = 1; i < datosExtracto.length; i++) {
                        totalFilasRevisadas++;
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                        const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                        const ref = (fila[mapeoColumnas.ref] || '').toString();
                        const fecha = (fila[mapeoColumnas.fecha] || '').toString();
                        
                        // Revisar columna de estado según el banco
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        
                        // Solo procesar si la columna dice "Pendiente"
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue; // Saltar si no está pendiente
                        }
                        
                        // Contar estadísticas (si llegamos aquí, está pendiente)
                        totalFilasPendientes++;
                        if (importe > 0) totalFilasPositivas++;
                        
                        // Solo procesar positivos (ya sabemos que está pendiente)
                        if (importe > 0) {
                            
                            // Verificar que NO sea parte de las agrupaciones especiales
                            let esGrupoEspecial = false;
                            for (const grupo of gruposEspeciales) {
                                if (grupo.criterio === 'endsWith') {
                                    if (descripcion.toUpperCase().endsWith(grupo.nombre.toUpperCase())) {
                                        esGrupoEspecial = true;
                                        break;
                                    }
                                } else {
                                    if (descripcion.toUpperCase().includes(grupo.nombre.toUpperCase())) {
                                        esGrupoEspecial = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (esGrupoEspecial) {
                                pendientesExcluidos++;
                            } else {
                                // Agregar como depósito individual
                                const deposito = {
                                    descripcion: descripcion,
                                    fecha: fecha,
                                    ref: ref,
                                    importe: importe
                                };
                                
                                depositos.push(deposito);
                                pendientesIndividuales++;
                                // Individual agregado
                            }
                        }
                    }
                    
                    
                } else if (nombrePestaña === 'SBP' || nombrePestaña === 'SBP.USD') {
                    
                    // PARTE 1: AGRUPACIÓN ESPECIAL MERCADOPAGO
                    const grupoMercadoPago = { nombre: 'MERCADOPAGO', criterio: 'includes' };
                    let totalGrupo = 0;
                    let fechaGrupo = '';
                    let refGrupo = '';
                    let transaccionesEncontradas = [];
                    
                    // Agrupando MERCADOPAGO
                    
                    // Buscar todas las transacciones MERCADOPAGO
                    for (let i = 1; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                        const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                        const ref = (fila[mapeoColumnas.ref] || '').toString();
                        
                        // Revisar columna de estado según el banco
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        
                        // Solo procesar si está pendiente
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue;
                        }
                        
                        // Verificar si es MERCADOPAGO
                        const esMercadoPago = descripcion.toUpperCase().includes('MERCADOPAGO');
                        
                        if (esMercadoPago && importe > 0) {
                            totalGrupo += importe;
                            if (!fechaGrupo) fechaGrupo = (fila[mapeoColumnas.fecha] || '').toString();
                            if (!refGrupo) refGrupo = ref;
                            transaccionesEncontradas.push({
                                fila: i,
                                descripcion: descripcion,
                                importe: importe
                            });
                        }
                    }
                    
                    // Crear agrupación MERCADOPAGO si hay transacciones
                    if (totalGrupo > 0) {
                        const agrupacion = {
                            descripcion: 'MERCADOPAGO',
                            fecha: fechaGrupo,
                            ref: refGrupo,
                            importe: totalGrupo
                        };
                        depositos.push(agrupacion);
                    }
                    
                    // PARTE 2: Todos los demás pendientes positivos (excepto MERCADOPAGO)
                    // Parte 2: Otros pendientes (NO MERCADOPAGO)
                    
                    for (let i = 1; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        // Usar mapeo correcto de columnas según el banco (igual que en agrupaciones)
                        const descripcion = (fila[mapeoColumnas.concepto] || '').toString(); // B
                        const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;        // C
                        const ref = (fila[mapeoColumnas.ref] || '').toString();              // D
                        const fecha = (fila[mapeoColumnas.fecha] || '').toString();          // A
                        
                        // Revisar columna de estado
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue;
                        }
                        
                        // Solo procesar positivos que NO sean MERCADOPAGO
                        if (importe > 0 && !descripcion.toUpperCase().includes('MERCADOPAGO')) {
                            const deposito = {
                                descripcion: descripcion,
                                fecha: fecha,
                                ref: ref,
                                importe: importe
                            };
                            depositos.push(deposito);
                        }
                    }
                    
                } else if (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') {
                    
                    // PARTE 1: AGRUPACIÓN ESPECIAL POWERPAY
                    const grupoPowerPay = { nombre: 'POWERPAY', criterio: 'includes' };
                    let totalGrupo = 0;
                    let fechaGrupo = '';
                    let refGrupo = '';
                    let transaccionesEncontradas = [];
                    
                    
                    // Buscar todas las transacciones POWERPAY
                    for (let i = 1; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        const descripcionC = (fila[2] || '').toString(); // Columna C
                        const importeD = parseFloat(fila[3]) || 0; // Columna D
                        const refG = (fila[6] || '').toString(); // Columna G
                        
                        // Revisar columna de estado según el banco
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        
                        // Solo procesar si está pendiente
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue;
                        }
                        
                        // Verificar si es POWERPAY
                        const esPowerPay = descripcionC.toUpperCase().includes('POWERPAY');
                        
                        if (esPowerPay && importeD > 0) {
                            totalGrupo += importeD;
                            if (!fechaGrupo) fechaGrupo = (fila[1] || '').toString();
                            if (!refGrupo) refGrupo = refG;
                            transaccionesEncontradas.push({
                                fila: i,
                                descripcion: descripcionC,
                                importe: importeD
                            });
                        }
                    }
                    
                    // Crear agrupación POWERPAY si hay transacciones
                    if (totalGrupo > 0) {
                        const agrupacion = {
                            descripcion: 'POWERPAY',
                            fecha: fechaGrupo,
                            ref: refGrupo,
                            importe: totalGrupo
                        };
                        depositos.push(agrupacion);
                    }
                    
                    // PARTE 2: Todos los demás pendientes positivos (excepto POWERPAY)
                    
                    for (let i = 1; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        // Usar mapeo correcto de columnas según el banco (igual que en agrupaciones)
                        const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                        const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                        const ref = (fila[mapeoColumnas.ref] || '').toString();
                        const fecha = (fila[mapeoColumnas.fecha] || '').toString();
                        
                        // Revisar columna de estado
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue;
                        }
                        
                        // Solo procesar positivos que NO sean POWERPAY
                        if (importe > 0 && !descripcion.toUpperCase().includes('POWERPAY')) {
                            const deposito = {
                                descripcion: descripcion,
                                fecha: fecha,
                                ref: ref,
                                importe: importe
                            };
                            depositos.push(deposito);
                        }
                    }
                    
                } else {
                    // LÓGICA GENÉRICA PARA OTROS BANCOS (SANT, IBK, BCP.02, BCP.USD, BBVA, BBVA.USD)
                    
                    for (let i = 1; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        if (!Array.isArray(fila)) continue;
                        
                        // Usar mapeo correcto de columnas según el banco
                        const descripcion = (fila[mapeoColumnas.concepto] || '').toString();
                        const importe = parseFloat(fila[mapeoColumnas.importe]) || 0;
                        const ref = (fila[mapeoColumnas.ref] || '').toString();
                        const fecha = (fila[mapeoColumnas.fecha] || '').toString();
                        
                        // Revisar columna de estado según el banco
                        const estadoColumna = (fila[columnaEstado] || '').toString();
                        
                        if ((nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') && i <= 5) {
                        }
                        
                        // Solo procesar si está pendiente
                        if (estadoColumna.toUpperCase() !== 'PENDIENTE') {
                            continue;
                        }
                        
                        // Agregar todos los pendientes positivos
                        if (importe > 0) {
                            const deposito = {
                                descripcion: descripcion,
                                fecha: fecha,
                                ref: ref,
                                importe: importe
                            };
                            depositos.push(deposito);
                        }
                    }
                }

                
                return depositos;
            },

            generateDatosOriginalesFile(datosCompletos, fileName) {
                try {
                    
                    const wb = XLSX.utils.book_new();
                    
                    const resumenData = [];
                    
                    // === FUNCIONES DE FILTRADO USANDO DATOS JSON ===
                    
                    // Función para calcular cheques no cobrados desde datos JSON almacenados
                    const calcularChequesNoCobradosJSON = () => {
                        //console.log('🔍 [JSON FILTER] Calculando cheques no cobrados desde datos JSON...');
                        
                        if (!window.datosHojaTrabajoJSON || !window.datosHojaTrabajoJSON.saldo) {
                            //console.log('⚠️ [JSON FILTER] No hay datos JSON disponibles');
                            return 0;
                        }
                        
                        const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                        //console.log('🔍 [JSON FILTER] Datos SALDO disponibles:', datosSaldo.length, 'filas');
                        
                        if (datosSaldo.length === 0) {
                            return 0;
                        }
                        
                        try {
                            // Buscar el header
                            let headerIndex = -1;
                            let headers = [];
                            
                            for (let i = 0; i < datosSaldo.length; i++) {
                                const fila = datosSaldo[i];
                                if (Array.isArray(fila) && fila.some(celda => 
                                    celda && celda.toString().toUpperCase().includes('CONCEPTO'))) {
                                    headerIndex = i;
                                    headers = fila;
                                    break;
                                }
                            }
                            
                            if (headerIndex === -1) {
                                //console.log('⚠️ [JSON FILTER] No se encontró header en datos SALDO');
                                return 0;
                            }
                            
                            // Buscar índices de columnas
                            const conceptoCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('CONCEPTO REPORTE FINAL'));
                            const estadoCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase() === 'ESTADO');
                            const haberCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('HABER'));
                            const importeCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('IMPORTE'));
                            
                            //console.log('🔍 [JSON FILTER] Headers encontrados:', headers);
                            //console.log('🔍 [JSON FILTER] Índices - Concepto:', conceptoCol, 'Estado:', estadoCol, 'Haber:', haberCol, 'Importe:', importeCol);
                            
                            if (conceptoCol === -1 || estadoCol === -1 || haberCol === -1 || importeCol === -1) {
                                //console.log('⚠️ [JSON FILTER] No se encontraron todas las columnas necesarias');
                                return 0;
                            }
                            
                            // Filtrar y sumar
                            let totalCheques = 0;
                            let filasProcesadas = 0;
                            let filasConConcepto = 0;
                            
                            for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                                const fila = datosSaldo[i];
                                if (!Array.isArray(fila)) continue;
                                
                                filasProcesadas++;
                                const concepto = fila[conceptoCol]?.toString().trim();
                                const estado = fila[estadoCol]?.toString().trim();
                                const haber = parseFloat(fila[haberCol]) || 0;
                                const importe = parseFloat(fila[importeCol]) || 0;
                                
                                // Log para debugging
                                if (concepto && concepto.includes('CHEQUES')) {
                                    filasConConcepto++;
                                    //console.log('🔍 [JSON FILTER] Fila con concepto cheques:', { concepto, estado, haber, importe });
                                }
                                
                                // Aplicar filtros
                                if (concepto === '(-) CHEQUES NO COBRADOS' &&
                                    estado === 'pendiente' &&
                                    haber > 0) {
                                    //console.log('✅ [JSON FILTER] Fila que cumple filtros:', { concepto, estado, haber, importe });
                                    totalCheques += importe;
                                }
                            }
                            
                            //console.log('🔍 [JSON FILTER] Resumen - Filas procesadas:', filasProcesadas, 'Con concepto cheques:', filasConConcepto, 'Total calculado:', totalCheques);
                            return totalCheques;
                            
                        } catch (error) {
                            //console.error('❌ [JSON FILTER] Error calculando cheques:', error);
                            return 0;
                        }
                    };
                    
                    // Header principal
                    resumenData.push(['RESUMEN DE CUENTAS BANCARIAS']);
                    resumenData.push(['Generado el:', new Date().toLocaleDateString('es-PE')]);
                    resumenData.push(['Mes:', this.mesAnoTarjetas || '']);
                    resumenData.push(['Tipo de Cambio:', this.tipoCambio || 3.5]);
                    resumenData.push([]); // Fila vacía
                    
                    // Headers de la tabla
                    resumenData.push(['#CTA', 'Nombre', 'USD', 'PEN', 'LIBROS', 'AJUSTE DIF CAMBIO']);
                    
                    // Función para obtener saldo de libros
                    const getSaldoLibrosExcel = (cuenta) => {
                        if (this.conciliationResult && this.conciliationResult.saldosLibros) {
                            const saldo = this.conciliationResult.saldosLibros.get(cuenta);
                            if (saldo !== undefined && saldo !== null) {
                                return saldo; // Retornar el número para Excel
                            }
                        }
                        return 0; // Si no hay saldo, retornar 0
                    };
                    
                    // Función para obtener saldo de extractos
                    const getSaldoExtractoExcel = (cuenta) => {
                        if (this.conciliationResult && this.conciliationResult.saldosExtractos) {
                            const saldo = this.conciliationResult.saldosExtractos.get(cuenta);
                            if (saldo !== undefined && saldo !== null) {
                                return saldo; // Retornar el número para Excel
                            }
                        }
                        return 0; // Si no hay saldo, retornar 0
                    };

                    // Función para calcular equivalente PEN de cuentas USD
                    const getSaldoExtractoPENExcel = (cuenta) => {
                        if (this.conciliationResult && this.conciliationResult.saldosExtractos && this.tipoCambio > 0) {
                            const saldoUSD = this.conciliationResult.saldosExtractos.get(cuenta);
                            if (saldoUSD !== undefined && saldoUSD !== null) {
                                return saldoUSD * this.tipoCambio; // USD * Tipo de Cambio = PEN
                            }
                        }
                        return 0; // Si no hay saldo USD o TC, retornar 0
                    };
                    
                    // Función para crear fórmula Excel de conversión USD a PEN
                    const crearFormulaUSDaPEN = (filaUSD, filaPEN) => {
                        // Tipo de cambio está en B4 (fila 4, columna B)
                        // USD está en columna C, PEN está en columna D
                        const columnaUSD = 'C';
                        const columnaPEN = 'D';
                        const celdaTipoCambio = 'B4';
                        const celdaUSD = `${columnaUSD}${filaUSD}`;
                        return `=${celdaUSD}*$${celdaTipoCambio}`;
                    };

                    // Función para calcular cheques no cobrados desde datos SALDO
                    const calcularChequesNoCobrados = (datosSaldo) => {
                        //console.log('🔍 [CALCULAR CHEQUES] Iniciando cálculo...');
                        //console.log('🔍 [CALCULAR CHEQUES] Datos SALDO:', datosSaldo);
                        
                        if (!datosSaldo || !Array.isArray(datosSaldo) || datosSaldo.length === 0) {
                            //console.log('⚠️ [CALCULAR CHEQUES] No hay datos SALDO disponibles');
                            return 0;
                        }

                        try {
                            // Buscar el índice de las columnas necesarias
                            let headerIndex = -1;
                            let headers = [];
                            
                            for (let i = 0; i < datosSaldo.length; i++) {
                                const fila = datosSaldo[i];
                                if (Array.isArray(fila) && fila.some(celda => 
                                    celda && celda.toString().toUpperCase().includes('CONCEPTO'))) {
                                    headerIndex = i;
                                    headers = fila;
                                    break;
                                }
                            }

                            if (headerIndex === -1) {
                                return 0;
                            }

                            // Buscar índices de columnas
                            const conceptoCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('CONCEPTO REPORTE FINAL'));
                            const estadoCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase() === 'ESTADO');
                            const haberCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('HABER'));
                            const importeCol = headers.findIndex(h => 
                                h && h.toString().toUpperCase().includes('IMPORTE'));

                            if (conceptoCol === -1 || estadoCol === -1 || haberCol === -1 || importeCol === -1) {
                                return 0;
                            }

                            // Filtrar y sumar
                            let totalCheques = 0;
                            let filasProcesadas = 0;
                            let filasConConcepto = 0;
                            
                            //console.log('🔍 [CALCULAR CHEQUES] Headers encontrados:', headers);
                            //console.log('🔍 [CALCULAR CHEQUES] Índices - Concepto:', conceptoCol, 'Estado:', estadoCol, 'Haber:', haberCol, 'Importe:', importeCol);
                            
                            for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                                const fila = datosSaldo[i];
                                if (!Array.isArray(fila)) continue;

                                filasProcesadas++;
                                const concepto = fila[conceptoCol]?.toString().trim();
                                const estado = fila[estadoCol]?.toString().trim();
                                const haber = parseFloat(fila[haberCol]) || 0;
                                const importe = parseFloat(fila[importeCol]) || 0;

                                // Log para debugging
                                if (concepto && concepto.includes('CHEQUES')) {
                                    filasConConcepto++;
                                    //console.log('🔍 [CALCULAR CHEQUES] Fila con concepto cheques:', { concepto, estado, haber, importe });
                                }

                                // Aplicar filtros
                                if (concepto === '(-) CHEQUES NO COBRADOS' &&
                                    estado === 'pendiente' &&
                                    haber > 0) {
                                    //console.log('✅ [CALCULAR CHEQUES] Fila que cumple filtros:', { concepto, estado, haber, importe });
                                    totalCheques += importe;
                                }
                            }

                            //console.log('🔍 [CALCULAR CHEQUES] Resumen - Filas procesadas:', filasProcesadas, 'Con concepto cheques:', filasConConcepto, 'Total calculado:', totalCheques);
                            return totalCheques;
                        } catch (error) {
                            //console.error('Error calculando cheques no cobrados:', error);
                            return 0;
                        }
                    };
                    
                    // Construir datos de cuentas con fórmulas Excel
                    const cuentasData = [];
                    const cuentasConfig = [
                        { codigo: '1041501', nombre: 'BCP.01', esUSD: false },
                        { codigo: '1041505', nombre: 'BCP.02', esUSD: false },
                        { codigo: '1041502', nombre: 'BCP.USD', esUSD: true },
                        { codigo: '1041401', nombre: 'SANT', esUSD: false },
                        { codigo: '1041402', nombre: 'SANT.USD', esUSD: true },
                        { codigo: '1041201', nombre: 'BBVA', esUSD: false },
                        { codigo: '1041202', nombre: 'BBVA.USD', esUSD: true },
                        { codigo: '1041301', nombre: 'SBP', esUSD: false },
                        { codigo: '1041302', nombre: 'SBP.USD', esUSD: true },
                        { codigo: '1041101', nombre: 'IBK', esUSD: false },
                        { codigo: '1041102', nombre: 'IBK.USD', esUSD: true },
                        { codigo: '1042101', nombre: 'DET', esUSD: false },
                        { codigo: '1041601', nombre: 'BN', esUSD: false }
                    ];

                    // Fila inicial para datos (después de headers)
                    let filaActual = 7; // Empieza en fila 7 (después de headers)

                    cuentasConfig.forEach(cuenta => {
                        const saldoUSD = getSaldoExtractoExcel(cuenta.codigo);
                        const saldoLibros = getSaldoLibrosExcel(cuenta.codigo);
                        
                        /*
                        const crearFormulaSaldo = (hoja) => {
                            return `=INDICE(INDIRECTO("'${hoja}'!E:E"); COINCIDIR("SALDO EN LIBROS"; INDIRECTO("'${hoja}'!A:A"); 0))`;
                        };
                        */

                        const crearFormulaSaldo = (hoja) => {
                            // Buscar en un rango específico en lugar de columnas completas
                            return `=IFERROR(VLOOKUP("SALDO EN LIBROS",'${hoja}'!A:Z,5,FALSE),0)`;
                        };

                        //=INDICE(INDIRECTO("'BCP.01'!E:E"); COINCIDIR("SALDO EN LIBROS"; INDIRECTO("'BCP.01'!A:A"); 0))
                        const formulaSaldo = crearFormulaSaldo(cuenta.nombre);


                        let filaCuenta;
                        
                        if (cuenta.esUSD && saldoUSD > 0) {
                            // Para cuentas USD: usar fórmula Excel en lugar del valor calculado
                            filaCuenta = [
                                cuenta.codigo,
                                cuenta.nombre,
                                //saldoUSD, // Valor USD original (ya calculado)
                                { f: formulaSaldo },
                                { f: `=C${filaActual}/$B$4` }, // Fórmula: USD * Tipo de Cambio
                                saldoLibros,
                                { f: `=E${filaActual}-D${filaActual}` } // Fórmula: LIBROS - PEN
                            ];
                        } else {
                            // Para cuentas PEN: usar valor directo (ya calculado)
                            filaCuenta = [
                                cuenta.codigo,
                                cuenta.nombre,
                                0, // Sin USD
                                //getSaldoExtractoExcel(cuenta.codigo), // Valor PEN directo (ya calculado)
                                { f: formulaSaldo },
                                saldoLibros,
                                { f: `=E${filaActual}-D${filaActual}` } // Fórmula: LIBROS - PEN
                            ];
                        }
                        
                        cuentasData.push(filaCuenta);
                        filaActual++;
                    });
                    
                    // Agregar datos de cuentas
                    cuentasData.forEach(cuenta => resumenData.push(cuenta));
                    
                    const wsResumen = XLSX.utils.aoa_to_sheet(resumenData);
                    
                    // Log para verificar que las fórmulas se aplicaron correctamente
                    //console.log('🔍 [RESUMEN] ✅ Fórmulas de AJUSTE DIF CAMBIO agregadas');
                    //console.log('🔍 [RESUMEN] 📊 Total de cuentas procesadas:', cuentasData.length);
                    //console.log('🔍 [RESUMEN] 🔄 Fórmula aplicada: =E{fila}-D{fila} para cada cuenta');
                    
                    XLSX.utils.book_append_sheet(wb, wsResumen, "Resumen");
                    
                    // AGREGAR PESTAÑAS DE EXTRACTOS VACÍAS (mismas que Hoja de Trabajo)
                    const pestañasExtractos = [
                        'BCP.01',
                        'BCP.02', 
                        'BCP.USD',
                        'SANT',
                        'SANT.USD',
                        'BBVA',
                        'BBVA.USD',
                        'SBP',
                        'SBP.USD',
                        'IBK',
                        'IBK.USD',
                        'DET',
                        'BN'
                    ];
                    
                    // Obtener depósitos en libros no registrados en bancos para BCP.01
                    const depositosLibrosNoRegistrados = this.obtenerDepositosLibrosNoRegistrados(datosCompletos);
                    
                    // Crear pestañas de conciliación bancaria para cada extracto
                    for (const nombrePestaña of pestañasExtractos) {
                        try {
                        
                        // Obtener código de cuenta correspondiente al nombre de pestaña
                        const codigoCuenta = this.obtenerCodigoCuentaPorPestaña(nombrePestaña);
                        
                        // Obtener saldos reales
                        const saldoBanco = this.obtenerSaldoBancoPorCuenta(codigoCuenta);
                        const saldoLibros = this.obtenerSaldoLibrosPorCuenta(codigoCuenta);
                        
                        
                        let totalAjustes = 0;
                        
                        // Inicializar datos de conciliación
                        const datosConciliacion = [
                            [`CONCILIACIÓN BANCARIA - ${nombrePestaña}`],
                            ['Fecha de generación:', new Date().toLocaleDateString('es-PE')],
                            ['Código de cuenta:', codigoCuenta],
                            ['Tipo de cambio usado:', this.tipoCambio || 'N/A'],
                            [''],
                            ['FECHA', 'CONCEPTO', 'REF', 'IMPORTE', 'PARTE', 'ESTADO', 'DESCRIPCIÓN', 'COMPROBANTE', 'GIRADO', 'IMPORTE'],
                            [''],
                            ['SALDO EN BANCOS', '', '', '', 0, '', '', '', '', '']           // SALDO EN BANCOS al inicio
                        ];
                        
                        // Obtener código de cuenta según la pestaña (para todas las pestañas)
                        const codigoCuentaActual = nombrePestaña === 'BCP.01' ? '1041501' : 
                                                 nombrePestaña === 'BCP.02' ? '1041505' : 
                                                 nombrePestaña === 'BCP.USD' ? '1041502' : 
                                                 nombrePestaña === 'SANT' ? '1041401' : 
                                                 nombrePestaña === 'SANT.USD' ? '1041402' : 
                                                 nombrePestaña === 'BBVA' ? '1041201' : 
                                                 nombrePestaña === 'BBVA.USD' ? '1041202' : 
                                                 nombrePestaña === 'SBP' ? '1041301' : 
                                                 nombrePestaña === 'SBP.USD' ? '1041302' : 
                                                 nombrePestaña === 'IBK' ? '1041101' : 
                                                 nombrePestaña === 'IBK.USD' ? '1041102' : 
                                                 nombrePestaña === 'DET' ? '1042101' : 
                                                 nombrePestaña === 'BN' ? '1041601' : null;
                        
                        // Solo para pestañas con códigos de cuenta válidos: Agregar título especial
                        if (codigoCuentaActual) {
                            // DEBUG: Guardar JSON completo para análisis
                            //console.log('🔍 [DEBUG] window.datosHojaTrabajoJSON completo:', window.datosHojaTrabajoJSON);
                            
                            // DEBUG: JSON disponible en consola (sin descarga automática)
                            //console.log('📁 [DEBUG] JSON disponible en window.datosHojaTrabajoJSON');
                            
                            //console.log(`🔍 [DEBUG] Procesando ${nombrePestaña} con código de cuenta: ${codigoCuentaActual}`);
                            
                            // CHEQUES NO COBRADOS CONSOLIDADOS (PARTE 1 + PARTE 2)
                            //console.log('🔍 [DEBUG] Iniciando cálculo consolidado de Cheques No Cobrados');
                            
                            let totalChequesConsolidado = 0;
                            let todosChequesDetalles = [];
                            
                            // PARTE 1: CHEQUES NO COBRADOS DESDE SALDO
                            //console.log('🔍 [DEBUG] Procesando Cheques No Cobrados - Parte 1 desde SALDO');
                            
                            if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                                //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                                
                                const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                                const headers = datosSaldo[0];
                                const datosMapeados = datosSaldo.slice(1).map(row => {
                                    const obj = {};
                                    headers.forEach((header, index) => {
                                        obj[header] = row[index];
                                    });
                                    return obj;
                                });

                                const chequesNoCobradosParte1 = datosMapeados.filter(item => {
                                    return item['CUENTA'] === codigoCuentaActual &&
                                           item['Concepto Reporte Final'] === '(-) CHEQUES NO COBRADOS' &&
                                           item['HABER'] > 0 &&
                                           item['ESTADO'] === 'Pendiente';
                                });

                                //console.log('🔍 [DEBUG] Cheques Parte 1 encontrados:', chequesNoCobradosParte1.length);
                                
                                const totalParte1 = chequesNoCobradosParte1.reduce((sum, item) => sum + (parseFloat(item['HABER']) || 0), 0);
                                totalChequesConsolidado += totalParte1;
                                //console.log('🔍 [DEBUG] Total Parte 1 calculado:', totalParte1);
                                
                                // Agregar detalles de Parte 1
                                chequesNoCobradosParte1.forEach(cheque => {
                                    // Buscar datos adicionales del cheque por número de referencia
                                    const datosCheque = this.buscarDatosChequePorReferencia(cheque['NUMDOC'] || '');
                                    
                                    const filaCheque = [
                                        this.formatearFecha(cheque['FDOC']),  // 1. FECHA
                                        cheque['Girado'] || '',              // 2. CONCEPTO (Girado)
                                        cheque['NUMDOC'] || '',               // 3. REF
                                        //parseFloat(cheque['Importe']) || 0,   // 4. IMPORTE
                                        parseFloat(cheque['HABER']) || 0,   // 4. IMPORTE
                                        'PARTE 1',                           // 5. PARTE
                                        datosCheque?.estado || '',           // 6. Estado
                                        datosCheque?.descripcion || '',      // 7. Descripción
                                        datosCheque?.comprobante || '',       // 8. Comprobante
                                        datosCheque?.girado || '',           // 9. Girado
                                        datosCheque?.importe || ''           // 10. Importe (segunda columna)
                                    ];
                                    todosChequesDetalles.push(filaCheque);
                                });
                            } else {
                                console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Parte 1');
                            }
                            
                            // PARTE 2: CHEQUES NO COBRADOS DESDE MAYOR.PEN
                            //console.log('🔍 [DEBUG] Procesando Cheques No Cobrados - Parte 2 desde MAYOR.PEN');
                            
                            if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.mayor && Array.isArray(window.datosHojaTrabajoJSON.mayor)) {
                                //console.log('🔍 [DEBUG] Datos MAYOR.PEN disponibles:', window.datosHojaTrabajoJSON.mayor.length, 'filas');
                                
                                const datosMayor = window.datosHojaTrabajoJSON.mayor;
                                
                                // Filtrar cheques Parte 2: Cuenta dinámica, Estado=Pendiente, Libro=02
                                const chequesParte2 = datosMayor.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    return item[7] === codigoCuentaActual &&    // CUENTA (índice 7) - dinámico
                                           item[14] === 'Pendiente' &&  // ESTADO (índice 14)
                                           item[4] === '02';            // LIBRO (índice 4)
                                });
                                
                                //console.log('🔍 [DEBUG] Cheques Parte 2 encontrados:', chequesParte2.length);
                                
                                const totalParte2 = chequesParte2.reduce((sum, item) => sum + (parseFloat(item[13]) || 0), 0);
                                totalChequesConsolidado += totalParte2;
                                //console.log('🔍 [DEBUG] Total Parte 2 calculado:', totalParte2);
                                
                                // Agregar detalles de Parte 2
                                chequesParte2.forEach(cheque => {
                                    // Buscar datos adicionales del cheque por número de referencia
                                    const datosCheque = this.buscarDatosChequePorReferencia(cheque[1] || '');
                                    
                                    const filaCheque = [
                                        this.formatearFecha(cheque[2]),  // 1. FECHA (FDOC índice 2)
                                        cheque[10] || '',               // 2. CONCEPTO (RAZON SOCI índice 10)
                                        cheque[1] || '',                // 3. REF (NUMDOC índice 1)
                                        parseFloat(cheque[13]) || 0,    // 4. IMPORTE (HABER índice 13)
                                        'PARTE 2',                      // 5. PARTE
                                        datosCheque?.estado || '',      // 6. Estado
                                        datosCheque?.descripcion || '',  // 7. Descripción
                                        datosCheque?.comprobante || '',  // 8. Comprobante
                                        datosCheque?.girado || '',      // 9. Girado
                                        datosCheque?.importe || ''      // 10. Importe (segunda columna)
                                    ];
                                    todosChequesDetalles.push(filaCheque);
                                });
                            } else {
                                console.warn('⚠️ window.datosHojaTrabajoJSON.mayor no está disponible para Parte 2');
                            }
                            
                            // Agregar título consolidado y todos los detalles
                            if (totalChequesConsolidado > 0 || todosChequesDetalles.length > 0) {
                                //console.log('🔍 [DEBUG] Total consolidado calculado:', totalChequesConsolidado);
                                
                                // Agregar línea en blanco para diferenciación visual
                                datosConciliacion.push(['']);
                                
                                // CORRECCIÓN DE SIGNO: Para conceptos (-), el total debe ser negativo
                                const totalConSignoCorrecto = -Math.abs(totalChequesConsolidado);
                                //console.log('🔍 [DEBUG] Total con signo corregido:', totalConSignoCorrecto);
                                
                                // Agregar título principal CONSOLIDADO CON TOTAL
                                datosConciliacion.push(['(-) CHEQUES NO COBRADOS', '', '', '', totalConSignoCorrecto, '', '', '', '', '']);
                                
                                // Agregar todos los detalles consolidados
                                todosChequesDetalles.forEach(cheque => {
                                    datosConciliacion.push(cheque);
                                });
                            } else {
                                console.warn('⚠️ No se encontraron cheques no cobrados');
                                datosConciliacion.push(['']);
                                datosConciliacion.push(['(-) CHEQUES NO COBRADOS', '', '', '', 0, '', '', '', '', '']);
                            }
                        }
                        
                        // DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS CONSOLIDADOS (PARTE 1 + PARTE 2 + PARTE 3 + PARTE 4)
                        //console.log('🔍 [DEBUG] Iniciando cálculo consolidado de Depósitos en Bancos No Registrados en Libros');
                        
                        let totalDepositosBancosConsolidado = 0;
                        let todosDepositosBancosDetalles = [];
                        
                        // PARTE 1: DEPOSITOS EN BANCOS DESDE EXTRACT DINÁMICO
                        //console.log(`🔍 [DEBUG] Procesando Depósitos en Bancos - Parte 1 desde ${nombrePestaña} Extract`);
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.extractos && window.datosHojaTrabajoJSON.extractos[codigoCuentaActual]) {
                            //console.log(`🔍 [DEBUG] Datos ${nombrePestaña} Extract disponibles:`, window.datosHojaTrabajoJSON.extractos[codigoCuentaActual].length, 'filas');
                            
                            const datosExtracto = window.datosHojaTrabajoJSON.extractos[codigoCuentaActual];
                            
                            // Buscar columnas ESTADO, MONTO/IMPORTE y FECHA
                            const headers = datosExtracto[0];
                            const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ESTADO'));
                            let montoCol = headers.findIndex(h => h && (h.toString().toUpperCase().includes('MONTO') || h.toString().toUpperCase().includes('IMPORTE')));
                            const fechaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FECHA'));
                            
                            // CORRECCIÓN PARA BBVA: Buscar también "F. OPERACION" y "F. VALOR"
                            let fechaColBBVA = fechaCol;
                            if ((nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') && fechaCol === -1) {
                                fechaColBBVA = headers.findIndex(h => h && (
                                    h.toString().toUpperCase().includes('F. OPERACION') ||
                                    h.toString().toUpperCase().includes('F. VALOR') ||
                                    h.toString().toUpperCase().includes('OPERACION') ||
                                    h.toString().toUpperCase().includes('VALOR')
                                ));
                                //console.log('🔍 [DEBUG BBVA] Búsqueda alternativa de fecha:', fechaColBBVA);
                            }
                            
                            // Usar la columna de fecha correcta
                            const fechaColFinal = (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') ? fechaColBBVA : fechaCol;
                            
                            // DEBUG específico para BBVA
                            if (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') {
                                //console.log('🔍 [DEBUG BBVA] Headers encontrados:', headers);
                                //console.log('🔍 [DEBUG BBVA] Búsqueda de FECHA:', fechaCol);
                                //console.log('🔍 [DEBUG BBVA] Headers que contienen FECHA:', headers.filter(h => h && h.toString().toUpperCase().includes('FECHA')));
                                //console.log('🔍 [DEBUG BBVA] Headers que contienen OPERACION:', headers.filter(h => h && h.toString().toUpperCase().includes('OPERACION')));
                                //console.log('🔍 [DEBUG BBVA] Headers que contienen VALOR:', headers.filter(h => h && h.toString().toUpperCase().includes('VALOR')));
                            }
                            
                            // Para IBK: usar CARGO y ABONO en lugar de MONTO
                            const cargoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CARGO'));
                            const abonoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ABONO'));
                            const esIBK = (cargoCol !== -1 && abonoCol !== -1 && montoCol === -1);
                            
                            //console.log('🔍 [DEBUG] Columnas encontradas - ESTADO:', estadoCol, 'MONTO/IMPORTE:', montoCol, 'FECHA:', fechaCol, 'FECHA_FINAL:', fechaColFinal);
                            if (esIBK) {
                                //console.log('🔍 [DEBUG] Detectado IBK - CARGO:', cargoCol, 'ABONO:', abonoCol);
                            }
                            //console.log('🔍 [DEBUG] Headers completos:', headers);
                            //console.log('🔍 [DEBUG] Primeros 3 registros de muestra:', datosExtracto.slice(1, 4));
                            
                            if (estadoCol !== -1 && (montoCol !== -1 || esIBK)) {
                                // Filtrar depósitos Parte 1: Estado=Pendiente, Monto>0
                                const depositosParte1 = datosExtracto.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    
                                    if (esIBK) {
                                        // Para IBK: usar ABONO para depósitos (monto positivo)
                                        const abono = parseFloat(item[abonoCol]) || 0;
                                        return item[estadoCol] === 'Pendiente' && abono > 0;
                                    } else {
                                        // Para otros bancos: usar MONTO
                                        return item[estadoCol] === 'Pendiente' &&
                                               parseFloat(item[montoCol]) > 0;
                                    }
                                });
                                
                                //console.log('🔍 [DEBUG] Depósitos Parte 1 encontrados:', depositosParte1.length);
                                
                                
                                const totalParte1 = depositosParte1.reduce((sum, item) => {
                                    const monto = esIBK ? (parseFloat(item[abonoCol]) || 0) : (parseFloat(item[montoCol]) || 0);
                                    return sum + monto;
                                }, 0);
                                totalDepositosBancosConsolidado += totalParte1;
                                //console.log('🔍 [DEBUG] Total Parte 1 calculado:', totalParte1);
                                
                                // Agregar detalles de Parte 1
                                depositosParte1.forEach(deposito => {
                                    const montoDeposito = esIBK ? (parseFloat(deposito[abonoCol]) || 0) : (parseFloat(deposito[montoCol]) || 0);
                                    
                                    // Usar mapeo de columnas correcto para BBVA, SBP e IBK
                                    let concepto, ref;
                                    if (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') {
                                        concepto = deposito[4] || '';  // Columna E (Concepto)
                                        ref = deposito[3] || '';       // Columna D (Nº. Doc.)
                                    } else if (nombrePestaña === 'SBP' || nombrePestaña === 'SBP.USD') {
                                        concepto = deposito[1] || '';  // Columna B (Movimiento)
                                        ref = deposito[3] || '';       // Columna D (Referencia)
                                    } else if (nombrePestaña === 'IBK' || nombrePestaña === 'IBK.USD') {
                                        /*Cambio solicitado: OBSERVACIÓN 1 - Cambiar columna D por C en campo concepto para IBK - 27102025 19:47*/
                                        concepto = deposito[2] || '';  // Columna C (Nro. de operación)
                                        ref = deposito[1] || '';       // Columna B (Fecha proceso)
                                    } else {
                                        concepto = deposito[2] || '';  // Columna C (descripción)
                                        ref = deposito[6] || '';       // Columna G (Nro de Operación)
                                    }
                                    
                                    const filaDeposito = [
                                        fechaColFinal !== -1 ? this.formatearFecha(deposito[fechaColFinal]) : '',  // 1. Fecha
                                        concepto,                       // 2. Concepto (usando mapeo correcto)
                                        ref,                           // 3. REF (usando mapeo correcto)
                                        montoDeposito,                 // 4. Importe
                                        'PARTE 1'                      // 5. Parte
                                    ];
                                    todosDepositosBancosDetalles.push(filaDeposito);
                                });
                            } else {
                                console.warn(`⚠️ No se encontraron columnas ESTADO o MONTO en ${nombrePestaña} Extract`);
                            }
                        } else {
                            console.warn(`⚠️ window.datosHojaTrabajoJSON.extractos[${codigoCuentaActual}] no está disponible para Parte 1`);
                        }
                        
                        /*Cambio solicitado: OBSERVACIÓN 5 - Comentar PARTE 2 de DEPOSITOS EN BANCOS - 27102025 20:02*/
                        
                        // PARTE 2: DEPOSITOS EN BANCOS DESDE TARJETAS
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Bancos - Parte 2 desde TARJETAS');
                        // OBSERVACIÓN 3 - Usar función duplicada específica para PARTE 2 - 27102025 19:52
                        try {

                            //console.error('🔍 [DEBUG] codigoCuentaActual:', codigoCuentaActual);
                            ////console.error('🔍 [DEBUG] datosTarjetas:', datosTarjetas);
                            ////console.error('🔍 [DEBUG] nombrePestaña:', nombrePestaña);

                            // Ver registros omitidos del PASO 2 (fuente de TARJETAS)
                            ////console.error('📊 [TARJETAS RAW] Registros omitidos Paso 2:', window.registrosOmitidosPaso2);
                           // //console.error('📊 [TARJETAS RAW] Total registros:', window.registrosOmitidosPaso2?.length || 0);

                            //const datosTarjetas = this.generarDatosTarjetasDepositosBancosParte2(codigoCuentaActual, nombrePestaña);
                            const datosTarjetas= this.generarDatosTarjetas();
                            // Ver datos procesados de TARJETAS
                            ////console.error('📊 [TARJETAS PROCESADAS] Datos datosTarjetasXX:', datosTarjetasXX);
                            ////console.error('📊 [TARJETAS PROCESADAS] Total filas:', datosTarjetas?.length || 0);
                            
                            
                            if (datosTarjetas && datosTarjetas.length > 0) {
                               
                                
                                // Filtrar depósitos Parte 2: Cuenta dinámica, FUENTE distinta a MAYOR
                                const depositosParte2 = datosTarjetas.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    
                                    return item[0] === codigoCuentaActual &&    // CUENTA - dinámico
                                        !item[6]?.startsWith("MAYOR");                // FUENTE - distinta a MAYOR
                                });
                                
                               // //console.error('📊 [TARJETAS PROCESADAS] Datos completos 2:', depositosParte2);
                                
                                
                                const totalParte2 = depositosParte2.reduce((sum, item) => sum + (parseFloat(item[4]) || 0), 0);
                                totalDepositosBancosConsolidado += totalParte2;
                               
                            

                                // Agregar detalles de Parte 2
                                depositosParte2.forEach(deposito => {
                                    // Usar fecha del formulario mesAnoTarjetas para TARJETAS
                                    let fechaTarjetas = '';
                                    if (this.mesAnoTarjetas) {
                                        // Convertir formato YYYY-MM a DD/MM/YYYY
                                        const [año, mes] = this.mesAnoTarjetas.split('-');
                                        fechaTarjetas = `01/${mes}/${año}`;
                                    }
                                    
                                    ////console.log('🔍 [DEBUG] mesAnoTarjetas:', this.mesAnoTarjetas);
                                    ////console.log('🔍 [DEBUG] fechaTarjetas formateada:', fechaTarjetas);
                                    ////console.error('🔍 [DEBUG] deposito:', deposito);
                                    const filaDeposito = [
                                        fechaTarjetas,                    // 1. Fecha
                                        deposito[3] || '',               // 2. Operación (GLOSA)
                                        deposito[1] || '',               // 3. Nro de Operación (NUMDOC)
                                        parseFloat(deposito[4]) || 0,   // 4. Importe (DEBE)
                                        'PARTE 2'                          // 5. Parte
                                    ];
                                    todosDepositosBancosDetalles.push(filaDeposito);
                                });
                            } else {
                                console.warn('⚠️ No se pudieron generar datos TARJETAS para Parte 2');
                            }
                        } catch (error) {
                            //console.error('❌ Error generando datos TARJETAS para Parte 2:', error);
                        }
                        
                        
                        // PARTE 3: DEPOSITOS EN BANCOS DESDE SALDO
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Bancos - Parte 3 desde SALDO');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            const depositosBancosParte3 = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                const estado = item['ESTADO'] || '';
                                
                                return cuenta.toString() === codigoCuentaActual && 
                                       concepto === '(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS' &&
                                       estado === 'Pendiente';
                            });
                            
                            //console.log('🔍 [DEBUG] Depósitos Bancos Parte 3 encontrados:', depositosBancosParte3.length);
                            
                            const totalParte3 = depositosBancosParte3.reduce((sum, item) => {
                                return sum + (parseFloat(item['HABER']) || 0);
                            }, 0);
                            totalDepositosBancosConsolidado += totalParte3;
                            //console.log('🔍 [DEBUG] Total Parte 3 calculado:', totalParte3);
                            
                            // Agregar detalles de Parte 3
                            depositosBancosParte3.forEach(deposito => {
                                const filaDeposito = [
                                    this.formatearFecha(deposito['FDOC']),  // 1. Fecha
                                    deposito['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    deposito['NUMDOC'] || '',              // 3. Nro de Operación (NUMDOC)
                                    parseFloat(deposito['HABER']) || 0,   // 4. Importe
                                    'PARTE 3'                               // 5. Parte
                                ];
                                todosDepositosBancosDetalles.push(filaDeposito);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Depósitos en Bancos Parte 3');
                        }
                       
                        
                        // Agregar título consolidado y todos los detalles
                        if (totalDepositosBancosConsolidado > 0 || todosDepositosBancosDetalles.length > 0) {
                            //console.log('🔍 [DEBUG] Total consolidado calculado:', totalDepositosBancosConsolidado);
                            
                            // Agregar línea en blanco para diferenciación visual
                            datosConciliacion.push(['']);
                            
                            // CORRECCIÓN DE SIGNO: Para conceptos (-), el total debe ser negativo
                            const totalConSignoCorrecto = -Math.abs(totalDepositosBancosConsolidado);
                            //console.log('🔍 [DEBUG] Total con signo corregido:', totalConSignoCorrecto);
                            
                            // Agregar título principal CONSOLIDADO CON TOTAL
                            datosConciliacion.push(['(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS', '', '', '', totalConSignoCorrecto]);
                            
                            // Agregar todos los detalles consolidados
                            todosDepositosBancosDetalles.forEach(deposito => {
                                datosConciliacion.push(deposito);
                            });
                        } else {
                            console.warn('⚠️ No se encontraron depósitos en bancos');
                            datosConciliacion.push(['']);
                            datosConciliacion.push(['(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS', '', '', '', 0]);
                        }
                        
                        // DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS CONSOLIDADOS (PARTE 1 + PARTE 2 + PARTE 3 + PARTE 4)
                        //console.log('🔍 [DEBUG] Iniciando cálculo consolidado de Depósitos en Libros No Registrados en Bancos');
                        
                        let totalDepositosLibrosConsolidado = 0;
                        let todosDepositosLibrosDetalles = [];
                        
                        // PARTE 1: DEPOSITOS EN LIBROS DESDE SALDO
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Libros - Parte 1 desde SALDO');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            const depositosParte1 = datosMapeados.filter(item => {
                                return item['CUENTA'] === codigoCuentaActual &&
                                       item['ESTADO'] === 'Pendiente' &&
                                       item['Concepto Reporte Final'] === '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS' &&
                                       item['DEBE'] > 0;
                            });
                            
                            //console.log('🔍 [DEBUG] Depósitos Parte 1 encontrados:', depositosParte1.length);
                            
                            const totalParte1 = depositosParte1.reduce((sum, item) => sum + (parseFloat(item['DEBE']) || 0), 0);
                            totalDepositosLibrosConsolidado += totalParte1;
                            //console.log('🔍 [DEBUG] Total Parte 1 calculado:', totalParte1);
                            
                            // Agregar detalles de Parte 1
                            depositosParte1.forEach(deposito => {
                                const filaDeposito = [
                                    this.formatearFecha(deposito['FDOC']),  // 1. Fecha
                                    deposito['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    deposito['NUMDOC'] || '',               // 3. Nro de Operación (NUMDOC)
                                    parseFloat(deposito['DEBE']) || 0,     // 4. Importe (DEBE)
                                    'PARTE 1'                              // 5. Parte
                                ];
                                todosDepositosLibrosDetalles.push(filaDeposito);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Parte 1');
                        }
                        
                        // PARTE 2: DEPOSITOS EN LIBROS DESDE TARJETAS
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Libros - Parte 2 desde TARJETAS');
                        
                        try {
                            const datosTarjetas = this.generarDatosTarjetas(codigoCuentaActual, nombrePestaña);
                            if (datosTarjetas && datosTarjetas.length > 0) {
                                //console.log('🔍 [DEBUG] Datos TARJETAS disponibles:', datosTarjetas.length, 'filas');
                                
                                // Filtrar depósitos Parte 2: Cuenta dinámica, FUENTE dinámico según moneda
                                const esCuentaUSD = ['1041502', '1041402', '1041202', '1041302', '1041102'].includes(codigoCuentaActual);
                                const fuenteMayor = esCuentaUSD ? 'MAYOR.USD' : 'MAYOR.PEN';
                                
                                const depositosParte2 = datosTarjetas.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    return item[0] === codigoCuentaActual &&    // CUENTA - dinámico
                                           item[6] === fuenteMayor;              // FUENTE - dinámico según moneda
                                });
                                
                                //console.log(`🔍 [DEBUG] Depósitos Parte 2 encontrados: ${depositosParte2.length} (usando ${fuenteMayor} para cuenta ${codigoCuentaActual})`);
                                
                                const totalParte2 = depositosParte2.reduce((sum, item) => sum + (parseFloat(item[4]) || 0), 0);
                                totalDepositosLibrosConsolidado += totalParte2;
                                //console.log('🔍 [DEBUG] Total Parte 2 calculado:', totalParte2);
                                
                                // Agregar detalles de Parte 2
                                depositosParte2.forEach(deposito => {
                                    // Usar fecha del formulario mesAnoTarjetas para TARJETAS
                                    let fechaTarjetas = '';
                                    if (this.mesAnoTarjetas) {
                                        // Convertir formato YYYY-MM a DD/MM/YYYY
                                        const [año, mes] = this.mesAnoTarjetas.split('-');
                                        fechaTarjetas = `01/${mes}/${año}`;
                                    }
                                    
                                    const filaDeposito = [
                                        fechaTarjetas,                    // 1. Fecha
                                        deposito[3] || '',               // 2. Operación (GLOSA)
                                        deposito[1] || '',               // 3. Nro de Operación (NUMDOC)
                                        parseFloat(deposito[4]) || 0,   // 4. Importe (DEBE)
                                        'PARTE 2'                          // 5. Parte
                                    ];
                                    todosDepositosLibrosDetalles.push(filaDeposito);
                                });
                            } else {
                                console.warn('⚠️ No se pudieron generar datos TARJETAS para Parte 2');
                            }
                        } catch (error) {
                            //console.error('❌ Error generando datos TARJETAS para Parte 2:', error);
                        }
                        
                        // PARTE 3: DEPOSITOS EN LIBROS DESDE MAYOR (PEN o USD según cuenta)
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Libros - Parte 3 desde MAYOR');
                        
                        // Determinar si es cuenta USD y qué datos usar para DEPOSITOS
                        const esCuentaUSDDepositos = ['1041502', '1041402', '1041202', '1041302', '1041102'].includes(codigoCuentaActual);
                        const datosMayorParaUsarDepositos = esCuentaUSDDepositos ? 'mayorUSD' : 'mayor';
                        const nombreMayorParaUsarDepositos = esCuentaUSDDepositos ? 'MAYOR.USD' : 'MAYOR.PEN';
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON[datosMayorParaUsarDepositos] && Array.isArray(window.datosHojaTrabajoJSON[datosMayorParaUsarDepositos])) {
                            //console.log(`🔍 [DEBUG] Datos ${nombreMayorParaUsarDepositos} disponibles:`, window.datosHojaTrabajoJSON[datosMayorParaUsarDepositos].length, 'filas');
                            
                            const datosMayor = window.datosHojaTrabajoJSON[datosMayorParaUsarDepositos];
                            
                            // Filtrar depósitos Parte 3: Cuenta dinámica, Estado=Pendiente, DEBE>0
                            const depositosParte3 = datosMayor.filter((item, index) => {
                                if (index === 0) return false; // Skip headers
                                return item[7] === codigoCuentaActual &&    // CUENTA (índice 7) - dinámico
                                       item[14] === 'Pendiente' &&  // ESTADO (índice 14)
                                       item[12] > 0;                // DEBE (índice 12)
                            });
                            
                            //console.log(`🔍 [DEBUG] Depósitos Parte 3 encontrados: ${depositosParte3.length} (usando ${nombreMayorParaUsarDepositos} para cuenta ${codigoCuentaActual})`);
                            
                            const totalParte3 = depositosParte3.reduce((sum, item) => sum + (parseFloat(item[12]) || 0), 0);
                            totalDepositosLibrosConsolidado += totalParte3;
                            //console.log('🔍 [DEBUG] Total Parte 3 calculado:', totalParte3);
                            
                            // Agregar detalles de Parte 3
                            depositosParte3.forEach(deposito => {
                                const filaDeposito = [
                                    this.formatearFecha(deposito[2]),  // 1. Fecha (FDOC)
                                    deposito[11] || '',               // 2. Operación (GLOSA)
                                    deposito[1] || '',               // 3. Nro de Operación (NUMDOC)
                                    parseFloat(deposito[12]) || 0,   // 4. Importe (DEBE)
                                    'PARTE 3'                          // 5. Parte
                                ];
                            todosDepositosLibrosDetalles.push(filaDeposito);
                        });
                    }
                    
                    // PARTE 4: DEPOSITOS EN LIBROS DESDE SALDO (Concepto específico) - SOLO PARA CUENTAS DISTINTAS A BCP/1041501
                    if (nombrePestaña !== 'BCP' && codigoCuentaActual !== '1041501') {
                        //console.log('🔍 [DEBUG] Procesando Depósitos en Libros - Parte 4 desde SALDO (excluye BCP/1041501)');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles para Parte 4:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            //console.log("--------------------------------ROY:::" + codigoCuentaActual);
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            const depositosParte4 = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                const estado = item['ESTADO'] || '';
                                
                                return cuenta.toString() === codigoCuentaActual && 
                                       concepto === '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS' &&
                                       estado === 'Pendiente';
                            });
                            
                            //console.log('🔍 [DEBUG] Depósitos Parte 4 encontrados:', depositosParte4.length);
                            
                            const totalParte4 = depositosParte4.reduce((sum, item) => {
                                return sum + Math.abs(parseFloat(item['DEBE']) || 0);
                            }, 0);
                            totalDepositosLibrosConsolidado += totalParte4;
                            //console.log('🔍 [DEBUG] Total Parte 4 calculado:', totalParte4);
                            
                            // Agregar detalles de Parte 4
                            depositosParte4.forEach(deposito => {
                                const filaDeposito = [
                                    this.formatearFecha(deposito['FDOC']),  // 1. Fecha
                                    deposito['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    deposito['NUMDOC'] || '',              // 3. Nro de Operación (NUMDOC)
                                    Math.abs(parseFloat(deposito['DEBE']) || 0),   // 4. Importe (DEBE para DEPOSITOS EN LIBROS)
                                    'PARTE 4'                              // 5. Parte
                                ];
                                todosDepositosLibrosDetalles.push(filaDeposito);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Depósitos en Libros Parte 4');
                        }
                    } else {
                        //console.log('🔍 [DEBUG] Parte 4 omitida: Es BCP o cuenta 1041501');
                    }
                    
                    // Agregar título consolidado y todos los detalles
                    if (totalDepositosLibrosConsolidado > 0 || todosDepositosLibrosDetalles.length > 0) {
                            //console.log('🔍 [DEBUG] Total consolidado calculado:', totalDepositosLibrosConsolidado);
                            
                            // Agregar línea en blanco para diferenciación visual
                            datosConciliacion.push(['']);
                            
                            // Agregar título principal CONSOLIDADO CON TOTAL
                            datosConciliacion.push(['(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS', '', '', '', totalDepositosLibrosConsolidado]);
                            
                            // Agregar todos los detalles consolidados
                            todosDepositosLibrosDetalles.forEach(deposito => {
                                datosConciliacion.push(deposito);
                            });
                        } else {
                            console.warn('⚠️ No se encontraron depósitos en libros');
                            datosConciliacion.push(['']);
                            datosConciliacion.push(['(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS', '', '', '', 0]);
                        }
                        
                        // CARGO EN BANCOS NO REGISTRADO EN LIBROS CONSOLIDADOS (PARTE 1 + PARTE 2 + PARTE 3)
                        //console.log('🔍 [DEBUG] Iniciando cálculo consolidado de Cargo en Bancos No Registrado en Libros');
                        
                        let totalCargosBancosConsolidado = 0;
                        let todosCargosBancosDetalles = [];
                        
                        // PARTE 1: CARGO EN BANCOS DESDE EXTRACTOS
                        //console.log(`🔍 [DEBUG] Procesando Cargo en Bancos - Parte 1 desde ${nombrePestaña} Extract`);
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.extractos && window.datosHojaTrabajoJSON.extractos[codigoCuentaActual]) {
                            //console.log(`🔍 [DEBUG] Datos ${nombrePestaña} Extract disponibles para Cargo en Bancos:`, window.datosHojaTrabajoJSON.extractos[codigoCuentaActual].length, 'filas');
                            
                            const datosExtracto = window.datosHojaTrabajoJSON.extractos[codigoCuentaActual];
                            
                            // Buscar columnas ESTADO, MONTO/IMPORTE y FECHA
                            const headers = datosExtracto[0];
                            const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ESTADO'));
                            let montoCol = headers.findIndex(h => h && (h.toString().toUpperCase().includes('MONTO') || h.toString().toUpperCase().includes('IMPORTE')));
                            const fechaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FECHA'));
                            
                            // CORRECCIÓN PARA BBVA: Buscar también "F. OPERACION" y "F. VALOR"
                            let fechaColBBVA = fechaCol;
                            if ((nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') && fechaCol === -1) {
                                fechaColBBVA = headers.findIndex(h => h && (
                                    h.toString().toUpperCase().includes('F. OPERACION') ||
                                    h.toString().toUpperCase().includes('F. VALOR') ||
                                    h.toString().toUpperCase().includes('OPERACION') ||
                                    h.toString().toUpperCase().includes('VALOR')
                                ));
                                //console.log('🔍 [DEBUG BBVA CARGO] Búsqueda alternativa de fecha:', fechaColBBVA);
                            }
                            
                            // Usar la columna de fecha correcta
                            const fechaColFinal = (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') ? fechaColBBVA : fechaCol;
                            
                            // Para IBK: usar CARGO y ABONO en lugar de MONTO
                            const cargoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CARGO'));
                            const abonoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('ABONO'));
                            const esIBK = (cargoCol !== -1 && abonoCol !== -1 && montoCol === -1);
                            
                            //console.log('🔍 [DEBUG] Columnas encontradas - ESTADO:', estadoCol, 'MONTO/IMPORTE:', montoCol, 'FECHA:', fechaCol, 'FECHA_FINAL:', fechaColFinal);
                            if (esIBK) {
                                //console.log('🔍 [DEBUG] Detectado IBK - CARGO:', cargoCol, 'ABONO:', abonoCol);
                            }
                            
                            if (estadoCol !== -1 && (montoCol !== -1 || esIBK)) {
                                // Filtrar cargos bancos: Estado=Pendiente, Monto<0
                                const cargosBancosParte1 = datosExtracto.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    
                                    if (esIBK) {
                                        // Para IBK: usar CARGO para cargos (monto negativo)
                                        const cargo = parseFloat(item[cargoCol]) || 0;
                                        return item[estadoCol] === 'Pendiente' && cargo < 0;
                                    } else {
                                        // Para otros bancos: usar MONTO
                                        return item[estadoCol] === 'Pendiente' &&
                                               parseFloat(item[montoCol]) < 0;
                                    }
                                });
                                
                                //console.log('🔍 [DEBUG] Cargos Bancos Parte 1 encontrados:', cargosBancosParte1.length);
                                
                                const totalParte1 = cargosBancosParte1.reduce((sum, item) => {
                                    const monto = esIBK ? (parseFloat(item[cargoCol]) || 0) : (parseFloat(item[montoCol]) || 0);
                                    return sum + Math.abs(monto);
                                }, 0);
                                totalCargosBancosConsolidado += totalParte1;
                                //console.log('🔍 [DEBUG] Total Parte 1 calculado:', totalParte1);
                                
                                // Agregar detalles de Parte 1
                                cargosBancosParte1.forEach(cargo => {
                                    const montoCargo = esIBK ? (parseFloat(cargo[cargoCol]) || 0) : (parseFloat(cargo[montoCol]) || 0);
                                    
                                    // Usar mapeo de columnas correcto para BBVA, SBP e IBK
                                    let concepto, ref;
                                    if (nombrePestaña === 'BBVA' || nombrePestaña === 'BBVA.USD') {
                                        concepto = cargo[4] || '';  // Columna E (Concepto)
                                        ref = cargo[3] || '';       // Columna D (Nº. Doc.)
                                    } else if (nombrePestaña === 'SBP' || nombrePestaña === 'SBP.USD') {
                                        concepto = cargo[1] || '';  // Columna B (Movimiento)
                                        ref = cargo[3] || '';       // Columna D (Referencia)
                                    } else if (nombrePestaña === 'IBK' || nombrePestaña === 'IBK.USD') {
                                        /*Cambio solicitado: OBSERVACIÓN 1 - Cambiar columna D por C en campo concepto para IBK - 27102025 19:47*/
                                        concepto = cargo[2] || '';  // Columna C (Nro. de operación)
                                        ref = cargo[1] || '';       // Columna B (Fecha proceso)
                                    } else {
                                        concepto = cargo[2] || '';  // Columna C (descripción)
                                        ref = cargo[6] || '';       // Columna G (Nro de Operación)
                                    }
                                    
                                    const filaCargo = [
                                        fechaColFinal !== -1 ? this.formatearFecha(cargo[fechaColFinal]) : '',  // 1. Fecha
                                        concepto,                       // 2. Concepto (usando mapeo correcto)
                                        ref,                           // 3. REF (usando mapeo correcto)
                                        Math.abs(montoCargo),          // 4. Importe (signo positivo para CARGO EN BANCOS)
                                        'PARTE 1'                      // 5. Parte
                                    ];
                                    todosCargosBancosDetalles.push(filaCargo);
                                });
                            } else {
                                console.warn(`⚠️ No se encontraron columnas ESTADO o MONTO en ${nombrePestaña} Extract`);
                            }
                        } else {
                            console.warn(`⚠️ window.datosHojaTrabajoJSON.extractos[${codigoCuentaActual}] no está disponible para Cargo en Bancos Parte 1`);
                        }
                        
                        // PARTE 2: CARGO EN BANCOS DESDE SALDO
                        //console.log('🔍 [DEBUG] Procesando Cargo en Bancos - Parte 2 desde SALDO');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            // DEBUG: Mostrar algunos registros para diagnóstico
                            //console.log('🔍 [DEBUG PARTE 2] Total registros en datosMapeados:', datosMapeados.length);
                            //console.log('🔍 [DEBUG PARTE 2] codigoCuentaActual:', codigoCuentaActual);
                            
                            // Mostrar los primeros 3 registros para ver la estructura
                            datosMapeados.slice(0, 3).forEach((item, index) => {
                                //console.log(`🔍 [DEBUG PARTE 2] Registro ${index + 1}:`, {
                                    cuenta: item['CUENTA'],
                                    concepto: item['Concepto Reporte Final'],
                                    estado: item['ESTADO'],
                                    debe: item['DEBE']
                                });
                            });
                            /*
                            const cargosBancosParte2 = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                const estado = item['ESTADO'] || '';
                                
                                // DEBUG: Log detallado para cada registro que coincida parcialmente
                                if (cuenta.toString() === codigoCuentaActual) {
                                    //console.log('🔍 [DEBUG PARTE 2] Registro con cuenta coincidente:', {
                                        cuenta: cuenta,
                                        concepto: concepto,
                                        estado: estado,
                                        conceptoMatch: concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                                        estadoMatch: estado === 'Pendiente'
                                    });
                                }
                                
                                return cuenta.toString() === codigoCuentaActual && 
                                       concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS' &&
                                       estado === 'Pendiente';
                            });
                            */

                            const cargosBancosParte2 = datosMapeados.filter(item => {
                            const concepto = (item['Concepto Reporte Final'] || '').trim().toUpperCase();
                            const cuenta = (item['CUENTA'] || '').toString();
                            const estado = (item['ESTADO'] || '').trim();

                            // Acepta "REGISTRADO" o "REGISTRADOS"
                            const esConceptoValido =
                                concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS' ||
                                concepto === '(+) CARGO EN BANCOS NO REGISTRADOS EN LIBROS';

                            // DEBUG: Log detallado para cada registro con cuenta coincidente
                            if (cuenta === codigoCuentaActual.toString()) {
                                /*console.log('🔍 [DEBUG PARTE 2] Registro con cuenta coincidente:', {
                                    cuenta: cuenta,
                                    conceptoOriginal: item['Concepto Reporte Final'],
                                    conceptoNormalizado: concepto,
                                    estado: estado,
                                    conceptoMatch: esConceptoValido,
                                    estadoMatch: estado === 'Pendiente'
                                });*/
                            }

                            return cuenta === codigoCuentaActual.toString() &&
                                esConceptoValido &&
                                estado === 'Pendiente';
                        });

                            
                            //console.log('🔍 [DEBUG] Cargos Bancos Parte 2 encontrados:', cargosBancosParte2.length);
                            
                            const totalParte2 = cargosBancosParte2.reduce((sum, item) => {
                                return sum + Math.abs(parseFloat(item['DEBE']) || 0);
                            }, 0);
                            totalCargosBancosConsolidado += totalParte2;
                            //console.log('🔍 [DEBUG] Total Parte 2 calculado:', totalParte2);
                            
                            // Agregar detalles de Parte 2
                            cargosBancosParte2.forEach(cargo => {
                                const filaCargo = [
                                    this.formatearFecha(cargo['FDOC']),  // 1. Fecha
                                    cargo['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    cargo['NUMDOC'] || '',              // 3. Nro de Operación (NUMDOC)
                                    Math.abs(parseFloat(cargo['DEBE']) || 0),   // 4. Importe (DEBE para CARGO EN BANCOS)
                                    'PARTE 2'                           // 5. Parte
                                ];
                                todosCargosBancosDetalles.push(filaCargo);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Cargo en Bancos Parte 2');
                        }
                        
                        /*
                        // PARTE 3 ELIMINADA - Duplicaba la Parte 2
                        //console.log('🔍 [DEBUG] Procesando Cargo en Bancos - Parte 3 desde SALDO');
                        
                        // LOG ESPECÍFICO PARA CUENTA 1041301 (SBP)
                        if (codigoCuentaActual === '1041301') {
                            //console.log('🔍 [DEBUG SBP 1041301] Iniciando Parte 3 para cuenta SBP');
                            //console.log('🔍 [DEBUG SBP 1041301] window.datosHojaTrabajoJSON.saldo disponible:', !!window.datosHojaTrabajoJSON?.saldo);
                            //console.log('🔍 [DEBUG SBP 1041301] Array.isArray:', Array.isArray(window.datosHojaTrabajoJSON?.saldo));
                            if (window.datosHojaTrabajoJSON?.saldo) {
                                //console.log('🔍 [DEBUG SBP 1041301] Total filas en saldo:', window.datosHojaTrabajoJSON.saldo.length);
                            }
                        }
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            // LOG ESPECÍFICO PARA CUENTA 1041301 (SBP) - Mostrar TODOS los registros de la cuenta
                            if (codigoCuentaActual === '1041301') {
                                const todosRegistrosSBP = datosMapeados.filter(item => {
                                    const cuenta = item['CUENTA'] || '';
                                    return cuenta === '1041301';
                                });
                                //console.log('🔍 [DEBUG SBP 1041301] TODOS los registros para cuenta 1041301:', todosRegistrosSBP.length);
                                todosRegistrosSBP.forEach((item, index) => {
                                    //console.log(`🔍 [DEBUG SBP 1041301] Registro ${index + 1}:`, {
                                        concepto: item['Concepto Reporte Final'],
                                        estado: item['ESTADO'],
                                        importe: item['Importe'],
                                        debe: item['DEBE'],
                                        haber: item['HABER']
                                    });
                                });
                            }
                            
                            // DEBUG: Mostrar todos los registros con concepto relacionado a CARGO EN BANCOS para esta cuenta
                            const registrosConCargoBancos = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                return cuenta.toString() === codigoCuentaActual && concepto.includes('CARGO EN BANCOS');
                            });
                            
                            //console.log(`🔍 [DEBUG PARTE 3] Registros con concepto CARGO EN BANCOS para cuenta ${codigoCuentaActual}:`, registrosConCargoBancos.length);
                            registrosConCargoBancos.forEach((item, index) => {
                                //console.log(`🔍 [DEBUG PARTE 3] Registro ${index + 1}:`, {
                                    concepto: item['Concepto Reporte Final'],
                                    estado: item['ESTADO'],
                                    importe: item['Importe'],
                                    fdoc: item['FDOC']
                                });
                            });

                            const cargosBancosParte3 = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                const estado = item['ESTADO'] || '';
                                
                                // LOG ESPECÍFICO PARA CUENTA 1041301 (SBP)
                                if (codigoCuentaActual === '1041301') {
                                    if (cuenta === '1041301') {
                                        //console.log('🔍 [DEBUG SBP 1041301] Registro encontrado para SBP:', {
                                            concepto: concepto,
                                            estado: estado,
                                            importe: item['Importe'],
                                            debe: item['DEBE'],
                                            conceptoMatch: concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                                            estadoMatch: estado === 'Pendiente',
                                            conceptoExacto: concepto,
                                            estadoExacto: estado,
                                            conceptoLength: concepto.length,
                                            estadoLength: estado.length,
                                            conceptoCharCodes: concepto.split('').map(c => c.charCodeAt(0)),
                                            estadoCharCodes: estado.split('').map(c => c.charCodeAt(0))
                                        });
                                    }
                                }
                                
                                // DEBUG: Log detallado para identificar el problema
                                if (cuenta.toString() === codigoCuentaActual && concepto.includes('CARGO EN BANCOS')) {
                                    //console.log('🔍 [DEBUG PARTE 3] Registro encontrado:', {
                                        cuenta: cuenta,
                                        concepto: concepto,
                                        estado: estado,
                                        codigoCuentaActual: codigoCuentaActual,
                                        conceptoMatch: concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS' || concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                                        estadoMatch: estado === 'Pendiente',
                                        importe: item['Importe']
                                    });
                                }
                                
                                return cuenta.toString() === codigoCuentaActual && 
                                       (concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS' ||
                                        concepto === '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS') &&
                                       estado === 'Pendiente';
                            });
                            
                            //console.log('🔍 [DEBUG] Cargos Bancos Parte 3 encontrados:', cargosBancosParte3.length);
                            
                            // LOG ESPECÍFICO PARA CUENTA 1041301 (SBP)
                            if (codigoCuentaActual === '1041301') {
                                //console.log('🔍 [DEBUG SBP 1041301] Cargos Bancos Parte 3 encontrados para SBP:', cargosBancosParte3.length);
                                if (cargosBancosParte3.length > 0) {
                                    //console.log('🔍 [DEBUG SBP 1041301] Detalles de los registros encontrados:', cargosBancosParte3);
                                } else {
                                    //console.log('🔍 [DEBUG SBP 1041301] NO se encontraron registros para SBP Parte 3');
                                }
                            }
                            
                            const totalParte3 = cargosBancosParte3.reduce((sum, item) => {
                                return sum + Math.abs(parseFloat(item['DEBE']) || 0);
                            }, 0);
                            totalCargosBancosConsolidado += totalParte3;
                            //console.log('🔍 [DEBUG] Total Parte 3 calculado:', totalParte3);
                            
                            // LOG ESPECÍFICO PARA CUENTA 1041301 (SBP)
                            if (codigoCuentaActual === '1041301') {
                                //console.log('🔍 [DEBUG SBP 1041301] Total Parte 3 calculado para SBP:', totalParte3);
                            }
                            
                            // Agregar detalles de Parte 3
                            cargosBancosParte3.forEach(cargo => {
                                const filaCargo = [
                                    this.formatearFecha(cargo['FDOC']),  // 1. Fecha
                                    cargo['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    cargo['NUMDOC'] || '',              // 3. Nro de Operación (NUMDOC)
                                    Math.abs(parseFloat(cargo['DEBE']) || 0),   // 4. Importe (signo positivo para CARGO EN BANCOS)
                                    'PARTE 3'                           // 5. Parte
                                ];
                                todosCargosBancosDetalles.push(filaCargo);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Cargo en Bancos Parte 3');
                        }
                        */
                        
                        // Agregar título consolidado y todos los detalles
                        if (totalCargosBancosConsolidado > 0 || todosCargosBancosDetalles.length > 0) {
                            //console.log('🔍 [DEBUG] Total consolidado calculado:', totalCargosBancosConsolidado);
                            
                            // Agregar línea en blanco para diferenciación visual
                            datosConciliacion.push(['']);
                            
                            // CORRECCIÓN DE SIGNO: Para CARGO EN BANCOS NO REGISTRADO EN LIBROS, el total debe ser positivo
                            const totalConSignoCorrecto = Math.abs(totalCargosBancosConsolidado);
                            //console.log('🔍 [DEBUG] Total con signo corregido (positivo para CARGO EN BANCOS):', totalConSignoCorrecto);
                            
                            // Agregar título principal CONSOLIDADO CON TOTAL
                            datosConciliacion.push(['(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS', '', '', '', totalConSignoCorrecto]);
                            
                            // Agregar todos los detalles consolidados
                            todosCargosBancosDetalles.forEach(cargo => {
                                datosConciliacion.push(cargo);
                            });
                        } else {
                            console.warn('⚠️ No se encontraron cargos en bancos');
                            datosConciliacion.push(['']);
                            datosConciliacion.push(['(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS', '', '', '', 0]);
                        }
                        
                        // CARGO EN LIBROS NO REGISTRADO EN BANCOS CONSOLIDADOS (PARTE 1 + PARTE 2 + PARTE 3)
                        //console.log('🔍 [DEBUG] Iniciando cálculo consolidado de Cargo en Libros No Registrado en Bancos');
                        
                        let totalCargosLibrosConsolidado = 0;
                        let todosCargosLibrosDetalles = [];
                        
                        // PARTE 1: CARGO EN LIBROS DESDE SALDO
                        //console.log('🔍 [DEBUG] Procesando Cargo en Libros - Parte 1 desde SALDO');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            const cargosLibrosParte1 = datosMapeados.filter(item => {
                                return item['CUENTA'] === codigoCuentaActual &&
                                       item['ESTADO'] === 'Pendiente' &&
                                       item['Concepto Reporte Final'] === '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS' &&
                                       item['HABER'] > 0;
                            });
                            
                            //console.log('🔍 [DEBUG] Cargos Libros Parte 1 encontrados:', cargosLibrosParte1.length);
                            
                            const totalParte1 = cargosLibrosParte1.reduce((sum, item) => sum + (parseFloat(item['HABER']) || 0), 0);
                            totalCargosLibrosConsolidado += totalParte1;
                            //console.log('🔍 [DEBUG] Total Parte 1 calculado:', totalParte1);
                            
                            // Agregar detalles de Parte 1
                            cargosLibrosParte1.forEach(cargo => {
                                const filaCargo = [
                                    this.formatearFecha(cargo['FDOC']),  // 1. Fecha
                                    cargo['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    cargo['NUMDOC'] || '',               // 3. Nro de Operación (NUMDOC)
                                    parseFloat(cargo['HABER']) || 0,   // 4. Importe (HABER)
                                    'PARTE 1'                           // 5. Parte
                                ];
                                todosCargosLibrosDetalles.push(filaCargo);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Parte 1');
                        }
                        
                        // PARTE 2: CARGO EN LIBROS DESDE MAYOR (PEN o USD según cuenta)
                        //console.log('🔍 [DEBUG] Procesando Cargo en Libros - Parte 2 desde MAYOR');
                        
                        // Determinar si es cuenta USD y qué datos usar para CARGOS
                        const esCuentaUSDCargos = ['1041502', '1041402', '1041202', '1041302', '1041102'].includes(codigoCuentaActual);
                        const datosMayorParaUsarCargos = esCuentaUSDCargos ? 'mayorUSD' : 'mayor';
                        const nombreMayorParaUsarCargos = esCuentaUSDCargos ? 'MAYOR.USD' : 'MAYOR.PEN';
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON[datosMayorParaUsarCargos] && Array.isArray(window.datosHojaTrabajoJSON[datosMayorParaUsarCargos])) {
                            //console.log(`🔍 [DEBUG] Datos ${nombreMayorParaUsarCargos} disponibles:`, window.datosHojaTrabajoJSON[datosMayorParaUsarCargos].length, 'filas');
                            
                            const datosMayor = window.datosHojaTrabajoJSON[datosMayorParaUsarCargos];
                            
                            // Filtrar cargos Parte 2: Cuenta dinámica, Estado=Pendiente, HABER>0, LIBRO != "02", sin concepto específico (son todos los cargos pendientes del mayor excepto LIBRO 02)
                            const cargosLibrosParte2 = datosMayor.filter((item, index) => {
                                if (index === 0) return false; // Skip headers
                                const libro = String(item[4] || '').trim(); // LIBRO (índice 4)
                                return item[7] === codigoCuentaActual &&    // CUENTA (índice 7) - dinámico
                                       item[14] === 'Pendiente' &&  // ESTADO (índice 14)
                                       parseFloat(item[13]) > 0 &&   // HABER (índice 13) > 0
                                       libro !== '02';               // Excluir LIBRO 02
                            });
                            
                            //console.log(`🔍 [DEBUG] Cargos Libros Parte 2 encontrados: ${cargosLibrosParte2.length} (usando ${nombreMayorParaUsarCargos} para cuenta ${codigoCuentaActual})`);
                            
                            const totalParte2 = cargosLibrosParte2.reduce((sum, item) => sum + (parseFloat(item[13]) || 0), 0);
                            totalCargosLibrosConsolidado += totalParte2;
                            //console.log('🔍 [DEBUG] Total Parte 2 calculado:', totalParte2);
                            
                            // Agregar detalles de Parte 2
                            cargosLibrosParte2.forEach(cargo => {
                                const filaCargo = [
                                    this.formatearFecha(cargo[2]),  // 1. Fecha (FDOC)
                                    cargo[11] || '',               // 2. Operación (GLOSA)
                                    cargo[1] || '',               // 3. Nro de Operación (NUMDOC)
                                    parseFloat(cargo[13]) || 0,   // 4. Importe (HABER)
                                    'PARTE 2'                       // 5. Parte
                                ];
                                todosCargosLibrosDetalles.push(filaCargo);
                            });
                        } else {
                            console.warn(`⚠️ window.datosHojaTrabajoJSON.${datosMayorParaUsarCargos} no está disponible para Cargo en Libros Parte 2`);
                        }
                        
                        // PARTE 3: CARGO EN LIBROS DESDE SALDO
                        //console.log('🔍 [DEBUG] Procesando Cargo en Libros - Parte 3 desde SALDO');
                        
                        if (window.datosHojaTrabajoJSON && window.datosHojaTrabajoJSON.saldo && Array.isArray(window.datosHojaTrabajoJSON.saldo)) {
                            //console.log('🔍 [DEBUG] Datos SALDO disponibles:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                            
                            const datosSaldo = window.datosHojaTrabajoJSON.saldo;
                            const headers = datosSaldo[0];
                            const datosMapeados = datosSaldo.slice(1).map(row => {
                                const obj = {};
                                headers.forEach((header, index) => {
                                    obj[header] = row[index];
                                });
                                return obj;
                            });

                            const cargosLibrosParte3 = datosMapeados.filter(item => {
                                const concepto = item['Concepto Reporte Final'] || '';
                                const cuenta = item['CUENTA'] || '';
                                const estado = item['ESTADO'] || '';
                                
                                return cuenta.toString() === codigoCuentaActual && 
                                       concepto === '(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS' &&
                                       estado === 'Pendiente';
                            });
                            
                            //console.log('🔍 [DEBUG] Cargos Libros Parte 3 encontrados:', cargosLibrosParte3.length);
                            
                            const totalParte3 = cargosLibrosParte3.reduce((sum, item) => {
                                return sum + (parseFloat(item['HABER']) || 0);
                            }, 0);
                            totalCargosLibrosConsolidado += totalParte3;
                            //console.log('🔍 [DEBUG] Total Parte 3 calculado:', totalParte3);
                            
                            // Agregar detalles de Parte 3
                            cargosLibrosParte3.forEach(cargo => {
                                const filaCargo = [
                                    this.formatearFecha(cargo['FDOC']),  // 1. Fecha
                                    cargo['GLOSA 1'] || '',             // 2. Operación (GLOSA 1)
                                    cargo['NUMDOC'] || '',              // 3. Nro de Operación (NUMDOC)
                                    parseFloat(cargo['HABER']) || 0,   // 4. Importe
                                    'PARTE 3'                           // 5. Parte
                                ];
                                todosCargosLibrosDetalles.push(filaCargo);
                            });
                        } else {
                            console.warn('⚠️ window.datosHojaTrabajoJSON.saldo no está disponible para Cargo en Libros Parte 3');
                        }
                        
                        /*Cambio solicitado: Agregar PARTE 4 desde TARJETAS con filtros CUENTA, FUENTE y HABER>0 - 27102025*/
                        // PARTE 4: CARGO EN LIBROS DESDE TARJETAS
                        //console.log('🔍 [DEBUG] Procesando Cargo en Libros - Parte 4 desde TARJETAS');
                        
                        try {
                            const datosTarjetas = this.generarDatosTarjetas(codigoCuentaActual, nombrePestaña);
                            if (datosTarjetas && datosTarjetas.length > 0) {
                                //console.log('🔍 [DEBUG] Datos TARJETAS disponibles para Cargos Parte 4:', datosTarjetas.length, 'filas');
                                
                                // Filtrar cargos Parte 4: Cuenta dinámica, FUENTE dinámico según moneda, HABER>0
                                /*Cambio solicitado: OBSERVACIÓN 2 - Filtrar por FUENTE MAYOR.PEN o MAYOR.USD según la cuenta - 27102025 19:45*/
                                const esCuentaUSD = ['1041502', '1041402', '1041202', '1041302', '1041102'].includes(codigoCuentaActual);
                                const fuenteMayor = esCuentaUSD ? 'MAYOR.USD' : 'MAYOR.PEN';
                                
                                const cargosParte4 = datosTarjetas.filter((item, index) => {
                                    if (index === 0) return false; // Skip headers
                                    return item[0] === codigoCuentaActual &&    // CUENTA - dinámico
                                           item[6] === fuenteMayor &&            // FUENTE - dinámico según moneda
                                           parseFloat(item[5]) > 0;              // HABER (índice 5) > 0
                                });
                                
                                //console.log(`🔍 [DEBUG] Cargos Libros Parte 4 encontrados: ${cargosParte4.length} (usando ${fuenteMayor} para cuenta ${codigoCuentaActual})`);
                                
                                const totalParte4 = cargosParte4.reduce((sum, item) => sum + (parseFloat(item[5]) || 0), 0);
                                totalCargosLibrosConsolidado += totalParte4;
                                //console.log('🔍 [DEBUG] Total Parte 4 calculado:', totalParte4);
                                
                                // Agregar detalles de Parte 4
                                cargosParte4.forEach(cargo => {
                                    // Usar fecha del formulario mesAnoTarjetas para TARJETAS
                                    let fechaTarjetas = '';
                                    if (this.mesAnoTarjetas) {
                                        // Convertir formato YYYY-MM a DD/MM/YYYY
                                        const [año, mes] = this.mesAnoTarjetas.split('-');
                                        fechaTarjetas = `01/${mes}/${año}`;
                                    }
                                    
                                    const filaCargo = [
                                        fechaTarjetas,                    // 1. Fecha
                                        cargo[3] || '',                  // 2. Operación (GLOSA)
                                        cargo[1] || '',                  // 3. Nro de Operación (NUMDOC)
                                        parseFloat(cargo[5]) || 0,       // 4. Importe (HABER)
                                        'PARTE 4'                         // 5. Parte
                                    ];
                                    todosCargosLibrosDetalles.push(filaCargo);
                                });
                            } else {
                                console.warn('⚠️ No se pudieron generar datos TARJETAS para Cargos Parte 4');
                            }
                        } catch (error) {
                            //console.error('❌ Error generando datos TARJETAS para Cargos Parte 4:', error);
                        }
                        
                        // Agregar título consolidado y todos los detalles
                        if (totalCargosLibrosConsolidado > 0 || todosCargosLibrosDetalles.length > 0) {
                            //console.log('🔍 [DEBUG] Total consolidado calculado:', totalCargosLibrosConsolidado);
                            
                            // Agregar línea en blanco para diferenciación visual
                            datosConciliacion.push(['']);
                            
                            // CORRECCIÓN DE SIGNO: Para conceptos (-), el total debe ser negativo
                            const totalConSignoCorrecto = -Math.abs(totalCargosLibrosConsolidado);
                            //console.log('🔍 [DEBUG] Total con signo corregido:', totalConSignoCorrecto);
                            
                            // Agregar título principal CONSOLIDADO CON TOTAL
                            datosConciliacion.push(['(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS', '', '', '', totalConSignoCorrecto]);
                            
                            // Agregar todos los detalles consolidados
                            todosCargosLibrosDetalles.forEach(cargo => {
                                datosConciliacion.push(cargo);
                            });
                        } else {
                            console.warn('⚠️ No se encontraron cargos en libros');
                            datosConciliacion.push(['']);
                            datosConciliacion.push(['(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS', '', '', '', 0]);
                        }
                        
                        //console.log('🔍 [CAMPOS] Procesando campos finales para', nombrePestaña, '- saldoLibros:', saldoLibros);
                        
                        // Calcular TOTAL sumando todos los conceptos principales
                        let totalConciliacion = 0;
                        let conceptosSumados = [];
                        
                        // Sumar todos los totales de conceptos que se agregaron
                        datosConciliacion.forEach(fila => {
                            if (fila.length >= 5 && fila[4] !== undefined && fila[4] !== '') {
                                // Si es una fila de concepto con total (columna 5 = índice 4)
                                const concepto = fila[0] || '';
                                const valor = parseFloat(fila[4]) || 0;
                                
                                // Solo sumar conceptos principales (no detalles de PARTE 1, 2, 3, ni SALDO EN LIBROS)
                                if (concepto && 
                                    !concepto.includes('PARTE') && 
                                    concepto !== 'SALDO EN LIBROS' &&
                                    concepto !== 'SALDO EN BANCOS' &&
                                    concepto !== 'TOTAL' &&
                                    valor !== 0) {
                                    totalConciliacion += valor;
                                    conceptosSumados.push({ concepto: concepto, valor: valor });
                                }
                            }
                        });
                        
                        // Log detallado de todos los conceptos sumados
                        //console.log('🔍 [TOTAL CONCILIACIÓN] Conceptos sumados para', nombrePestaña, ':');
                        conceptosSumados.forEach(item => {
                            //console.log(`  - ${item.concepto}: ${item.valor}`);
                        });
                        //console.log('🔍 [TOTAL CONCILIACIÓN] Subtotal conceptos:', totalConciliacion);
                        
                        // Agregar SALDO EN LIBROS al total (siempre se suma al final)
                        totalConciliacion += saldoLibros;
                        //console.log('🔍 [TOTAL CONCILIACIÓN] Saldo en libros agregado:', saldoLibros);
                        //console.log('🔍 [TOTAL CONCILIACIÓN] Total final calculado:', totalConciliacion);
                        
                        // Agregar campos finales: SALDO EN LIBROS
                        
                        datosConciliacion.push(
                            [''],                                          // Línea en blanco
                            // ['SALDO EN LIBROS', '', '', '', saldoLibros],  // Comentado - no aparece
                            ['SALDO EN LIBROS', '', '', '', totalConciliacion - saldoLibros],     // SALDO EN LIBROS con subtotal conceptos
                            // ['TOTAL', '', '', '', totalConciliacion],     // Comentado - TOTAL con saldo en libros incluido
                            // ['TOTAL', '', '', '', totalConciliacion - saldoLibros],     // Comentado - TOTAL eliminado
                            ['']
                        );
                        
                        //console.log('🔍 [CAMPOS] ✅ Campos agregados - SALDO EN LIBROS:', totalConciliacion - saldoLibros);
                        
                        // Verificar específicamente que SALDO EN BANCOS se agregó
                        const ultimasFilas = datosConciliacion.slice(-5);
                        //console.log('🔍 [CAMPOS] Últimas 5 filas para verificar SALDO EN BANCOS:', ultimasFilas);


                        // No agregar campos de diferencia ni estado
                        
                        
                        const wsConciliacion = XLSX.utils.aoa_to_sheet(datosConciliacion);
                        
                        // Agregar fórmula de sumatoria para SALDO EN LIBROS
                        // La fórmula debe sumar TODOS los campos de conciliación según la imagen:
                        // - SALDO EN BANCOS (siempre presente)
                        // - (-) CHEQUES NO COBRADOS (siempre presente)
                        // - (-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBR (si existe)
                        // - (+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS (si existe)
                        // - (+) CARGO EN BANCOS NO REGISTRADO EN LIBROS (si existe)  
                        // - (-) CARGO EN LIBROS NO REGISTRADO EN BANCOS (si existe)
                        
                        // Buscar las filas de los campos que deben sumarse de forma dinámica
                        let filaSaldoBancos = -1;
                        let filaChequesNoCobrados = -1;
                        let filaDepositosBancos = -1;
                        let filaDepositosLibros = -1;
                        let filaCargoBancos = -1;
                        let filaCargoLibros = -1;
                        let filaSaldoLibros = -1;
                        
                        // Buscar dinámicamente las filas por contenido
                        datosConciliacion.forEach((fila, index) => {
                            const concepto = fila[0] || '';
                            
                            if (concepto === 'SALDO EN BANCOS') {
                                filaSaldoBancos = index + 1; // +1 porque Excel es 1-indexado
                            } else if (concepto.includes('(-) CHEQUES NO COBRADOS')) {
                                filaChequesNoCobrados = index + 1;
                            } else if (concepto.includes('(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBR')) {
                                filaDepositosBancos = index + 1;
                            } else if (concepto.includes('(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS')) {
                                filaDepositosLibros = index + 1;
                            } else if (concepto.includes('(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS')) {
                                filaCargoBancos = index + 1;
                            } else if (concepto.includes('(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS')) {
                                filaCargoLibros = index + 1;
                            } else if (concepto === 'SALDO EN LIBROS') {
                                filaSaldoLibros = index + 1;
                            }
                        });
                        
                        // Crear la fórmula SUM de forma dinámica incluyendo TODOS los campos
                        if (filaSaldoBancos > 0 && filaSaldoLibros > 0) {
                            let formulaSum = `=E${filaSaldoBancos}`; // Empezar con SALDO EN BANCOS
                            
                            // Agregar CHEQUES NO COBRADOS (siempre debe estar)
                            if (filaChequesNoCobrados > 0) {
                                formulaSum += `+E${filaChequesNoCobrados}`;
                            }
                            
                            // Agregar DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBR (si existe)
                            if (filaDepositosBancos > 0) {
                                formulaSum += `+E${filaDepositosBancos}`;
                            }
                            
                            // Agregar DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS (si existe)
                            if (filaDepositosLibros > 0) {
                                formulaSum += `+E${filaDepositosLibros}`;
                            }
                            
                            // Agregar CARGO EN BANCOS NO REGISTRADO EN LIBROS (si existe)
                            if (filaCargoBancos > 0) {
                                formulaSum += `+E${filaCargoBancos}`;
                            }
                            
                            // Agregar CARGO EN LIBROS NO REGISTRADO EN BANCOS (si existe)
                            if (filaCargoLibros > 0) {
                                formulaSum += `+E${filaCargoLibros}`;
                            }
                            
                            // Aplicar la fórmula a la celda SALDO EN LIBROS
                            const celdaSaldoLibros = `E${filaSaldoLibros}`;
                            wsConciliacion[celdaSaldoLibros] = { f: formulaSum };
                            
                            //console.log('🔍 [FÓRMULA] ✅ Fórmula completa agregada para SALDO EN LIBROS:', formulaSum);
                            /*console.log('🔍 [FÓRMULA] Celdas encontradas dinámicamente:', {
                                saldoBancos: `E${filaSaldoBancos}`,
                                chequesNoCobrados: filaChequesNoCobrados > 0 ? `E${filaChequesNoCobrados}` : 'No encontrado',
                                depositosBancos: filaDepositosBancos > 0 ? `E${filaDepositosBancos}` : 'No encontrado',
                                depositosLibros: filaDepositosLibros > 0 ? `E${filaDepositosLibros}` : 'No encontrado',
                                cargoBancos: filaCargoBancos > 0 ? `E${filaCargoBancos}` : 'No encontrado',
                                cargoLibros: filaCargoLibros > 0 ? `E${filaCargoLibros}` : 'No encontrado',
                                saldoLibros: `E${filaSaldoLibros}`
                            });
                            */
                            
                            // Log adicional para verificar que la fórmula es realmente dinámica
                            //console.log('🔍 [FÓRMULA] 📊 Total de filas en datosConciliacion:', datosConciliacion.length);
                            //console.log('🔍 [FÓRMULA] 🔄 La fórmula incluye TODOS los campos de conciliación');
                        } else {
                            /*console.log('🔍 [FÓRMULA] ⚠️ No se pudo crear la fórmula - filas no encontradas:', {
                                filaSaldoBancos,
                                filaSaldoLibros
                            });*/
                        }
                        
                        // Configurar agrupación de filas para todas las pestañas con códigos de cuenta válidos
                        if (codigoCuentaActual) {
                            this.configurarAgrupacionCheques(wsConciliacion, datosConciliacion);
                            this.configurarCombinacionCeldasTitulos(wsConciliacion, datosConciliacion);
                        }
                        
                        XLSX.utils.book_append_sheet(wb, wsConciliacion, nombrePestaña);
                        
                        } catch (error) {
                            //console.error('❌ [ERROR] Error en conciliación para', nombrePestaña, ':', error);
                            //console.error('❌ [ERROR] Stack trace:', error.stack);
                            
                            // Agregar pestaña básica en caso de error
                            const datosBasicos = [
                                [`ERROR EN CONCILIACIÓN - ${nombrePestaña}`],
                                ['Error:', error.message || 'Error desconocido'],
                                [''],
                                ['SALDO EN BANCOS', '', '', '', 0],
                                ['SALDO EN LIBROS', '', '', '', 0]
                            ];
                            const wsBasico = XLSX.utils.aoa_to_sheet(datosBasicos);
                            XLSX.utils.book_append_sheet(wb, wsBasico, nombrePestaña);
                        }
                    }
                    
                    return this.createDownloadableFile(wb, fileName);
                } catch (error) {
                    throw error;
                }
            },

            // Función para configurar agrupación de filas para todas las secciones con detalles
            configurarAgrupacionCheques(worksheet, datosConciliacion) {
                try {
                    //console.log('🔧 [GROUPING] Configurando agrupación para todas las secciones...');
                    
                    // Lista de títulos que pueden tener agrupación
               const titulosConAgrupacion = [
                   '(-) CHEQUES NO COBRADOS',
                   '(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS',
                   '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS',
                   '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                   '(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS',
                   'SALDO EN BANCOS',
                   'SALDO EN LIBROS',
                   'TOTAL'
               ];
                    
                    // Configurar propiedades de filas para agrupación
                    if (!worksheet['!rows']) {
                        worksheet['!rows'] = [];
                    }
                    
                    // Procesar cada título
                    titulosConAgrupacion.forEach(titulo => {
                        const resultado = this.buscarSeccionConDetalles(datosConciliacion, titulo);
                        
                        //console.log(`🔍 [GROUPING] Analizando título: ${titulo}`, resultado);
                        
                        if (resultado.tieneDetalles) {
                            //console.log(`🔧 [GROUPING] Configurando agrupación para: ${titulo}`, {
                                titulo: resultado.filaTitulo,
                                inicio: resultado.filaInicioDetalles,
                                fin: resultado.filaFinDetalles,
                                totalDetalles: resultado.totalDetalles
                            });
                            
                            // Configurar fila del título (nivel 0, sin agrupar)
                            worksheet['!rows'][resultado.filaTitulo] = {
                                level: 0,
                                hidden: false
                            };
                            
                    // Configurar filas de detalles (nivel 1, agrupadas y ocultas por defecto)
                    for (let i = resultado.filaInicioDetalles; i <= resultado.filaFinDetalles; i++) {
                        worksheet['!rows'][i] = {
                            level: 1,
                            hidden: true,  // Ocultar por defecto para mostrar contraído
                            collapsed: true,  // Forzar contraído
                            outlineLevel: 1   // Nivel de esquema explícito
                        };
                    }
                    
                    // Configurar grupo específico para esta sección
                    if (!worksheet['!groups']) {
                        worksheet['!groups'] = [];
                    }
                    worksheet['!groups'].push({
                        start: resultado.filaInicioDetalles,
                        end: resultado.filaFinDetalles,
                        level: 1,
                        collapsed: true
                    });
                        } else {
                            //console.log(`ℹ️ [GROUPING] ${titulo} no tiene detalles, omitiendo agrupación`);
                        }
                    });
                    
                    // Configurar outline properties
                    worksheet['!outline'] = {
                        summaryBelow: false,  // Resumen arriba (título arriba de detalles)
                        summaryRight: false, // Resumen a la izquierda
                        collapsed: true,    // Contraído por defecto
                        autoOutline: false,  // Desactivar auto-outline
                        applyStyles: true   // Aplicar estilos de agrupación
                    };
                    
                    //console.log('✅ [GROUPING] Agrupación configurada exitosamente para todas las secciones');
                    
                } catch (error) {
                    //console.error('❌ [GROUPING] Error configurando agrupación:', error);
                }
            },

            configurarCombinacionCeldasTitulos(worksheet, datosConciliacion) {
                //console.log('🔧 [MERGE] Iniciando configuración de combinación de celdas para títulos');
                
                // Lista de títulos que necesitan combinación de celdas
                const titulosConCombinacion = [
                    '(-) CHEQUES NO COBRADOS',
                    '(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS',
                    '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS',
                    '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                    '(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS',
                    'SALDO EN BANCOS',
                    'SALDO EN LIBROS',
                    'TOTAL'
                ];
                
                // Inicializar array de merges si no existe
                if (!worksheet['!merges']) {
                    worksheet['!merges'] = [];
                }
                
                // Buscar cada título y configurar combinación de celdas
                titulosConCombinacion.forEach(titulo => {
                    const filaTitulo = datosConciliacion.findIndex(fila => 
                        fila && fila[0] && fila[0].toString().trim() === titulo
                    );
                    
                    if (filaTitulo !== -1) {
                        //console.log(`🔧 [MERGE] Combinando celdas para título: ${titulo} en fila ${filaTitulo}`);
                        
                        // Combinar celdas A hasta D (columnas 0-3) para el título
                        const mergeRange = {
                            s: { r: filaTitulo, c: 0 }, // Fila del título, columna A
                            e: { r: filaTitulo, c: 3 }   // Fila del título, columna D
                        };
                        
                        worksheet['!merges'].push(mergeRange);
                        //console.log(`✅ [MERGE] Combinación configurada: A${filaTitulo + 1}:D${filaTitulo + 1}`);
                    } else {
                        console.warn(`⚠️ [MERGE] No se encontró el título: ${titulo}`);
                    }
                });
                
                //console.log(`🔧 [MERGE] Total de combinaciones configuradas: ${worksheet['!merges'].length}`);
            },

            // Función auxiliar para buscar una sección con detalles
            buscarSeccionConDetalles(datosConciliacion, titulo) {
                let filaTitulo = -1;
                let filaInicioDetalles = -1;
                let filaFinDetalles = -1;
                let tieneDetalles = false;
                
                // Lista de títulos que pueden tener agrupación
               const titulosConAgrupacion = [
                   '(-) CHEQUES NO COBRADOS',
                   '(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS',
                   '(+) DEPOSITOS EN LIBROS NO REGISTRADOS EN BANCOS',
                   '(+) CARGO EN BANCOS NO REGISTRADO EN LIBROS',
                   '(-) CARGO EN LIBROS NO REGISTRADO EN BANCOS',
                   'SALDO EN BANCOS',
                   'SALDO EN LIBROS',
                   'TOTAL'
               ];
                
                //console.log(`🔍 [GROUPING DEBUG] Buscando título: "${titulo}"`);
                
                // Buscar la fila del título
                for (let i = 0; i < datosConciliacion.length; i++) {
                    const fila = datosConciliacion[i];
                    if (Array.isArray(fila) && fila[0] === titulo) {
                        filaTitulo = i;
                        filaInicioDetalles = i + 1;
                        //console.log(`🔍 [GROUPING DEBUG] Título encontrado en fila ${i}`);
                        break;
                    }
                }
                
                if (filaTitulo === -1) {
                    //console.log(`🔍 [GROUPING DEBUG] Título "${titulo}" NO encontrado`);
                    return { tieneDetalles: false };
                }
                
                // Buscar el final de los detalles
                for (let i = filaInicioDetalles; i < datosConciliacion.length; i++) {
                    const fila = datosConciliacion[i];
                    if (Array.isArray(fila)) {
                        // Si contiene otro título, es el final
                        if (titulosConAgrupacion.includes(fila[0])) {
                            filaFinDetalles = i - 1;
                            //console.log(`🔍 [GROUPING DEBUG] Final de detalles encontrado en fila ${i-1} (otro título)`);
                            break;
                        }
                        
                        // Si es una fila completamente vacía, es el final
                        if (fila.length === 0 || (fila[0] === '' && fila[1] === '' && fila[2] === '' && fila[3] === '')) {
                            filaFinDetalles = i - 1;
                            //console.log(`🔍 [GROUPING DEBUG] Final de detalles encontrado en fila ${i-1} (fila vacía)`);
                            break;
                        }
                    }
                }
                
                // Si no se encontró fin específico, usar hasta el final
                if (filaFinDetalles === -1) {
                    filaFinDetalles = datosConciliacion.length - 1;
                }
                
                // Verificar si tiene detalles (más de 0 filas de detalles)
                const totalDetalles = filaFinDetalles - filaInicioDetalles + 1;
                tieneDetalles = totalDetalles > 0;
                
                //console.log(`🔍 [GROUPING DEBUG] Resultado final para "${titulo}":`, {
                    filaTitulo,
                    filaInicioDetalles,
                    filaFinDetalles,
                    totalDetalles,
                    tieneDetalles
                });
                
                // Debug adicional para títulos "(-)"
                if (titulo.startsWith('(-)')) {
                    //console.log(`🔍 [GROUPING DEBUG] Título "(-)": ${titulo}`, {
                        filaTitulo,
                        filaInicioDetalles,
                        filaFinDetalles,
                        totalDetalles,
                        tieneDetalles,
                        filaTituloData: datosConciliacion[filaTitulo],
                        filaInicioData: datosConciliacion[filaInicioDetalles],
                        filaFinData: datosConciliacion[filaFinDetalles]
                    });
                    
                    // Debug específico para fechas vacías
                    if (tieneDetalles) {
                        //console.log(`🔍 [DATE DEBUG] Verificando fechas para ${titulo}:`);
                        for (let i = filaInicioDetalles; i <= Math.min(filaFinDetalles, filaInicioDetalles + 3); i++) {
                            const fila = datosConciliacion[i];
                            //console.log(`  Fila ${i}:`, {
                                fecha: fila[0],
                                concepto: fila[1],
                                ref: fila[2],
                                importe: fila[3],
                                fechaVacia: fila[0] === '' || fila[0] === undefined || fila[0] === null
                            });
                        }
                    }
                }
                
                return {
                    tieneDetalles,
                    filaTitulo,
                    filaInicioDetalles,
                    filaFinDetalles,
                    totalDetalles
                };
            },

            async generateConciliacionFile(datosCompletos, fileName) {
                try {
                    // Inicializar estructura JSON para almacenar datos de hoja de trabajo
                    window.datosHojaTrabajoJSON = {
                        saldo: [],
                        mayor: [],
                        mayorUSD: [],
                        extractos: {},
                        timestamp: new Date().toISOString(),
                        metadata: {
                            fileName: fileName,
                            tipoCambio: this.tipoCambio,
                            mesAnoTarjetas: this.mesAnoTarjetas
                        }
                    };
                    
                    //console.log('📊 [JSON] Inicializando almacenamiento de datos de hoja de trabajo');
                    
                    // Crear workbook para resultados de conciliación
                    const wb = XLSX.utils.book_new();
                    
                     
                     // HOJA 2: MAYOR.PEN PROCESADO (con estados de conciliación + pendientes LIBRO 02)
                     if (datosCompletos.datosMayor && datosCompletos.datosMayor.length > 0) {
                         // Obtener pendientes del LIBRO 02
                         const pendientesLibro02 = this.obtenerPendientesLibro02(datosCompletos);
                         
                         // Crear datos del MAYOR.PEN con pendientes agregados
                         const datosMayorCompletos = [...datosCompletos.datosMayor];
                         
                         if (pendientesLibro02.length > 0) {
                             // Agregar separador
                             datosMayorCompletos.push([]);
                             datosMayorCompletos.push(['=== PENDIENTES LIBRO 02 ===']);
                             datosMayorCompletos.push(['Filas no conciliadas que requieren revisión']);
                             datosMayorCompletos.push([]);
                             
                             // Agregar header específico para pendientes LIBRO 02
                             datosMayorCompletos.push(['FECHA', 'CONCEPTO', 'REF', 'IMPORTE', 'ESTADO']);
                             
                             // CORREGIDO: Convertir objetos pendientes a arrays con el formato correcto
                             pendientesLibro02.forEach(pendiente => {
                                 const filaArray = [
                                     pendiente.fecha || '',           // FECHA
                                     pendiente.glosa || '',           // CONCEPTO (glosa)
                                     pendiente.ref || '',             // REF
                                     pendiente.importe || 0,          // IMPORTE
                                     'Pendiente LIBRO 02'             // ESTADO
                                 ];
                                 datosMayorCompletos.push(filaArray);
                             });
                         }
                         
                         // Almacenar datos MAYOR.PEN en JSON
                         window.datosHojaTrabajoJSON.mayor = datosMayorCompletos;
                         //console.log('📊 [JSON] Almacenados datos MAYOR.PEN:', datosMayorCompletos.length, 'filas');
                         
                        const wsMayor = XLSX.utils.aoa_to_sheet(datosMayorCompletos);
                        
                        // Aplicar formato de fecha a la columna FDOC (índice 2, columna C)
                        this.aplicarFormatoFecha(wsMayor, datosMayorCompletos.length, 'C');
                        
                        XLSX.utils.book_append_sheet(wb, wsMayor, "MAYOR.PEN");
                     }
                     
                     // HOJA 3: MAYOR.USD PROCESADO
                     if (datosCompletos.datosMayorUSD && datosCompletos.datosMayorUSD.length > 0) {
                         // Almacenar datos MAYOR.USD en JSON
                         window.datosHojaTrabajoJSON.mayorUSD = datosCompletos.datosMayorUSD;
                         //console.log('📊 [JSON] Almacenados datos MAYOR.USD:', datosCompletos.datosMayorUSD.length, 'filas');
                         
                         const wsMayorUSD = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayorUSD);
                         
                         // Aplicar formato de fecha a la columna FDOC (índice 2, columna C)
                         this.aplicarFormatoFecha(wsMayorUSD, datosCompletos.datosMayorUSD.length, 'C');
                         
                         XLSX.utils.book_append_sheet(wb, wsMayorUSD, "MAYOR.USD");
                     }
                     
                     // HOJAS DE EXTRACTOS PROCESADOS
                     if (datosCompletos.extractosPorCuenta) {
                         datosCompletos.extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                             if (extractoInfo.datosExtracto && extractoInfo.datosExtracto.length > 0) {
                                 // Filtrar datos BCP.01 para eliminar términos de exclusión
                                 let datosParaAlmacenar = extractoInfo.datosExtracto;
                                 let datosParaExcel = extractoInfo.datosExtracto;
                                 
                                 if (codigoCuenta === '1041501') {
                                     //console.log(`🔍 [FILTER] Aplicando filtro de exclusión a BCP.01 (${codigoCuenta})`);
                                     //console.log(`🔍 [FILTER] Datos originales BCP.01:`, extractoInfo.datosExtracto.length, 'registros');
                                     datosParaAlmacenar = this.filtrarRegistrosExclusionBCP01(extractoInfo.datosExtracto);
                                     datosParaExcel = datosParaAlmacenar; // Usar datos filtrados también para Excel
                                     //console.log(`🔍 [FILTER] Datos filtrados BCP.01:`, datosParaAlmacenar.length, 'registros');
                                 }
                                 
                                // Almacenar datos de extracto en JSON (filtrados para BCP.01)
                                window.datosHojaTrabajoJSON.extractos[codigoCuenta] = datosParaAlmacenar;
                                //console.log(`📊 [JSON] Almacenados datos extracto ${codigoCuenta}:`, datosParaAlmacenar.length, 'filas');
                                
                                const wsExtracto = XLSX.utils.aoa_to_sheet(datosParaExcel);
                                
                                // Aplicar formato de fecha a la columna Fecha (columna A)
                                this.aplicarFormatoFecha(wsExtracto, datosParaExcel.length, 'A');
                                // Aplicar formato de fecha a la columna F. Valor (Fecha Valuta - columna B)
                                this.aplicarFormatoFecha(wsExtracto, datosParaExcel.length, 'B');
                                
                                XLSX.utils.book_append_sheet(wb, wsExtracto, extractoInfo.config.pestañaExcel);
                             }
                         });
                     }
                     
                     // HOJA: SALDO PROCESADO
                     if (datosCompletos.datosSaldo && datosCompletos.datosSaldo.length > 0) {
                         // Almacenar datos SALDO en JSON
                         window.datosHojaTrabajoJSON.saldo = datosCompletos.datosSaldo;
                         //console.log('📊 [JSON] Almacenados datos SALDO:', datosCompletos.datosSaldo.length, 'filas');
                         
                         const wsSaldo = XLSX.utils.aoa_to_sheet(datosCompletos.datosSaldo);
                         
                         // Aplicar formato de fecha a la columna FDOC (índice 4, columna E)
                         this.aplicarFormatoFecha(wsSaldo, datosCompletos.datosSaldo.length, 'E');
                         
                         XLSX.utils.book_append_sheet(wb, wsSaldo, "SALDO");
                     }
                     
                    // HOJA: TARJETAS (Resumen de registros omitidos en Paso 2)
                    window.datosCompletos = datosCompletos;
                    
                    const datosTarjetas = this.generarDatosTarjetas();
                    if (datosTarjetas && datosTarjetas.length > 0) {
                        const wsTarjetas = XLSX.utils.aoa_to_sheet(datosTarjetas);
                        XLSX.utils.book_append_sheet(wb, wsTarjetas, "TARJETAS");
                    } else {
                    }
                     
                     // Guardar el workbook para poder acceder a la pestaña SALDO después
                     this.outputWorkbook = wb;
                     
                     // Log final de datos almacenados en JSON
                     //console.log('📊 [JSON] Resumen de datos almacenados:');
                     //console.log('📊 [JSON] - SALDO:', window.datosHojaTrabajoJSON.saldo.length, 'filas');
                     //console.log('📊 [JSON] - MAYOR:', window.datosHojaTrabajoJSON.mayor.length, 'filas');
                     //console.log('📊 [JSON] - MAYOR.USD:', window.datosHojaTrabajoJSON.mayorUSD.length, 'filas');
                     //console.log('📊 [JSON] - EXTRACTOS:', Object.keys(window.datosHojaTrabajoJSON.extractos).length, 'cuentas');
                     //console.log('📊 [JSON] Datos completos:', window.datosHojaTrabajoJSON);
                     
                     // 🔧 GUARDAR DATOS EN ARCHIVO JSON PARA ANÁLISIS (DESACTIVADO)
                     // this.guardarDatosJSON(window.datosHojaTrabajoJSON);
                     
                     return this.createDownloadableFile(wb, fileName);
                 } catch (error) {
                     throw error;
                 }
             },

             // === FUNCIÓN PARA PROCESAR CHEQUES NO COBRADOS DESDE OUTPUT ===
             procesarChequesNoCobradosDesdeOutput(extractosPorCuenta) {
                 try {
                     if (!this.outputWorkbook) {
                         return;
                     }
                     
                     const saldoSheet = this.outputWorkbook.Sheets['SALDO'];
                     if (!saldoSheet) {
                         return;
                     }
                     
                     // Convertir la pestaña SALDO a array
                     const datosSaldo = XLSX.utils.sheet_to_json(saldoSheet, { header: 1, defval: '' });
                     if (!Array.isArray(datosSaldo) || datosSaldo.length === 0) {
                         return;
                     }
                     
                     // Buscar header
                     let headerIndex = -1;
                     let headers = [];
                     
                     for (let i = 0; i < datosSaldo.length; i++) {
                         const fila = datosSaldo[i];
                         if (Array.isArray(fila) && fila.some(celda => 
                             celda && celda.toString().toUpperCase().includes('CONCEPTO'))) {
                             headerIndex = i;
                             headers = fila;
                             break;
                         }
                     }
                     
                     if (headerIndex === -1) {
                         return;
                     }
                     // Buscar columnas
                     const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA'));
                     const conceptoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CONCEPTO REPORTE FINAL'));
                     const giradoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('GIRADO'));
                     const fdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FDOC'));
                     const numdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('NUMDOC'));
                     const importeCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('IMPORTE'));
                     const estadoCol = headers.findIndex(h => h && h.toString().toUpperCase() === 'ESTADO');
                     if (conceptoCol === -1 || cuentaCol === -1 || estadoCol === -1) {
                         return;
                     }
                     
                     // Procesar cada cuenta configurada
                     extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                         const chequesNoCobrados = [];
                         
                         for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                             const fila = datosSaldo[i];
                             if (!Array.isArray(fila)) continue;
                             
                             const cuenta = fila[cuentaCol]?.toString().trim();
                             const concepto = fila[conceptoCol]?.toString().trim();
                             const estado = fila[estadoCol]?.toString().trim();
                             
                             // Debug: mostrar algunas filas para entender el contenido
                             if (i <= headerIndex + 5 && cuenta === codigoCuenta) {
                             }
                             
                             // Filtrar por cuenta y concepto
                             if (cuenta === codigoCuenta && 
                                 concepto && concepto.includes('(-) CHEQUES NO COBRADOS')) {
                                 
                                 // Criterio más flexible para determinar si está pendiente (igual que en conciliador estados.html)
                                 const estaPendiente = !estado || 
                                                     estado === '' || 
                                                     estado.toString().toUpperCase().includes('PENDIENTE') ||
                                                     !estado.toString().toUpperCase().includes('CONCILIADO');
                                 
                                 if (estaPendiente) {
                                 
                                 const cheque = {
                                     cuenta: cuenta,
                                     concepto: concepto,
                                     girado: fila[giradoCol]?.toString().trim() || '',
                                     fdoc: fila[fdocCol]?.toString().trim() || '',
                                     numdoc: fila[numdocCol]?.toString().trim() || '',
                                     importe: parseFloat(fila[importeCol]) || 0,
                                     estado: estado
                                 };
                                 
                                 chequesNoCobrados.push(cheque);
                             }
                         }
                         }
                         if (chequesNoCobrados.length > 0) {
                             // Agregar los cheques no cobrados al extracto correspondiente
                             this.agregarChequesNoCobradosAlExtracto(extractoInfo, chequesNoCobrados);
                         }
                     });
                     
                 } catch (error) {
                     //console.error('❌ Error en procesarChequesNoCobradosDesdeOutput:', error);
                 }
             },

            // Nueva función que usa directamente los datos conciliados
            procesarChequesNoCobradosDesdeResultado(extractosPorCuenta) {
                if (!this.conciliationResult || !this.conciliationResult.resultado) {
                    return;
                }
                
                // Usar datosSaldo que ya contiene los estados aplicados después de la conciliación
                const datosSaldo = this.conciliationResult.resultado.datosSaldo;
                
                if (!Array.isArray(datosSaldo) || datosSaldo.length === 0) {
                    return;
                }
                try {
                    // Buscar header en datosSaldo
                    let headerIndex = -1;
                    let headers = [];
                    
                    for (let i = 0; i < datosSaldo.length; i++) {
                        const fila = datosSaldo[i];
                        if (Array.isArray(fila) && fila.some(celda => 
                            celda && celda.toString().toUpperCase().includes('CONCEPTO'))) {
                            headerIndex = i;
                            headers = fila;
                            break;
                        }
                    }
                    
                    if (headerIndex === -1) {
                        return;
                    }
                    // Encontrar índices de columnas
                    const cuentaCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CUENTA'));
                    const conceptoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('CONCEPTO'));
                    const giradoCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('GIRADO'));
                    const fdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('FDOC'));
                    const numdocCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('NUMDOC'));
                    const importeCol = headers.findIndex(h => h && h.toString().toUpperCase().includes('IMPORTE'));
                    
                    // Buscar la ÚLTIMA columna ESTADO (la conciliada, no la original)
                    let estadoCol = -1;
                    for (let i = headers.length - 1; i >= 0; i--) {
                        if (headers[i] && headers[i].toString().toUpperCase() === 'ESTADO') {
                            estadoCol = i;
                            break;
                        }
                    }
                    
                    const refCol = headers.findIndex(h => h && h.toString().toUpperCase() === '#REF');
                    if (conceptoCol === -1 || cuentaCol === -1 || estadoCol === -1) {
                        return;
                    }
                    
                    // Procesar cada cuenta configurada
                    extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                        const chequesNoCobrados = [];
                        
                        for (let i = headerIndex + 1; i < datosSaldo.length; i++) {
                            const fila = datosSaldo[i];
                            if (!Array.isArray(fila)) continue;
                            
                            const cuenta = fila[cuentaCol]?.toString().trim();
                            const concepto = fila[conceptoCol]?.toString().trim();
                            const estado = fila[estadoCol]?.toString().trim();
                            
                            // Debug: mostrar algunas filas para entender el contenido
                            if (i <= headerIndex + 5 && cuenta === codigoCuenta) {
                            }
                            
                            // Filtrar por cuenta y concepto
                            if (cuenta === codigoCuenta && 
                                concepto && concepto.includes('(-) CHEQUES NO COBRADOS')) {
                                
                                // Criterio más flexible para determinar si está pendiente
                                const estaPendiente = !estado || 
                                                    estado === '' || 
                                                    estado.toString().toUpperCase().includes('PENDIENTE') ||
                                                    !estado.toString().toUpperCase().includes('CONCILIADO');
                                
                                if (estaPendiente) {
                                    const ref = refCol !== -1 ? fila[refCol]?.toString().trim() || '' : '';
                                    const cheque = {
                                        cuenta: cuenta,
                                        concepto: concepto,
                                        girado: fila[giradoCol]?.toString().trim() || '',
                                        fdoc: fila[fdocCol]?.toString().trim() || '',
                                        numdoc: fila[numdocCol]?.toString().trim() || '',
                                        importe: parseFloat(fila[importeCol]) || 0,
                                        estado: estado,
                                        ref: ref
                                    };
                                    
                                    chequesNoCobrados.push(cheque);
                                }
                            }
                        }
                        if (chequesNoCobrados.length > 0) {
                            // Agregar los cheques no cobrados al extracto correspondiente
                            this.agregarChequesNoCobradosAlExtracto(extractoInfo, chequesNoCobrados);
                        }
                    });
                    
                } catch (error) {
                    //console.error('❌ Error en procesarChequesNoCobradosDesdeResultado:', error);
                }
            },

            // ⚠️ DESHABILITADO: agregarChequesNoCobradosAlExtracto
            // Los cheques NO van a la pestaña BCP.01 del OUTPUT CONCILIACIÓN
            // Van al OUTPUT RESUMEN en la sección "(-) CHEQUES NO COBRADOS"
            agregarChequesNoCobradosAlExtracto(extractoInfo, chequesNoCobrados) {
                // Función deshabilitada - los cheques van solo al RESUMEN
                return;
            },

             /*Cambio solicitado: OBSERVACIÓN 3 - Crear función duplicada para PARTE 2 de DEPOSITOS EN BANCOS - 27102025 19:52*/
             // Función específica para PARTE 2 de "(-) DEPOSITOS EN BANCOS NO REGISTRADOS EN LIBROS"
             generarDatosTarjetasDepositosBancosParte2(codigoCuentaActual = null, nombrePestaña = null) {
                try {
                    // Mapeo de códigos de cuenta a nombres de banco desde nomenclatura_archivos.md
                    const mapeoNomenclatura = {
                         '1041501': 'BCO DE CREDITO M/N',
                         '1041505': 'BCO DE CREDITO M/N', 
                         '1041401': 'BCO. SANTANDER M/N',
                         '1041201': 'CONTINENTAL M/N',
                         '1041301': 'SCOTIABANK MN',
                         '1041101': 'INTERBANK M/N',
                         '1042101': 'BCO. DE LA NACION DET M/N',
                         '1041601': 'BCO. DE LA NACION M/N',
                         '1041502': 'BCO DE CREDITO M/E',
                         '1041402': 'BCO. SANTANDER M/E',
                         '1041202': 'CONTINENTAL M/E',
                         '1041302': 'SCOTIABANK M/E',
                         '1041102': 'INTERBANK M/E'
                     };
                     
                     // Obtener el último día del mes seleccionado
                     const fdocCalculado = this.calcularFdocUltimoDiaMes();
                     
                     // Agrupar por término de exclusión Y cuenta
                     const resumenPorTerminoCuenta = {};
                     
                    // PROCESAR REGISTROS DEL MAYOR (PASO 2)
                    if (window.registrosOmitidosPaso2 && window.registrosOmitidosPaso2.length > 0) {
                        //console.log('🔍 [DEBUG PARTE 2] Total registros omitidos del Paso 2:', window.registrosOmitidosPaso2.length);
                        //console.log('🔍 [DEBUG PARTE 2] Registros omitidos:', window.registrosOmitidosPaso2);
                       // //console.error("window.registrosOmitidosPaso2:"+ codigoCuentaActual);
                       // //console.error(window.registrosOmitidosPaso2);
                        window.registrosOmitidosPaso2.forEach(registro => {

                            

                             const termino = registro.termino;
                             const cuenta = registro.cuenta;
                             const clave = `${termino}_${cuenta}_MAYOR`; // Clave única por término, cuenta y fuente
                             
                             if (!resumenPorTerminoCuenta[clave]) {
                                 // Usar mapeo de nomenclatura para DESCRIP
                                 const descripCorrecta = mapeoNomenclatura[cuenta] || registro.descrip;
                                 
                                 resumenPorTerminoCuenta[clave] = {
                                     cuenta: registro.cuenta,
                                     descrip: descripCorrecta,
                                     fdoc: fdocCalculado,
                                     glosa: `RESUMEN ${termino}`,
                                     debe: 0,
                                     haber: 0,
                                     cantidad: 0,
                                     fuente: 'MAYOR.PEN'
                                 };
                             }
                             
                             resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                             resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                            resumenPorTerminoCuenta[clave].cantidad += 1;
                            
                            // DEBUG: Mostrar registro específico que se está procesando
                          /*  //console.log('🔍 [DEBUG PARTE 2] Procesando registro:', {
                                cuenta: registro.cuenta,
                                termino: registro.termino,
                                glosa: registro.glosa,
                                debe: registro.debe,
                                haber: registro.haber,
                                clave: clave
                            });
                            */
                        });
                    } else {
                    }

                    //console.error(window.registrosOmitidosPaso2);
                    
                    // PROCESAR REGISTROS DE EXTRACTOS DINÁMICOS (todos los bancos)
                    if (codigoCuentaActual && nombrePestaña) {
                        // Obtener registros del extracto específico del banco actual
                        const registrosExtracto = this.filtrarRegistrosExtracto(codigoCuentaActual);
                        if (registrosExtracto && registrosExtracto.length > 0) {
                            registrosExtracto.forEach(registro => {
                                const termino = registro.termino;
                                const clave = `${termino}_${codigoCuentaActual}_${nombrePestaña}`; // Clave única por término, cuenta y fuente
                                
                                if (!resumenPorTerminoCuenta[clave]) {
                                    // Usar mapeo de nomenclatura para DESCRIP
                                    const descripCorrecta = mapeoNomenclatura[codigoCuentaActual] || registro.descrip;
                                    
                                    resumenPorTerminoCuenta[clave] = {
                                        cuenta: codigoCuentaActual,
                                        descrip: descripCorrecta,
                                        fdoc: registro.fdoc,
                                        glosa: registro.glosa,
                                        debe: 0,
                                        haber: 0,
                                        cantidad: 0,
                                        fuente: nombrePestaña
                                    };
                                }
                                
                                resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                                resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                                resumenPorTerminoCuenta[clave].cantidad += 1;
                            });
                        }
                    } else {
                        // Fallback: PROCESAR REGISTROS DE BCP.01 (para compatibilidad)
                        const registrosBCP01 = this.filtrarRegistrosBCP01();
                        if (registrosBCP01 && registrosBCP01.length > 0) {
                             registrosBCP01.forEach(registro => {
                                 const termino = registro.termino;
                                 const clave = `${termino}_1041501_BCP01`; // Clave única para BCP.01
                                 
                                 if (!resumenPorTerminoCuenta[clave]) {
                                     resumenPorTerminoCuenta[clave] = {
                                         cuenta: '1041501',
                                         descrip: 'BCO DE CREDITO M/N',
                                         fdoc: registro.fdoc,
                                         glosa: registro.glosa,
                                         debe: 0,
                                         haber: 0,
                                         cantidad: 0,
                                         fuente: 'BCP.01'
                                     };
                                 }
                                 
                                 resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                                 resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                                resumenPorTerminoCuenta[clave].cantidad += 1;
                            });
                        }
                    }
                    
                    // Verificar que tenemos al menos algunos registros
                    if (Object.keys(resumenPorTerminoCuenta).length === 0) {
                        return null;
                    }
                    const resumenPorFuente = {};
                    Object.values(resumenPorTerminoCuenta).forEach(r => {
                        if (!resumenPorFuente[r.fuente]) resumenPorFuente[r.fuente] = 0;
                        resumenPorFuente[r.fuente]++;
                    });
                    //console.log(resumenPorFuente);
                     
                     // Crear datos para la hoja
                     const datos = [];
                     
                     // Header actualizado con columna FUENTE
                     datos.push(['CUENTA', 'DESCRIP', 'FDOC', 'GLOSA', 'DEBE', 'HABER', 'FUENTE']);
                     
                     // Agregar resúmenes
                     Object.values(resumenPorTerminoCuenta).forEach(resumen => {
                         datos.push([
                             resumen.cuenta,
                             resumen.descrip,
                             resumen.fdoc,
                             `${resumen.glosa} (${resumen.cantidad} registros)`,
                             Math.round(resumen.debe * 100) / 100, // Mantener como número con 2 decimales
                             Math.round(resumen.haber * 100) / 100, // Mantener como número con 2 decimales
                            resumen.fuente
                        ]);
                    });
                    
                    return datos;
                     
                 } catch (error) {
                     //console.error('Error generando datos de tarjetas (Depositos Bancos Parte 2):', error);
                     return null;
                 }
             },

             generarDatosTarjetas(codigoCuentaActual = null, nombrePestaña = null) {
                try {
                    // Mapeo de códigos de cuenta a nombres de banco desde nomenclatura_archivos.md
                    const mapeoNomenclatura = {
                         '1041501': 'BCO DE CREDITO M/N',
                         '1041505': 'BCO DE CREDITO M/N', 
                         '1041401': 'BCO. SANTANDER M/N',
                         '1041201': 'CONTINENTAL M/N',
                         '1041301': 'SCOTIABANK MN',
                         '1041101': 'INTERBANK M/N',
                         '1042101': 'BCO. DE LA NACION DET M/N',
                         '1041601': 'BCO. DE LA NACION M/N',
                         '1041502': 'BCO DE CREDITO M/E',
                         '1041402': 'BCO. SANTANDER M/E',
                         '1041202': 'CONTINENTAL M/E',
                         '1041302': 'SCOTIABANK M/E',
                         '1041102': 'INTERBANK M/E'
                     };
                     
                     // Obtener el último día del mes seleccionado
                     const fdocCalculado = this.calcularFdocUltimoDiaMes();
                     
                     // Agrupar por término de exclusión Y cuenta
                     const resumenPorTerminoCuenta = {};
                     
                    // PROCESAR REGISTROS DEL MAYOR (PASO 2)
                    if (window.registrosOmitidosPaso2 && window.registrosOmitidosPaso2.length > 0) {
                        //console.log('🔍 [DEBUG PARTE 2] Total registros omitidos del Paso 2:', window.registrosOmitidosPaso2.length);
                        //console.log('🔍 [DEBUG PARTE 2] Registros omitidos:', window.registrosOmitidosPaso2);
                        
                        window.registrosOmitidosPaso2.forEach(registro => {
                             const termino = registro.termino;
                             const cuenta = registro.cuenta;
                             const clave = `${termino}_${cuenta}_MAYOR`; // Clave única por término, cuenta y fuente
                             
                             if (!resumenPorTerminoCuenta[clave]) {
                                 // Usar mapeo de nomenclatura para DESCRIP
                                 const descripCorrecta = mapeoNomenclatura[cuenta] || registro.descrip;
                                 
                                 resumenPorTerminoCuenta[clave] = {
                                     cuenta: registro.cuenta,
                                     descrip: descripCorrecta,
                                     fdoc: fdocCalculado,
                                     glosa: `RESUMEN ${termino}`,
                                     debe: 0,
                                     haber: 0,
                                     cantidad: 0,
                                     fuente: 'MAYOR.PEN'
                                 };
                             }
                             
                             resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                             resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                            resumenPorTerminoCuenta[clave].cantidad += 1;
                            
                            // DEBUG: Mostrar registro específico que se está procesando
                          /*  //console.log('🔍 [DEBUG PARTE 2] Procesando registro:', {
                                cuenta: registro.cuenta,
                                termino: registro.termino,
                                glosa: registro.glosa,
                                debe: registro.debe,
                                haber: registro.haber,
                                clave: clave
                            });
                            */
                        });
                    } else {
                    }
                    
                    // PROCESAR REGISTROS DE EXTRACTOS DINÁMICOS (todos los bancos)
                    if (codigoCuentaActual && nombrePestaña) {
                        // Obtener registros del extracto específico del banco actual
                        const registrosExtracto = this.filtrarRegistrosExtracto(codigoCuentaActual);
                        if (registrosExtracto && registrosExtracto.length > 0) {
                            registrosExtracto.forEach(registro => {
                                const termino = registro.termino;
                                const clave = `${termino}_${codigoCuentaActual}_${nombrePestaña}`; // Clave única por término, cuenta y fuente
                                
                                if (!resumenPorTerminoCuenta[clave]) {
                                    // Usar mapeo de nomenclatura para DESCRIP
                                    const descripCorrecta = mapeoNomenclatura[codigoCuentaActual] || registro.descrip;
                                    
                                    resumenPorTerminoCuenta[clave] = {
                                        cuenta: codigoCuentaActual,
                                        descrip: descripCorrecta,
                                        fdoc: registro.fdoc,
                                        glosa: registro.glosa,
                                        debe: 0,
                                        haber: 0,
                                        cantidad: 0,
                                        fuente: nombrePestaña
                                    };
                                }
                                
                                resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                                resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                                resumenPorTerminoCuenta[clave].cantidad += 1;
                            });
                        }
                    } else {
                        // Fallback: PROCESAR REGISTROS DE BCP.01 (para compatibilidad)
                        const registrosBCP01 = this.filtrarRegistrosBCP01();
                        if (registrosBCP01 && registrosBCP01.length > 0) {
                             registrosBCP01.forEach(registro => {
                                 const termino = registro.termino;
                                 const clave = `${termino}_1041501_BCP01`; // Clave única para BCP.01
                                 
                                 if (!resumenPorTerminoCuenta[clave]) {
                                     resumenPorTerminoCuenta[clave] = {
                                         cuenta: '1041501',
                                         descrip: 'BCO DE CREDITO M/N',
                                         fdoc: registro.fdoc,
                                         glosa: registro.glosa,
                                         debe: 0,
                                         haber: 0,
                                         cantidad: 0,
                                         fuente: 'BCP.01'
                                     };
                                 }
                                 
                                 resumenPorTerminoCuenta[clave].debe += parseFloat(registro.debe || 0);
                                 resumenPorTerminoCuenta[clave].haber += parseFloat(registro.haber || 0);
                                resumenPorTerminoCuenta[clave].cantidad += 1;
                            });
                        }
                    }
                    
                    // Verificar que tenemos al menos algunos registros
                    if (Object.keys(resumenPorTerminoCuenta).length === 0) {
                        return null;
                    }
                    const resumenPorFuente = {};
                    Object.values(resumenPorTerminoCuenta).forEach(r => {
                        if (!resumenPorFuente[r.fuente]) resumenPorFuente[r.fuente] = 0;
                        resumenPorFuente[r.fuente]++;
                    });
                    //console.log(resumenPorFuente);
                     
                     // Crear datos para la hoja
                     const datos = [];
                     
                     // Header actualizado con columna FUENTE
                     datos.push(['CUENTA', 'DESCRIP', 'FDOC', 'GLOSA', 'DEBE', 'HABER', 'FUENTE']);
                     
                     // Agregar resúmenes
                     Object.values(resumenPorTerminoCuenta).forEach(resumen => {
                         datos.push([
                             resumen.cuenta,
                             resumen.descrip,
                             resumen.fdoc,
                             `${resumen.glosa} (${resumen.cantidad} registros)`,
                             Math.round(resumen.debe * 100) / 100, // Mantener como número con 2 decimales
                             Math.round(resumen.haber * 100) / 100, // Mantener como número con 2 decimales
                            resumen.fuente
                        ]);
                    });
                    
                    return datos;
                     
                 } catch (error) {
                     //console.error('Error generando datos de tarjetas:', error);
                     return null;
                 }
             },

            filtrarRegistrosExclusionBCP01(datosExtracto) {
                try {
                    // Términos de exclusión específicos para BCP.01 (mismos que en filtrarRegistrosBCP01)
                    const terminosExclusion = [
                        'COMPAN',
                        'CIA DE SERV',
                        'DE DINERS CLUB PERU S.',
                        'DE GAS NATURAL DE LIMA',
                        'DE PROCESOS DE MEDIOS',
                        'TRANSF.BCO.CITIBANK'
                    ];
                    
                    if (!datosExtracto || !Array.isArray(datosExtracto) || datosExtracto.length === 0) {
                        return datosExtracto;
                    }
                    
                    // Buscar el header para identificar la columna de descripción
                    let headerRowIndex = -1;
                    let colDescripcion = -1;
                    
                    for (let i = 0; i < Math.min(10, datosExtracto.length); i++) {
                        const fila = datosExtracto[i];
                        if (Array.isArray(fila)) {
                            for (let j = 0; j < fila.length; j++) {
                                const celda = String(fila[j] || '').toLowerCase();
                                if (celda.includes('descripción') || celda.includes('descripcion') || celda.includes('glosa') || celda.includes('concepto')) {
                                    colDescripcion = j;
                                    headerRowIndex = i;
                                    break;
                                }
                            }
                            if (colDescripcion >= 0) break;
                        }
                    }
                    
                    if (headerRowIndex === -1 || colDescripcion === -1) {
                        console.warn('⚠️ No se encontró columna de descripción en BCP.01, retornando datos originales');
                        return datosExtracto;
                    }
                    
                    // Filtrar registros que NO contengan términos de exclusión
                    const datosFiltrados = [];
                    let registrosEliminados = 0;
                    
                    for (let i = 0; i < datosExtracto.length; i++) {
                        const fila = datosExtracto[i];
                        
                        // Mantener header y filas que no son datos
                        if (i <= headerRowIndex || !Array.isArray(fila) || fila.length <= colDescripcion) {
                            datosFiltrados.push(fila);
                            continue;
                        }
                        
                        const descripcion = String(fila[colDescripcion] || '').toUpperCase();
                        
                        // Verificar si contiene algún término de exclusión
                        let contieneTerminoExclusion = false;
                        for (const termino of terminosExclusion) {
                            if (descripcion.includes(termino)) {
                                contieneTerminoExclusion = true;
                                registrosEliminados++;
                               // //console.log(`🗑️ [FILTER] Eliminando registro BCP.01: "${descripcion}" (contiene: ${termino})`);
                                break;
                            }
                        }
                        
                        // Solo agregar si NO contiene términos de exclusión
                        if (!contieneTerminoExclusion) {
                            datosFiltrados.push(fila);
                        }
                    }
                    
                    ////console.log(`🔍 [FILTER] BCP.01 filtrado: ${datosExtracto.length} → ${datosFiltrados.length} registros (eliminados: ${registrosEliminados})`);
                    
                    return datosFiltrados;
                    
                } catch (error) {
                    //console.error('❌ Error filtrando registros de exclusión BCP.01:', error);
                    return datosExtracto; // Retornar datos originales en caso de error
                }
            },

            filtrarRegistrosBCP01() {
                try {
                    // Términos de exclusión específicos para BCP.01
                    const terminosExclusion = [
                        'COMPAN',
                        'CIA DE SERV',
                        'DE DINERS CLUB PERU S.',
                        'DE GAS NATURAL DE LIMA',
                        'DE PROCESOS DE MEDIOS',
                        'TRANSF.BCO.CITIBANK'
                    ];
                     // Verificar que tenemos datos de extractos
                     if (!window.datosCompletos || !window.datosCompletos.extractosPorCuenta) {
                         return [];
                     }
                     
                     // Obtener datos de BCP.01 (cuenta 1041501)
                     const extractoInfo = window.datosCompletos.extractosPorCuenta.get('1041501');
                     
                     // extractosPorCuenta guarda objetos con {config, datos, datosExtracto, archivo}
                     const datosBCP01 = extractoInfo?.datos || extractoInfo?.datosExtracto;
                     
                     if (!datosBCP01 || !Array.isArray(datosBCP01) || datosBCP01.length === 0) {
                         return [];
                     }
                     // Buscar el header para identificar las columnas
                     let headerRowIndex = -1;
                     let colDescripcion = -1;
                     let colImporte = -1;
                     let colFecha = -1;
                     
                     for (let i = 0; i < Math.min(10, datosBCP01.length); i++) {
                         const fila = datosBCP01[i];
                         if (Array.isArray(fila)) {
                             for (let j = 0; j < fila.length; j++) {
                                 const celda = String(fila[j] || '').toLowerCase();
                                 if (celda.includes('descripción') || celda.includes('descripcion') || celda.includes('glosa')) {
                                     colDescripcion = j;
                                     headerRowIndex = i;
                                 }
                                 if (celda.includes('importe') || celda.includes('monto') || celda.includes('debe') || celda.includes('haber')) {
                                     colImporte = j;
                                 }
                                 if (celda.includes('fecha')) {
                                     colFecha = j;
                                 }
                             }
                             if (colDescripcion >= 0 && colImporte >= 0) break;
                         }
                     }
                     
                     if (headerRowIndex === -1 || colDescripcion === -1 || colImporte === -1) {
                         return [];
                     }
                     // Filtrar registros que contengan los términos de exclusión
                     const registrosFiltrados = [];
                     
                     for (let i = headerRowIndex + 1; i < datosBCP01.length; i++) {
                         const fila = datosBCP01[i];
                         if (!Array.isArray(fila) || fila.length <= Math.max(colDescripcion, colImporte)) continue;
                         
                         const descripcion = String(fila[colDescripcion] || '').toUpperCase();
                         const importe = parseFloat(fila[colImporte] || 0);
                         const fecha = fila[colFecha] || '';
                         
                         // Buscar si la descripción contiene algún término de exclusión
                         for (const termino of terminosExclusion) {
                             if (descripcion.includes(termino)) {
                                 registrosFiltrados.push({
                                     termino: termino,
                                     glosa: descripcion,
                                     debe: importe > 0 ? importe : 0,
                                     haber: importe < 0 ? Math.abs(importe) : 0,
                                     fdoc: fecha,
                                     filaOriginal: i
                                 });
                                 break; // Solo agregar una vez por fila
                             }
                        }
                    }
                    
                    return registrosFiltrados;
                     
                 } catch (error) {
                     //console.error('Error filtrando registros de BCP.01:', error);
                     return [];
                 }
             },

             filtrarRegistrosExtracto(codigoCuenta) {
                 try {
                     // Términos de exclusión genéricos (pueden ser específicos por banco si es necesario)
                     const terminosExclusion = [
                         'COMPAN',
                         'CIA DE SERV',
                         'DE DINERS CLUB PERU S.',
                         'DE GAS NATURAL DE LIMA',
                         'DE PROCESOS DE MEDIOS',
                         'TRANSF.BCO.CITIBANK'
                     ];
                     
                     // Verificar que tenemos datos de extractos
                     if (!window.datosCompletos || !window.datosCompletos.extractosPorCuenta) {
                         return [];
                     }
                     
                     // Obtener datos del extracto específico por código de cuenta
                     const extractoInfo = window.datosCompletos.extractosPorCuenta.get(codigoCuenta);
                     
                     if (!extractoInfo) {
                         console.warn(`⚠️ No se encontró extracto para cuenta ${codigoCuenta}`);
                         return [];
                     }
                     
                     // extractosPorCuenta guarda objetos con {config, datos, datosExtracto, archivo}
                     const datosExtracto = extractoInfo?.datos || extractoInfo?.datosExtracto;
                     
                     if (!datosExtracto || !Array.isArray(datosExtracto) || datosExtracto.length === 0) {
                         return [];
                     }
                     
                     // Buscar el header para identificar las columnas
                     let headerRowIndex = -1;
                     let colDescripcion = -1;
                     let colImporte = -1;
                     let colFecha = -1;
                     
                     for (let i = 0; i < Math.min(5, datosExtracto.length); i++) {
                         const fila = datosExtracto[i];
                         if (Array.isArray(fila)) {
                             for (let j = 0; j < fila.length; j++) {
                                 const celda = fila[j];
                                 if (celda && typeof celda === 'string') {
                                     const celdaUpper = celda.toUpperCase();
                                     if (celdaUpper.includes('DESCRIP') || celdaUpper.includes('CONCEPTO')) {
                                         colDescripcion = j;
                                         headerRowIndex = i;
                                     } else if (celdaUpper.includes('IMPORTE') || celdaUpper.includes('MONTO')) {
                                         colImporte = j;
                                     } else if (celdaUpper.includes('FECHA')) {
                                         colFecha = j;
                                     }
                                 }
                             }
                         }
                     }
                     
                     if (colDescripcion === -1 || colImporte === -1) {
                         console.warn(`⚠️ No se encontraron columnas necesarias en extracto ${codigoCuenta}`);
                         return [];
                     }
                     
                     const registrosFiltrados = [];
                     
                     // Procesar filas de datos (empezar después del header)
                     for (let i = headerRowIndex + 1; i < datosExtracto.length; i++) {
                         const fila = datosExtracto[i];
                         if (!Array.isArray(fila) || fila.length === 0) continue;
                         
                         const descripcion = fila[colDescripcion] || '';
                         const importe = parseFloat(fila[colImporte]) || 0;
                         const fecha = colFecha !== -1 ? fila[colFecha] : '';
                         
                         // Buscar si la descripción contiene algún término de exclusión
                         for (const termino of terminosExclusion) {
                             if (descripcion.includes(termino)) {
                                 registrosFiltrados.push({
                                     termino: termino,
                                     glosa: descripcion,
                                     debe: importe > 0 ? importe : 0,
                                     haber: importe < 0 ? Math.abs(importe) : 0,
                                     fdoc: fecha,
                                     filaOriginal: i
                                 });
                                 break; // Solo agregar una vez por fila
                             }
                         }
                     }
                     
                     return registrosFiltrados;
                     
                 } catch (error) {
                     //console.error(`Error filtrando registros de extracto ${codigoCuenta}:`, error);
                     return [];
                 }
             },

             calcularFdocUltimoDiaMes() {
                 try {
                     if (!this.mesAnoTarjetas) {
                         // Si no hay mes/año seleccionado, usar el mes actual
                         const ahora = new Date();
                         const año = ahora.getFullYear();
                         const mes = ahora.getMonth() + 1; // getMonth() devuelve 0-11
                         return new Date(año, mes, 0).getDate().toString().padStart(2, '0');
                     }
                     
                     // Parsear el valor del input type="month" (formato: YYYY-MM)
                     const [año, mes] = this.mesAnoTarjetas.split('-').map(Number);
                     
                     // Obtener el último día del mes
                     const ultimoDia = new Date(año, mes, 0).getDate();
                     
                     return ultimoDia.toString().padStart(2, '0');
                     
                 } catch (error) {
                     //console.error('Error calculando FDOC:', error);
                     return '31'; // Valor por defecto
                 }
             },

            createDownloadableFile(workbook, fileName) {
                try {
                    // Generar archivo
                    const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                    const blob = new Blob([wbout], { type: 'application/octet-stream' });
                    const url = window.URL.createObjectURL(blob);
                    return url;
                } catch (error) {
                    throw error;
                }
            },

            // 🔧 FUNCIÓN PARA GUARDAR DATOS EN ARCHIVO JSON PARA ANÁLISIS
            guardarDatosJSON(datos) {
                try {
                    const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
                    const fileName = `datos_hoja_trabajo_${timestamp}.json`;
                    
                    // Crear resumen de los datos para facilitar el análisis
                    const resumen = {
                        timestamp: new Date().toISOString(),
                        resumen: {
                            saldo_filas: datos.saldo ? datos.saldo.length : 0,
                            mayor_filas: datos.mayor ? datos.mayor.length : 0,
                            mayorUSD_filas: datos.mayorUSD ? datos.mayorUSD.length : 0,
                            extractos: {}
                        },
                        datos_completos: datos
                    };
                    
                    // Agregar información de cada extracto
                    if (datos.extractos) {
                        Object.keys(datos.extractos).forEach(codigo => {
                            const extracto = datos.extractos[codigo];
                            resumen.resumen.extractos[codigo] = {
                                filas: extracto.length,
                                headers: extracto[0] || [],
                                primeras_3_filas: extracto.slice(1, 4)
                            };
                        });
                    }
                    
                    // Convertir a JSON con formato legible
                    const jsonString = JSON.stringify(resumen, null, 2);
                    
                    // Crear blob y descargar
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                    
                    //console.log(`📊 [JSON] Archivo guardado: ${fileName}`);
                    //console.log('📊 [JSON] Resumen:', resumen.resumen);
                    
                } catch (error) {
                    //console.error('❌ Error guardando datos JSON:', error);
                }
            },

             downloadFile(url, fileName) {
                 try {
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = fileName;
                     document.body.appendChild(a);
                     a.click();
                     document.body.removeChild(a);
                 } catch (error) {
                 }
             },

             downloadBothFiles() {
                 try {
                     if (this.conciliationResult && this.conciliationResult.archivosGenerados) {
                         const archivos = this.conciliationResult.archivosGenerados;
                         
                         // Descargar archivo de datos originales
                         setTimeout(() => {
                             this.downloadFile(archivos.datosOriginales.url, archivos.datosOriginales.nombre);
                         }, 100);
                         
                         // Descargar archivo de conciliación con un pequeño delay
                         setTimeout(() => {
                             this.downloadFile(archivos.conciliacion.url, archivos.conciliacion.nombre);
                         }, 500);
                         
                         this.showStatus('Descargando ambos archivos...', 'success');
                     }
                 } catch (error) {
                     this.showStatus('Error al descargar los archivos', 'error');
                 }
             },

             getFileTypeFromName(fileName) {
                 const name = fileName.toLowerCase();
                 if (name.includes('mayor')) return 'Libro Mayor';
                 if (name.includes('bcp') || name.includes('sant') || name.includes('bbva') || name.includes('sbp') || name.includes('ibk')) return 'Extracto Bancario';
                 if (name.includes('saldo')) return 'Saldo Inicial';
                 return 'Archivo de datos';
             },

             generateExcelFile(datosCompletos, fileName) {
        try {
            
            // Crear workbook
            const wb = XLSX.utils.book_new();
            
                    // HOJA 1: MAYOR.PEN (renombrado)
            if (datosCompletos.datosMayor && datosCompletos.datosMayor.length > 0) {
                const wsMayor = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayor);
                        XLSX.utils.book_append_sheet(wb, wsMayor, "MAYOR.PEN");
                    }
                    
                    // HOJA 2: MAYOR.USD (nueva pestaña para cuenta 1041502)
            if (datosCompletos.datosMayorUSD && datosCompletos.datosMayorUSD.length > 0) {
                const wsMayorUSD = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayorUSD);
                        XLSX.utils.book_append_sheet(wb, wsMayorUSD, "MAYOR.USD");
                    }
                    
                    // HOJAS DE EXTRACTOS DINÁMICAS (una por cuenta con sus datos específicos)
                    if (datosCompletos.extractosPorCuenta) {
                        if (datosCompletos.extractosPorCuenta.has('1041302')) {
                        } else {
                        }
                        datosCompletos.extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                            if (codigoCuenta === '1041302') {
                            }
                            
                            if (extractoInfo.datosExtracto && extractoInfo.datosExtracto.length > 0) {
                                if (codigoCuenta === '1041302') {
                                }
                                const wsExtracto = XLSX.utils.aoa_to_sheet(extractoInfo.datosExtracto);
                                XLSX.utils.book_append_sheet(wb, wsExtracto, extractoInfo.config.pestañaExcel);
                                if (codigoCuenta === '1041302') {
                                }
                            } else {
                                if (codigoCuenta === '1041302') {
                                }
                            }
                        });
                        
                        // SBP.USD y otras cuentas USD ya están manejadas por la lógica normal de extractosPorCuenta
                        // No necesitamos lógica especial aquí
                    } else {
                        // Fallback para compatibilidad con estructura anterior
                        const cuentasActivas = this.getCuentasActivas();
                        cuentasActivas.forEach((cuenta, index) => {
            if (datosCompletos.datosExtracto && datosCompletos.datosExtracto.length > 0) {
                const wsExtracto = XLSX.utils.aoa_to_sheet(datosCompletos.datosExtracto);
                                XLSX.utils.book_append_sheet(wb, wsExtracto, cuenta.pestañaExcel);
                            }
                        });
                    }
                    
                    // HOJA 3: SALDO (nombre fijo)
            if (datosCompletos.datosSaldo && datosCompletos.datosSaldo.length > 0) {
                const wsSaldo = XLSX.utils.aoa_to_sheet(datosCompletos.datosSaldo);
                        XLSX.utils.book_append_sheet(wb, wsSaldo, "SALDO");
            }
            
            // Generar archivo
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            
            const blob = new Blob([wbout], { type: 'application/octet-stream' });
            const url = window.URL.createObjectURL(blob);
            
            // Crear enlace de descarga automática
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            return url;
        } catch (error) {
            throw error;
        }
    },

            procesarPaso12BCP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 BCP - AGRUPACIÓN ESPECÍFICA PARA BCP (01, 02, USD):
                
                ESTRATEGIA BCP:
                1. Agrupar por FDOC en Mayor: FDOC de LIBROS "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Fecha de transacción
                3. Mapear: FDOC+TOTAL_HABER (Mayor) vs FECHA+TOTAL_|MONTO| (Extracto)
                4. Usar FDOC como #REF para grupos conciliados
                
                DIFERENCIAS CON SANTANDER:
                - BCP usa FDOC para agrupación en lugar de solo fecha
                - Los montos se comparan con tolerancia de centavos
                - Referencia usa formato "BCP-FDOC-[fecha]"
        
        ESTADOS RESULTANTES:
        - "P12 - Conciliada" para registros mapeados
        */
        
                // ⭐ VERIFICAR QUE ES BCP
                const esBCP = cuentaConfig && (cuentaConfig.codigo === '1041501' || cuentaConfig.codigo === '1041505' || cuentaConfig.codigo === '1041502');
                
                if (!esBCP) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                
                let gruposMayorCreados = 0;
                let gruposExtractoCreados = 0;
                let conciliados = 0;
                
                // === 1. CREAR GRUPOS DEL MAYOR (LIBROS 02/03/09/14/15) ===
                const gruposMayor = new Map(); // Key: FDOC, Value: {registros: [], totalHaber: 0}
                const librosPermitidos = ['02', '03', '09', '14', '15'];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    const estadoActual = estadosFilas.get(i);
                    if (estadoActual && estadoActual.estado !== 'Pendiente') {
                        continue; // Saltar registros ya conciliados
                    }
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = String(filaMayor[idxM.libro] || '').trim();
                    const fdoc = String(filaMayor[idxM.fdoc] || '').trim();
                    const haber = parseFloat(filaMayor[idxM.haber] || 0);
                    
                    if (librosPermitidos.includes(libro) && fdoc && haber > 0) {
                        if (!gruposMayor.has(fdoc)) {
                            gruposMayor.set(fdoc, { registros: [], totalHaber: 0 });
                            gruposMayorCreados++;
                        }
                        
                        gruposMayor.get(fdoc).registros.push({ indice: i, haber: haber });
                        gruposMayor.get(fdoc).totalHaber += haber;
                    }
                }
                
                // === 2. CREAR GRUPOS DEL EXTRACTO POR FECHA ===
                const gruposExtracto = new Map(); // Key: FECHA, Value: {registros: [], totalMonto: 0}
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    const estadoExtracto = estadosExtracto.get(j);
                    if (estadoExtracto && estadoExtracto.estado !== 'Pendiente') {
                        continue; // Saltar registros ya conciliados
                    }
                    
                    const filaExtracto = extractoProcesable[j];
                    const fecha = String(filaExtracto[idxE.fecha] || '').trim();
                    const monto = Math.abs(parseFloat(filaExtracto[idxE.monto] || 0));
                    
                    if (fecha && monto > 0) {
                        if (!gruposExtracto.has(fecha)) {
                            gruposExtracto.set(fecha, { registros: [], totalMonto: 0 });
                            gruposExtractoCreados++;
                        }
                        
                        gruposExtracto.get(fecha).registros.push({ indice: j, monto: monto });
                        gruposExtracto.get(fecha).totalMonto += monto;
                    }
                }
                
                // === 3. MAPEAR GRUPOS: FDOC+HABER vs FECHA+MONTO ===
                gruposMayor.forEach((grupoMayor, fdoc) => {
                    const totalHaber = grupoMayor.totalHaber;
                    
                    // Buscar grupo del extracto con monto similar
                    let mejorMatch = null;
                    let menorDiferencia = Infinity;
                    
                    gruposExtracto.forEach((grupoExtracto, fecha) => {
                        const totalMonto = grupoExtracto.totalMonto;
                        const diferencia = Math.abs(totalHaber - totalMonto);
                        
                        if (diferencia < menorDiferencia && diferencia <= 0.02) { // Tolerancia de 2 centavos
                            mejorMatch = { fecha: fecha, grupo: grupoExtracto };
                            menorDiferencia = diferencia;
                        }
                    });
                    
                    if (mejorMatch) {
                        // CONCILIAR GRUPO COMPLETO
                        const refBCP = `BCP-${fdoc}`;
                        
                        // Marcar registros del Mayor
                        grupoMayor.registros.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refBCP
                            });
                        });
                        
                        // Marcar registros del Extracto  
                        mejorMatch.grupo.registros.forEach(item => {
                            estadosExtracto.set(item.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refBCP
                            });
                        });
                        
                        // Eliminar grupo del extracto para evitar reutilización
                        gruposExtracto.delete(mejorMatch.fecha);
                        
                        conciliados++;
                        
                    }
                });
                
                
                return {
                    candidatos: gruposMayorCreados,
                    grupos: gruposExtractoCreados,
                    conciliados: conciliados
                };
            },

            procesarPaso12SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
        /*
        PASO 12 SBP - LÓGICA DUAL:
        
        SBP.USD (1041302): AGRUPACIÓN POR FECHA + MONTO
        - Mayor: Agrupar por FECHA + sumar TOTAL HABER
        - Extracto: Agrupar por FECHA + sumar |Total importe|
        - Mapeo: FECHA+TOTAL_HABER vs FECHA+|TOTAL_IMPORTE|
        
        SBP.PEN (1041301): AGRUPACIÓN TRADICIONAL
        - Mayor: Libros 2/3/9/14/15 agrupados por COMPROB
        - Extracto: Agrupado por Referencia
        - Comparación: FDOC+TOTAL_HABER vs Fecha+|TOTAL_IMPORTE|
        */
        const esSBPUSD = cuentaConfig && cuentaConfig.codigo === '1041302';
        // Para SBP.USD usar nueva lógica agrupada por fecha + monto
        if (esSBPUSD) {
            return this.procesarPaso12SBPUSDAgrupado(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
        }
        let gruposMayorCreados = 0;
        let gruposExtractoCreados = 0;
        let conciliados = 0;
        
        // === 1. CREAR GRUPOS DEL MAYOR (LIBROS 2/3/9/14/15) ===
        const gruposMayor = new Map(); // Key: COMPROB, Value: {registros: [], fdoc: '', totalHaber: 0}
        const librosPermitidos = ['02', '2', '3', '9', '14', '15'];
        
        // Agrupando Mayor por COMPROB
        // Libros permitidos definidos
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            if (estadosFilas.has(i)) continue; // Solo procesar pendientes
            
            const filaMayor = filasFiltradasMayor[i];
            const libro = (filaMayor[idxM.libro] || '').toString().trim();
            const comprob = (filaMayor[idxM.comprob] || '').toString().trim();
            const fdoc = (filaMayor[idxM.fdoc] || '').toString().trim();
            const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
            
            if (i < 10) {
            }
            
            // Verificar si está en los libros permitidos
            if (!librosPermitidos.includes(libro)) {
                continue;
            }
            
            // Crear o actualizar grupo por COMPROB
            if (!gruposMayor.has(comprob)) {
                gruposMayor.set(comprob, {
                    registros: [],
                    fdoc: fdoc, // Usar FDOC del primer registro
                    totalHaber: 0,
                    libro: libro
                });
                gruposMayorCreados++;
            }
            
            const grupo = gruposMayor.get(comprob);
            grupo.registros.push({
                indice: i,
                fila: filaMayor
            });
            grupo.totalHaber += haber;
            
            if (grupo.registros.length <= 3) { // Mostrar solo los primeros de cada grupo
                // Registro agregado al grupo
            }
        }
        
        // Grupos Mayor creados
        
        // === 2. CREAR GRUPOS DEL EXTRACTO (POR REFERENCIA) ===
        const gruposExtracto = new Map(); // Key: Referencia, Value: {registros: [], fecha: '', totalImporte: 0}
        
        // Agrupando extracto por referencia (o clave alternativa si no tiene referencia)
        
        for (let j = 0; j < extractoProcesable.length; j++) {
            if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
            
            const itemExtracto = extractoProcesable[j];
            const filaExtracto = itemExtracto.fila;
            const referencia = (filaExtracto[idxE.operacion] || '').toString().trim();
            const fecha = (filaExtracto[idxE.fecha] || '').toString().trim();
            const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0');
            
            if (j < 10) {
            }
            
            // Determinar clave de agrupamiento
            let claveGrupo;
            if (referencia && referencia !== '') {
                // Si tiene referencia, usar la referencia
                claveGrupo = referencia;
            } else {
                // Si no tiene referencia, crear clave única usando fecha + fila
                claveGrupo = `FILA_${j}_${fecha}`;
            }
            
            // Crear o actualizar grupo por CLAVE
            if (!gruposExtracto.has(claveGrupo)) {
                gruposExtracto.set(claveGrupo, {
                    registros: [],
                    fecha: fecha, // Usar fecha del primer registro
                    totalImporte: 0
                });
                gruposExtractoCreados++;
            }
            
            const grupo = gruposExtracto.get(claveGrupo);
            grupo.registros.push({
                indice: j,
                fila: filaExtracto
            });
            grupo.totalImporte += Math.abs(importe);
            
            if (grupo.registros.length <= 3) { // Mostrar solo los primeros de cada grupo
                // Registro agregado al grupo extracto
            }
        }
        
        // Grupos Extracto creados
        
        // === 3. MAPEAR GRUPOS: FDOC+TOTAL_HABER vs FECHA+|TOTAL_IMPORTE| ===
        // Mapeando grupos SBP
        
        let gruposMatched = 0;
        
        for (const [comprobMayor, grupoMayor] of gruposMayor) {
            const claveMapeoMayor = `${grupoMayor.fdoc}_${grupoMayor.totalHaber.toFixed(2)}`;
            
            
            let matchEncontrado = false;
            
            for (const [referenciaExtracto, grupoExtracto] of gruposExtracto) {
                const claveMapeoExtracto = `${this.normalizarFecha(grupoExtracto.fecha)}_${grupoExtracto.totalImporte.toFixed(2)}`;
                
                // COMPARAR: FDOC+TOTAL_HABER vs FECHA_NORMALIZADA+|TOTAL_IMPORTE|
                const fechaNormalizadaExtracto = this.normalizarFecha(grupoExtracto.fecha);
                const esMismoBanco = grupoMayor.fdoc === fechaNormalizadaExtracto;
                const esMismoMonto = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte) < 0.01;
                
                if (esMismoBanco && esMismoMonto) {
                    
                    matchEncontrado = true;
                    gruposMatched++;
                    
                    // Conciliar todos los registros del Mayor en este grupo
                    grupoMayor.registros.forEach((registro, idx) => {
                        estadosFilas.set(registro.indice, {
                            estado: 'P12 - Conciliada',
                            ref: referenciaExtracto
                        });
                        conciliados++;
                        if (idx < 3) { // Solo mostrar los primeros
                        }
                    });
                    
                    // Conciliar todos los registros del Extracto en este grupo
                    grupoExtracto.registros.forEach((registro, idx) => {
                        estadosExtracto.set(registro.indice, {
                            estado: 'P12 - Conciliada',
                            ref: `${grupoMayor.libro}-${comprobMayor}`
                        });
                        conciliados++;
                        if (idx < 3) { // Solo mostrar los primeros
                        }
                    });
                    
                    // Remover grupo del extracto para evitar múltiples matches
                    gruposExtracto.delete(referenciaExtracto);
                    break;
                }
            }
            
            if (!matchEncontrado) {
                // No match para grupo mayor
            }
        }
        
        // SBP Paso 12 completado
        // Estadísticas SBP Paso 12
        
        return {
            gruposMayor: gruposMayorCreados,
            gruposExtracto: gruposExtractoCreados,
            gruposMatched: gruposMatched,
            conciliados: conciliados
        };
    },

    procesarPaso12IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
        /*
        PASO 12 IBK - REPROCESAMIENTO PASO 4:
        
        OBJETIVO:
        Reprocesar la primera fase del Paso 4 IBK para todos los registros que quedaron pendientes
        después de los 11 pasos anteriores, dando una segunda oportunidad de conciliación.
        
        ESTRATEGIA:
        1. Identificar registros PENDIENTES tanto en Mayor como Extracto
        2. Aplicar exactamente la misma lógica de la ETAPA 1 del Paso 4 IBK:
           - Buscar candidatos IBK en extracto (FINANC. DE DOCS con cargo -8 y FCD ABON.CTA)
           - Agrupar por fecha de operación
           - Buscar coincidencias con Mayor (DES_TDOP="Bna" + LIBRO="04" + DEBE > 0)
        3. Mapear: FDOC + DEBE (Mayor) vs Fecha + Total Grupo (Extracto)
        
        CRITERIOS EXTRACTO (IGUALES AL PASO 4):
        1. Movimiento = "FINANC. DE DOCS" Y Cargo = "-8"
        2. Descripción = "FCD ABON.CTA"
        3. Agrupar por Fecha de operación del mismo día
        
        CRITERIOS MAYOR (IGUALES AL PASO 4):
        - DES_TDOP="Bna" + LIBRO="04" + DEBE > 0 + PENDIENTES
        
        ESTADOS RESULTANTES:
        - "P12 - Conciliada" para registros mapeados exitosamente
        - Referencias cruzadas Mayor ↔ Extracto
        */
        
        if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
            return { candidatos: 0, conciliados: 0 };
        }
        
        
        let candidatosExtractoIBK = 0;
        let contadorCandidatosMayorBNA = 0;
        let conciliados = 0;
        
        // === FASE 1: BUSCAR CANDIDATOS DEL EXTRACTO IBK CON ESTADO "Pendiente" ===
        const candidatosGrupoIBK = [];
        
        for (let i = 0; i < extractoProcesable.length; i++) {
            const item = extractoProcesable[i];
            const fila = item.fila;
            if (!fila || !Array.isArray(fila)) continue;
            
            // PASO 12: Solo procesar registros con ESTADO = "Pendiente"
            const estadoActual = item.estado || '';
            if (estadoActual !== 'Pendiente') {
                continue;
            }
            
            // IBK estructura ORIGINAL: A=vacío, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripción, G=Canal, H=Cargo, I=Abono, J=Saldo
            const fechaOperacion = fila[1] || '';     // B (índice 1)
            const movimiento = (fila[4] || '').toString();  // E (índice 4)
            const descripcion = (fila[5] || '').toString(); // F (índice 5)
            const cargo = (fila[7] || '').toString();       // H (índice 7)
            const abono = fila[8] || '';              // I (índice 8)
            
            let esCandidata = false;
            let tipoRegistro = '';
            
            // Criterio 1: FINANC. DE DOCS en MOVIMIENTO Y cargo -8
            if (movimiento.trim() === 'FINANC. DE DOCS' && cargo && cargo.trim() === '-8') {
                esCandidata = true;
                tipoRegistro = 'FINANC_DOCS';
            }
            
            // Criterio 2: FCD ABON.CTA en DESCRIPCIÓN
            if (descripcion.trim() === 'FCD ABON.CTA') {
                esCandidata = true;
                tipoRegistro = 'FCD_ABON';
            }
            
            if (esCandidata) {
                const cargoNumerico = this.normalizarMonto(cargo || '0');
                const abonoNumerico = this.normalizarMonto(abono || '0');
                const importeFila = cargoNumerico + abonoNumerico;
                
                candidatosGrupoIBK.push({
                    tipo: tipoRegistro,
                    indice: i,
                    fechaOperacion: fechaOperacion,
                    importeFila: importeFila,
                    fila: fila
                });
                candidatosExtractoIBK++;
            }
        }
        
        
        if (candidatosExtractoIBK === 0) {
            return { candidatos: 0, conciliados: 0 };
        }
        
        // === FASE 2: AGRUPAR CANDIDATOS POR FECHA ===
        const gruposPorFechaExtracto = new Map();
        
        candidatosGrupoIBK.forEach(candidato => {
            const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
            if (!gruposPorFechaExtracto.has(fechaNormalizada)) {
                gruposPorFechaExtracto.set(fechaNormalizada, []);
            }
            gruposPorFechaExtracto.get(fechaNormalizada).push(candidato);
        });
        
        
        // === FASE 3: CALCULAR TOTALES POR GRUPO DE FECHA ===
        const totalesPorFecha = new Map();
        
        gruposPorFechaExtracto.forEach((grupo, fecha) => {
            const totalImporte = grupo.reduce((sum, candidato) => sum + candidato.importeFila, 0);
            grupo.forEach(candidato => {
            });
            
            totalesPorFecha.set(fecha, {
                total: totalImporte,
                indices: grupo.map(c => c.indice),
                grupo: grupo
            });
        });
        
        // === FASE 4: BUSCAR CANDIDATOS DEL MAYOR BNA CON ESTADO "Pendiente" ===
        const candidatosMayorBNA = [];
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            
            // PASO 12: Solo procesar registros con ESTADO = "Pendiente"
            const estadoInfo = estadosFilas.get(i);
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') {
                continue;
            }
            
            const destdop = (filaMayor[idxM.destdop] || '').toString();
            const libro = (filaMayor[idxM.libro] || '').toString();
            const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
            const fdoc = filaMayor[idxM.fdoc] || '';
            
            if (destdop === 'Bna' && libro === '04' && debe > 0) {
                candidatosMayorBNA.push({
                    indice: i,
                    fdoc: fdoc,
                    debe: debe,
                    fila: filaMayor
                });
                contadorCandidatosMayorBNA++;
            }
        }
        
        
        if (contadorCandidatosMayorBNA === 0) {
            return { candidatos: candidatosExtractoIBK, conciliados: 0 };
        }
        
        // === FASE 5: MAPEO FDOC + DEBE vs FECHA + TOTAL ===
        
        totalesPorFecha.forEach((grupoExtracto, fechaExtracto) => {
            
            candidatosMayorBNA.forEach(candidatoMayor => {
                // PASO 12: Procesar candidatos que están en estado "Pendiente"
                
                const fechaMayorNormalizada = this.normalizarFecha(candidatoMayor.fdoc);
                const tolerancia = 1.0; // Tolerancia más amplia para captar diferencias de redondeo
                
                
                // Verificar coincidencia de fecha y monto
                const fechasCoinciden = fechaMayorNormalizada === fechaExtracto;
                
                // También verificar fechas con tolerancia de ±2 días hábiles
                const fechaMayor = new Date(fechaMayorNormalizada);
                const fechaExtractoDate = new Date(fechaExtracto);
                const diferenciaDias = Math.abs((fechaMayor - fechaExtractoDate) / (1000 * 60 * 60 * 24));
                const fechasProximas = diferenciaDias <= 3; // Tolerancia de 3 días
                
                const montosCoinciden = Math.abs(candidatoMayor.debe - Math.abs(grupoExtracto.total)) <= tolerancia;
                const diferenciaMonto = candidatoMayor.debe - Math.abs(grupoExtracto.total);
                
                
                if ((fechasCoinciden || fechasProximas) && montosCoinciden) {
                    // CONCILIACIÓN EXITOSA EN PASO 12
                    const comprob = candidatoMayor.fila[idxM.comprob] || '';
                    const libro = candidatoMayor.fila[idxM.libro] || '';
                    
                    // Marcar Mayor como conciliado (sabemos que estaba Pendiente)
                    estadosFilas.set(candidatoMayor.indice, {
                        estado: 'P12 - Conciliada',
                        ref: `IBK-GRUPO-${fechaExtracto}`
                    });
                    conciliados += 1;
                    
                    // Marcar registros del extracto como conciliados (sabemos que estaban Pendiente)
                    grupoExtracto.indices.forEach(idxExtracto => {
                        estadosExtracto.set(idxExtracto, {
                            estado: 'P12 - Conciliada',
                            ref: `${libro}-${comprob}`
                        });
                        conciliados += 1;
                    });
                    
                }
            });
        });
        
        
        // === ANÁLISIS DETALLADO DE REGISTROS PENDIENTES ===
        
        // Analizar extracto pendientes
        let pendientesExtracto = 0;
        for (let i = 0; i < extractoProcesable.length; i++) {
            const item = extractoProcesable[i];
            const estadoActual = item.estado || '';
            if (estadoActual === 'Pendiente') {
                pendientesExtracto++;
                if (pendientesExtracto <= 10) { // Solo mostrar primeros 10
                    const fila = item.fila || [];
                    const movimiento = (fila[4] || '').toString();
                    const descripcion = (fila[5] || '').toString();
                    const cargo = this.normalizarMonto(fila[7] || '0');
                    const abono = this.normalizarMonto(fila[8] || '0');
                }
            }
        }
        
        // Analizar mayor pendientes
        let pendientesMayor = 0;
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const estadoInfo = estadosFilas.get(i);
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual === 'Pendiente') {
                const filaMayor = filasFiltradasMayor[i];
                const destdop = (filaMayor[idxM.destdop] || '').toString();
                const libro = (filaMayor[idxM.libro] || '').toString();
                const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                if (destdop === 'Bna' && libro === '04' && debe > 0) {
                    pendientesMayor++;
                    if (pendientesMayor <= 10) { // Solo mostrar primeros 10
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const comprob = filaMayor[idxM.comprob] || '';
                    }
                }
            }
        }
        
        // Mostrar grupos formados
        totalesPorFecha.forEach((grupoExtracto, fechaExtracto) => {
        });
        
        candidatosMayorBNA.forEach((candidato, idx) => {
            if (idx < 10) { // Solo mostrar primeros 10
            }
        });
        
        // === ANÁLISIS ESPECÍFICO DEL CASO PROBLEMÁTICO ===
        
        // Buscar el registro Mayor con FDOC 45813 y DEBE 53342.53
        let registroMayorProblematico = null;
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            const fdoc = filaMayor[idxM.fdoc] || '';
            const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
            if (fdoc === '45813' && Math.abs(debe - 53342.53) < 1) {
                const estadoInfo = estadosFilas.get(i);
                const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
                registroMayorProblematico = { indice: i, fdoc, debe, estado: estadoActual };
                break;
            }
        }
        
        // Buscar grupo del 05/06/2025 en extracto
        let grupoExtractoProblematico = null;
        if (totalesPorFecha.has('05/06/2025')) {
            const grupo = totalesPorFecha.get('05/06/2025');
            grupoExtractoProblematico = grupo;
            
            // Analizar cada registro del grupo
            grupo.indices.forEach(idx => {
                const item = extractoProcesable[idx];
                const estadoActual = item.estado || '';
                const fila = item.fila || [];
                const movimiento = (fila[4] || '').toString();
                const descripcion = (fila[5] || '').toString();
                const cargo = this.normalizarMonto(fila[7] || '0');
                const abono = this.normalizarMonto(fila[8] || '0');
            });
        }
        
        // Analizar por qué no se mapeó
        if (registroMayorProblematico && grupoExtractoProblematico) {
            const fechaMayorNormalizada = this.normalizarFecha(registroMayorProblematico.fdoc);
            const fechaExtracto = '05/06/2025';
            const tolerancia = 1.0;
            
            const diferenciaMonto = registroMayorProblematico.debe - Math.abs(grupoExtractoProblematico.total);
            const montosCoinciden = Math.abs(diferenciaMonto) <= tolerancia;
            
            const fechaObj1 = new Date(fechaMayorNormalizada);
            const fechaObj2 = new Date(fechaExtracto);
            const diferenciaDias = Math.abs((fechaObj1.getTime() - fechaObj2.getTime()) / (1000 * 60 * 60 * 24));
            const fechasCoinciden = fechaMayorNormalizada === fechaExtracto;
            const fechasProximas = diferenciaDias <= 3;
            
            
            if (registroMayorProblematico.estado !== 'Pendiente') {
            }
            
            // Verificar si algún registro del grupo extracto no está Pendiente
            let todosExtractoPendientes = true;
            grupoExtractoProblematico.indices.forEach(idx => {
                const item = extractoProcesable[idx];
                const estadoActual = item.estado || '';
                if (estadoActual !== 'Pendiente') {
                    todosExtractoPendientes = false;
                }
            });
            
            if (todosExtractoPendientes) {
            }
        }
        
        
        return {
            candidatos: candidatosExtractoIBK + contadorCandidatosMayorBNA,
            conciliados: conciliados
        };
    },

    // === PASO 12 DET - AGRUPACIÓN POR FECHA Y COMPARACIÓN CON HABER ===
    procesarPaso12DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null, datosMayorCompletos = null) {
        /*
        PASO 12 DET - AGRUPACIÓN POR FECHA Y COMPARACIÓN CON HABER:
        
        OBJETIVO:
        Tomar todos los pendientes de DET (columna I) del archivo conciliación,
        agruparlos por fecha y compararlos contra pendientes en MAYOR.PEN que cuadren en HABER.
        
        ESTRATEGIA:
        1. Obtener todos los registros PENDIENTES de DET (sin importar si se usaron antes)
        2. Agrupar por FECHA (columna B del extracto DET)
        3. Sumar los importes de cada grupo por fecha
        4. Buscar en MAYOR.PEN registros pendientes que coincidan:
           - SOLO mismo monto en columna HABER (sin coincidir fecha)
        5. Mapear grupos que coincidan exactamente en monto
        
        CRITERIOS EXTRACTO DET:
        - Estado = "Pendiente" en columna I
        - Agrupar por columna B (Fecha)
        - Sumar columnas F (Cargo) + G (Abono) por grupo
        
        CRITERIOS MAYOR:
        - Estado = "Pendiente"
        - HABER > 0 y coincide con total del grupo DET
        - NO se valida coincidencia de fecha
        
        ESTADOS RESULTANTES:
        - "P12 - Conciliada" para registros mapeados exitosamente
        - Referencias cruzadas Mayor ↔ Extracto
        */
        
        
        // DET no tiene extracto - buscar en filasFiltradasMayor (archivo conciliación DET)
        let candidatosDETConciliacion = 0;
        let conciliados = 0;
        
        // === FASE 1: OBTENER REGISTROS PENDIENTES DE DET DEL ARCHIVO CONCILIACIÓN ===
        const registrosPendientesDET = [];
        
        // Buscar en filasFiltradasMayor los registros DET pendientes (columna ESTADO = "Pendiente")
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const estadoInfo = estadosFilas.get(i);
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            
            if (estadoActual !== 'Pendiente') continue;
            
            const filaDET = filasFiltradasMayor[i];
            const cuenta = filaDET[idxM.cuenta] || '';
            
            // Solo procesar si es cuenta DET (1042101)
            if (cuenta !== '1042101') continue;
            
            const fecha = filaDET[idxM.fdoc] || '';
            const debe = this.normalizarMonto(filaDET[idxM.debe] || '0');
            const haber = this.normalizarMonto(filaDET[idxM.haber] || '0');
            const importe = debe + haber; // Total del registro DET
            
            if (fecha && importe !== 0) {
                // BUSCAR EL ÍNDICE CORRECTO EN datosMayorCompletos
                let indiceEnMayorCompleto = -1;
                for (let j = 1; j < datosMayorCompletos.length; j++) {
                    const filaMayorCompleto = datosMayorCompletos[j];
                    if (filaMayorCompleto && Array.isArray(filaMayorCompleto)) {
                        // Comparar por múltiples campos para encontrar el registro exacto
                        const cuentaCompleto = filaMayorCompleto[idxM.cuenta] || '';
                        const fechaCompleto = filaMayorCompleto[idxM.fdoc] || '';
                        const debeCompleto = this.normalizarMonto(filaMayorCompleto[idxM.debe] || '0');
                        const haberCompleto = this.normalizarMonto(filaMayorCompleto[idxM.haber] || '0');
                        const glosaCompleto = filaMayorCompleto[idxM.glosa] || '';
                        const glosaFiltradasMayor = filaDET[idxM.glosa] || '';
                        
                        if (cuentaCompleto === cuenta && 
                            fechaCompleto === fecha && 
                            Math.abs(debeCompleto - debe) < 0.01 && 
                            Math.abs(haberCompleto - haber) < 0.01 &&
                            glosaCompleto === glosaFiltradasMayor) {
                            indiceEnMayorCompleto = j;
                            break;
                        }
                    }
                }
                
                if (indiceEnMayorCompleto === -1) {
                }
                
                registrosPendientesDET.push({
                    indice: i, // Índice en filasFiltradasMayor
                    indiceCompleto: indiceEnMayorCompleto, // Índice en datosMayorCompletos
                    fecha: fecha,
                    importe: importe,
                    fila: filaDET
                });
                candidatosDETConciliacion++;
            }
        }
        
        
        registrosPendientesDET.forEach((registro, idx) => {
            const fila = registro.fila;
            const glosa = fila[11] || ''; // GLOSA
            const debe = this.normalizarMonto(fila[12] || '0');
            const haber = this.normalizarMonto(fila[13] || '0');
        });
        
        if (candidatosDETConciliacion === 0) {
            return { candidatos: 0, conciliados: 0 };
        }
        
        // === FASE 2: AGRUPAR POR FECHA ===
        const gruposPorFechaDET = new Map();
        
        registrosPendientesDET.forEach(registro => {
            const fechaNormalizada = this.normalizarFecha(registro.fecha);
            
            if (!gruposPorFechaDET.has(fechaNormalizada)) {
                gruposPorFechaDET.set(fechaNormalizada, {
                    fecha: fechaNormalizada,
                    registros: [],
                    totalImporte: 0
                });
            }
            
            const grupo = gruposPorFechaDET.get(fechaNormalizada);
            grupo.registros.push(registro);
            grupo.totalImporte += registro.importe;
        });
        
        
        // Mostrar detalles COMPLETOS de cada grupo DET
        gruposPorFechaDET.forEach((grupo, fecha) => {
            grupo.registros.forEach((registro, idx) => {
                const fila = registro.fila;
                const glosa = fila[11] || ''; // GLOSA
                const debe = this.normalizarMonto(fila[12] || '0');
                const haber = this.normalizarMonto(fila[13] || '0');
            });
        });
        
        // === FASE 3: BUSCAR REGISTROS DET EN EL MAYOR.PEN ===
        const candidatosMayorDET = [];
        
        // Buscar SOLO registros DET (cuenta 1042101) en el Mayor.PEN con HABER > 0
        // Estos son los registros DET del Mayor que deben coincidir con los grupos DET
        const datosParaBuscar = datosMayorCompletos;
        
        for (let i = 1; i < datosParaBuscar.length; i++) { // Empezar en 1 para saltar header
            const filaMayor = datosParaBuscar[i];
            if (!filaMayor || !Array.isArray(filaMayor)) continue;
            
            const cuenta = filaMayor[idxM.cuenta] || '';
            const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
            const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
            const glosa = filaMayor[idxM.glosa] || '';
            const fdoc = filaMayor[idxM.fdoc] || '';
            
            // INCLUIR TODOS los registros DET (1042101) - tanto con DEBE como con HABER
            if (cuenta === '1042101') {
                candidatosMayorDET.push({
                    indice: i,
                    debe: debe,
                    haber: haber,
                    fila: filaMayor,
                    cuenta: cuenta,
                    glosa: glosa,
                    fdoc: fdoc
                });
            }
        }
        
        const totalCandidatosMayor = candidatosMayorDET.length;
        
        
        // Mostrar TODOS los registros DET del Mayor.PEN
        candidatosMayorDET.forEach((candidato, idx) => {
        });
        
        // Buscar específicamente los montos que necesitamos (4253 y 10457)
        
        gruposPorFechaDET.forEach((grupoDET, fechaDET) => {
            
            // Buscar registros DET del Mayor con el mismo DEBE
            const coincidencias = candidatosMayorDET.filter(c => {
                const diferencia = Math.abs(c.debe - Math.abs(grupoDET.totalImporte));
                return diferencia < 0.01;
            });
            
            coincidencias.forEach((c, i) => {
            });
        });
        
        // === FASE 4: MAPEAR GRUPOS DET CON REGISTROS DET MAYOR (DEBE vs DEBE) ===
        let numeroGrupo = 1;
        
        gruposPorFechaDET.forEach((grupoDET, fechaDET) => {
            
            // Buscar registros DET del Mayor con el mismo DEBE
            const candidatosCoincidentes = candidatosMayorDET.filter(candidato => {
                const diferencia = Math.abs(candidato.debe - Math.abs(grupoDET.totalImporte));
                const coincide = diferencia < 0.01;
                
                
                return coincide;
            });
            
            
            if (candidatosCoincidentes.length > 0) {
                const candidatoElegido = candidatosCoincidentes[0];
                const referenciaGenerada = `DET-GRUPO-${numeroGrupo}`;
                
                
                // Marcar registros del grupo DET como conciliados
                grupoDET.registros.forEach((registro, idx) => {
                    const indiceEnFilasFiltradasMayor = registro.indice; // Índice en filasFiltradasMayor
                    const indiceEnMayorCompleto = registro.indiceCompleto; // Índice en datosMayorCompletos
                    
                    // MARCAR EN MAYOR (estadosFilas) - COPIANDO LÓGICA DEL PASO 6 DET
                    estadosFilas.set(indiceEnFilasFiltradasMayor, {
                        estado: 'P12 - Conciliada',
                        ref: referenciaGenerada
                    });
                    
                    // MARCAR EN EXTRACTO DET (estadosExtracto) - COPIANDO LÓGICA DEL PASO 6 DET
                    let indiceExtractoEncontrado = -1;
                    
                    for (let e = 0; e < extractoProcesable.length; e++) {
                        // Saltar si ya fue procesado
                        if (estadosExtracto.has(e)) continue;
                        
                        const itemExtracto = extractoProcesable[e];
                        if (itemExtracto && itemExtracto.fila) {
                            const filaExtracto = itemExtracto.fila;
                            const fechaExtracto = filaExtracto[1] || ''; // B - Fecha
                            const cargoExtracto = this.normalizarMonto(filaExtracto[6] || '0'); // G - Cargo
                            const abonoExtracto = this.normalizarMonto(filaExtracto[7] || '0'); // H - Abono
                            const importeExtracto = cargoExtracto + abonoExtracto;
                            
                            // Comparar con el registro DET del Mayor (igual que Paso 6)
                            const fechaDET = registro.fecha;
                            const importeDET = Math.abs(registro.importe);
                            
                            if (fechaExtracto === fechaDET && Math.abs(importeExtracto - importeDET) < 0.01) {
                                indiceExtractoEncontrado = e;
                                break;
                            }
                        }
                    }
                    
                    if (indiceExtractoEncontrado !== -1) {
                        // MARCAR EN EXTRACTO - COPIANDO EXACTAMENTE DEL PASO 6 DET
                        estadosExtracto.set(indiceExtractoEncontrado, {
                            estado: 'P12 - Conciliada',
                            ref: referenciaGenerada
                        });
                    } else {
                    }
                    
                    conciliados++;
                });
                
                // Marcar registro del Mayor que coincide - COPIANDO LÓGICA DEL PASO 6 DET
                
                // MARCAR DIRECTAMENTE COMO EN PASO 6 DET
                estadosFilas.set(candidatoElegido.indice, {
                    estado: 'P12 - Conciliada',
                    ref: referenciaGenerada
                });
                conciliados++;
                
                numeroGrupo++;
            } else {
            }
        });
        
        
        return {
            candidatos: candidatosDETConciliacion + totalCandidatosMayor,
            conciliados: conciliados
        };
    },

    // === PASO 12 SBP - REPROCESAMIENTO COMPLETO DEL PASO 4 === [OBSOLETO - USAR procesarPaso12SBP EN LÍNEA 13396]
    procesarPaso12SBP_P9B_OBSOLETO: function(datosMayor, datosExtracto, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig) {
        if (!datosMayor || !Array.isArray(datosMayor) || datosMayor.length === 0) {
            return { candidatos: 0, conciliados: 0 };
        }

        if (!datosExtracto || !Array.isArray(datosExtracto) || datosExtracto.length === 0) {
            return { candidatos: 0, conciliados: 0 };
        }

        // Filtrar solo registros pendientes del Mayor
        const filasFiltradasMayor = datosMayor.filter((fila, indice) => {
            // Verificar si estadosFilas es un Map o un array
            let estadoInfo;
            if (estadosFilas instanceof Map) {
                estadoInfo = estadosFilas.get(indice);
            } else if (Array.isArray(estadosFilas)) {
                estadoInfo = estadosFilas[indice];
            } else {
                // Si no es ni Map ni array, asumir que todos están pendientes
                return true;
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            return estadoActual === 'Pendiente';
        });

        // PASO 12 SBP-P9B: Usar TODAS las filas del extracto (como en el Paso 9B original)
        const extractoProcesable = datosExtracto;



        if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
            return { candidatos: 0, conciliados: 0 };
        }

        const esUSD = cuentaConfig.moneda === 'USD';

        let candidatosExtractoSBP = 0;
        let candidatosMayorSBP = 0;
        let conciliados = 0;

        // === FASE 1: BUSCAR CANDIDATOS DEL EXTRACTO SBP CON ESTADO "Pendiente" ===
        const candidatosGrupoSBP = [];

        for (let i = 0; i < extractoProcesable.length; i++) {
            const fila = extractoProcesable[i];
            if (!fila || !Array.isArray(fila)) continue;

            // Solo procesar registros con ESTADO = "Pendiente"
            let estadoInfo;
            if (estadosExtracto instanceof Map) {
                estadoInfo = estadosExtracto.get(i);
            } else if (Array.isArray(estadosExtracto)) {
                estadoInfo = estadosExtracto[i];
            } else {
                // Si no es ni Map ni array, asumir que todos están pendientes
                estadoInfo = { estado: 'Pendiente' };
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') {
                continue;
            }

            // SBP estructura: A=Fecha, B=Referencia, C=Descripción, D=Importe
            const fecha = fila[0] || '';
            const referencia = fila[1] || '';
            const descripcion = (fila[2] || '').toString();
            const importe = this.normalizarMonto(fila[3] || '0');

            if (fecha && importe !== 0) {
                candidatosExtractoSBP++;
                candidatosGrupoSBP.push({
                    indice: i,
                    fecha: fecha,
                    referencia: referencia,
                    descripcion: descripcion,
                    importe: importe,
                    fila: fila
                });
            }
        }


        // === FASE 2: AGRUPAR EXTRACTO POR CRITERIO ===
        const gruposExtracto = new Map();

        if (esUSD) {
            // USD: Agrupa por FECHA
            candidatosGrupoSBP.forEach(candidato => {
                const fecha = candidato.fecha;
                if (!gruposExtracto.has(fecha)) {
                    gruposExtracto.set(fecha, {
                        total: 0,
                        registros: [],
                        indices: []
                    });
                }
                const grupo = gruposExtracto.get(fecha);
                grupo.total += Math.abs(candidato.importe);
                grupo.registros.push(candidato);
                grupo.indices.push(candidato.indice);
            });
        } else {
            // PEN: Agrupación anidada REFERENCIA → FECHA
            const gruposPorReferencia = new Map();
            
            candidatosGrupoSBP.forEach(candidato => {
                const referencia = candidato.referencia;
                const fecha = candidato.fecha;
                
                if (!gruposPorReferencia.has(referencia)) {
                    gruposPorReferencia.set(referencia, new Map());
                }
                
                const grupoReferencia = gruposPorReferencia.get(referencia);
                if (!grupoReferencia.has(fecha)) {
                    grupoReferencia.set(fecha, {
                        total: 0,
                        registros: [],
                        indices: []
                    });
                }
                
                const grupoFecha = grupoReferencia.get(fecha);
                grupoFecha.total += Math.abs(candidato.importe);
                grupoFecha.registros.push(candidato);
                grupoFecha.indices.push(candidato.indice);
            });
            
            // Convertir a formato plano para el mapeo
            gruposPorReferencia.forEach((gruposFecha, referencia) => {
                gruposFecha.forEach((grupoFecha, fecha) => {
                    const clave = `${referencia}-${fecha}`;
                    gruposExtracto.set(clave, grupoFecha);
                });
            });
        }


        // === FASE 3: BUSCAR CANDIDATOS DEL MAYOR SBP CON ESTADO "Pendiente" ===
        const candidatosMayorSBPList = [];
        const gruposMayor = new Map(); // Para agrupación anidada

        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            
            // Solo procesar registros con ESTADO = "Pendiente"
            let estadoInfo;
            if (estadosFilas instanceof Map) {
                estadoInfo = estadosFilas.get(i);
            } else if (Array.isArray(estadosFilas)) {
                estadoInfo = estadosFilas[i];
            } else {
                estadoInfo = null;
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') {
                continue;
            }

            const libro = (filaMayor[indicesMayor.libro] || '').toString();
            const debe = this.normalizarMonto(filaMayor[indicesMayor.debe] || '0');
            const haber = this.normalizarMonto(filaMayor[indicesMayor.haber] || '0');
            const fdoc = filaMayor[indicesMayor.fdoc] || '';
            const comprob = filaMayor[indicesMayor.comprob] || '';

            // Filtrar por libros permitidos: 02/03/09/14/15
            if (['02', '03', '09', '14', '15'].includes(libro) && (debe > 0 || haber > 0)) {
                candidatosMayorSBP++;
                candidatosMayorSBPList.push({
                    indice: i,
                    libro: libro,
                    debe: debe,
                    haber: haber,
                    fdoc: fdoc,
                    comprob: comprob,
                    fila: filaMayor
                });

                // Agrupación anidada COMPROB → FDOC
                if (!gruposMayor.has(comprob)) {
                    gruposMayor.set(comprob, new Map());
                }
                
                const grupoComprob = gruposMayor.get(comprob);
                if (!grupoComprob.has(fdoc)) {
                    grupoComprob.set(fdoc, {
                        total: 0,
                        registros: [],
                        indices: []
                    });
                }
                
                const grupoFDOC = grupoComprob.get(fdoc);
                grupoFDOC.total += haber; // Usar HABER para el total
                grupoFDOC.registros.push({
                    indice: i,
                    libro: libro,
                    debe: debe,
                    haber: haber,
                    fdoc: fdoc,
                    comprob: comprob,
                    fila: filaMayor
                });
                grupoFDOC.indices.push(i);
            }
        }


        // === FASE 4: MAPEO SEGÚN CRITERIO ===

        gruposExtracto.forEach((grupoExtracto, criterioExtracto) => {

            if (esUSD) {
                // USD: Mapea por FECHA + TOTAL IMPORTE
                candidatosMayorSBPList.forEach(candidatoMayor => {
                    const criterioMayor = candidatoMayor.fdoc;
                    const totalMayor = candidatoMayor.haber;
                    const tolerancia = 1.0;
                    const montosCoinciden = Math.abs(totalMayor - grupoExtracto.total) <= tolerancia;
                    const criteriosCoinciden = criterioMayor === criterioExtracto;


                    if (criteriosCoinciden && montosCoinciden) {
                        this.conciliarGrupoSBP(grupoExtracto, candidatoMayor, estadosFilas, estadosExtracto, esUSD, criterioExtracto);
                        conciliados += 1;
                    }
                });
            } else {
                // PEN: Mapea por COMPROB-FDOC + TOTAL HABER vs REFERENCIA-FECHA + TOTAL IMPORTE
                const [referenciaExtracto, fechaExtracto] = criterioExtracto.split('-');
                
                gruposMayor.forEach((gruposFDOC, comprob) => {
                    gruposFDOC.forEach((grupoFDOC, fdoc) => {
                        const criterioMayor = `${comprob}-${fdoc}`;
                        const totalMayor = grupoFDOC.total;
                        const tolerancia = 1.0;
                        const montosCoinciden = Math.abs(totalMayor - grupoExtracto.total) <= tolerancia;
                        const criteriosCoinciden = criterioMayor === criterioExtracto;


                        if (criteriosCoinciden && montosCoinciden) {
                            this.conciliarGrupoSBP(grupoExtracto, grupoFDOC, estadosFilas, estadosExtracto, esUSD, criterioExtracto);
                            conciliados += 1;
                        }
                    });
                });
            }
        });


        // === ANÁLISIS DETALLADO ===
        
        // Analizar extracto pendientes
        let pendientesExtracto = 0;
        for (let i = 0; i < extractoProcesable.length; i++) {
            // Verificar estado usando estadosExtracto
            let estadoInfo;
            if (estadosExtracto instanceof Map) {
                estadoInfo = estadosExtracto.get(i);
            } else if (Array.isArray(estadosExtracto)) {
                estadoInfo = estadosExtracto[i];
            } else {
                estadoInfo = { estado: 'Pendiente' };
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            
            if (estadoActual === 'Pendiente') {
                pendientesExtracto++;
                if (pendientesExtracto <= 10) {
                    const fila = extractoProcesable[i];
                    const fecha = fila[0] || '';
                    const referencia = fila[1] || '';
                    const importe = this.normalizarMonto(fila[3] || '0');

                }
            }
        }

        // Analizar mayor pendientes
        let pendientesMayor = 0;
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            let estadoInfo;
            if (estadosFilas instanceof Map) {
                estadoInfo = estadosFilas.get(i);
            } else if (Array.isArray(estadosFilas)) {
                estadoInfo = estadosFilas[i];
            } else {
                estadoInfo = null;
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual === 'Pendiente') {
                const filaMayor = filasFiltradasMayor[i];
                const libro = (filaMayor[indicesMayor.libro] || '').toString();
                const debe = this.normalizarMonto(filaMayor[indicesMayor.debe] || '0');
                const haber = this.normalizarMonto(filaMayor[indicesMayor.haber] || '0');
                if (['02', '03', '09', '14', '15'].includes(libro) && (debe > 0 || haber > 0)) {
                    pendientesMayor++;
                    if (pendientesMayor <= 10) {
                        const fdoc = filaMayor[indicesMayor.fdoc] || '';
                        const comprob = filaMayor[indicesMayor.comprob] || '';
                    }
                }
            }
        }

        // Mostrar grupos formados
        gruposExtracto.forEach((grupoExtracto, criterioExtracto) => {
            grupoExtracto.registros.forEach(registro => {
            });
        });

        candidatosMayorSBPList.forEach((candidato, idx) => {
            if (idx < 10) {
            }
        });

        // ===== ETAPA ADICIONAL: LÓGICA DEL PASO 9B MIGRADA AL PASO 12 =====
        /*
        PASO 9B MIGRADO - OPERACIONES AGRUPADAS POR FECHA + MONTO TOTAL:
        
        ESTRATEGIA:
        1. MAYOR: Agrupar por FDOC y sumar TOTAL HABER (registros pendientes de libros 02, 03, 09, 14, 15)
        2. EXTRACTO: Agrupar por FECHA y sumar |Total importe| (valor absoluto)
        3. MAPEO: FDOC+TOTAL HABER (Mayor) vs FECHA+|Total importe| (Extracto)
        
        ESTADOS RESULTANTES:
        - "P12SBP-P9B - Conciliada"
        - Mayor: #REF = "GRUPO-P12SBP-P9B-[N]"
        - Extracto: #REF = "GRUPO-P12SBP-P9B-[N]"
        */
        

        
        let conciliadosP9B = 0;
        let gruposP9BMayor = 0;
        let gruposP9BExtracto = 0;
        
        // === 1. AGRUPAR EN MAYOR POR FDOC + HABER (SOLO PENDIENTES) ===
        const gruposMayorP9B = new Map();
        let filasPendientesMayorP9B = 0;
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            // Solo procesar filas pendientes (no procesadas en pasos anteriores)
            let estadoInfo;
            if (estadosFilas instanceof Map) {
                estadoInfo = estadosFilas.get(i);
            } else if (Array.isArray(estadosFilas)) {
                estadoInfo = estadosFilas[i];
            } else {
                estadoInfo = null;
            }
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') continue;
            
            filasPendientesMayorP9B++;
            
            const filaMayor = filasFiltradasMayor[i];
            const libro = (filaMayor[indicesMayor.libro] || '').toString();
            const fdoc = filaMayor[indicesMayor.fdoc] || '';
            const haber = this.normalizarMonto(filaMayor[indicesMayor.haber] || '0');
            const comprob = filaMayor[indicesMayor.comprob] || '';
            
            // Verificar criterios del PASO 9B (libros 02, 03, 09, 14, 15)
            const esLibroObjetivo = ['02', '03', '09', '14', '15'].includes(String(libro || '').trim());
            
            if (esLibroObjetivo && haber > 0) {
                // ⭐ AGRUPAR SOLO POR FDOC (sumar HABER)
                const fdocLimpio = String(fdoc || '').trim();
                const fechaNormalizada = this.normalizarFechaP9B(fdoc); // Usar formato DD/MM/YYYY
                const haberRedondeado = Math.round(haber * 100) / 100; // Redondear a 2 decimales
                const claveGrupo = fechaNormalizada; // Usar fecha normalizada como clave
                
                if (!gruposMayorP9B.has(claveGrupo)) {
                    gruposMayorP9B.set(claveGrupo, {
                        fdoc: fdocLimpio,
                        fdocOriginal: fdoc,
                        fechaNormalizada: fechaNormalizada,
                        haber: 0, // Inicializar en 0 para sumar
                        filas: []
                    });
                }
                
                const grupo = gruposMayorP9B.get(claveGrupo);
                grupo.haber += haberRedondeado; // Sumar HABER al grupo
                grupo.haber = Math.round(grupo.haber * 100) / 100; // Redondear resultado
                grupo.filas.push({
                    indice: i,
                    fila: filaMayor,
                    libro: libro,
                    comprob: comprob
                });
            }
        }
        

        gruposP9BMayor = gruposMayorP9B.size;
        
        // === 2. AGRUPAR EN EXTRACTO POR FECHA (SUMAR |MONTO| POR FECHA) ===
        const gruposExtractoP9B = new Map();
        let filasPendientesExtractoP9B = 0;
        
        for (let i = 0; i < extractoProcesable.length; i++) {
            // PASO 12 SBP-P9B: Procesar TODAS las filas del extracto (la lógica original del Paso 9B era independiente)
            // No filtrar por estado ya que el Paso 9B original procesaba todas las filas
            
            filasPendientesExtractoP9B++;
            
            const filaExtracto = extractoProcesable[i];
            
            if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
            
            // 🔧 DIAGNÓSTICO: Ver contenido real de filas SBP.USD
            if (cuentaConfig.alias === 'SBP.USD' && i < 3) {
            }
            
            const fechaExtractoRaw = filaExtracto[indicesExtracto.fecha] || '';
            const montoExtractoRaw = filaExtracto[indicesExtracto.monto] || '0';
            
            // Normalizar fecha y monto del extracto
            const fechaExtractoNormalizada = this.normalizarFechaP9B(fechaExtractoRaw);
            const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
            const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO
            const montoRedondeado = Math.round(montoExtracto * 100) / 100; // Redondear a 2 decimales
            
            if (fechaExtractoNormalizada && montoRedondeado > 0) {
                // ⭐ AGRUPAR SOLO POR FECHA (sumar montos)
                const claveGrupo = fechaExtractoNormalizada;
                
                if (!gruposExtractoP9B.has(claveGrupo)) {
                    gruposExtractoP9B.set(claveGrupo, {
                        fecha: fechaExtractoNormalizada,
                        fechaOriginal: fechaExtractoRaw,
                        totalImporte: 0, // Suma de todos los importes de esta fecha
                        filas: []
                    });
                }
                
                const grupo = gruposExtractoP9B.get(claveGrupo);
                grupo.totalImporte += montoRedondeado; // Sumar al total de la fecha
                grupo.totalImporte = Math.round(grupo.totalImporte * 100) / 100; // Redondear resultado
                grupo.filas.push({
                    indice: i,
                    fila: filaExtracto,
                    monto: montoRedondeado,
                    operacionNumero: filaExtracto[6] || '' // Columna G - Operación Número
                });
            }
        }
        

        gruposP9BExtracto = gruposExtractoP9B.size;
        
        // === 3. MAPEAR GRUPOS MAYOR VS EXTRACTO ===
        const monedaP9B = (cuentaConfig && (cuentaConfig.codigo === '1041506' || cuentaConfig.codigo === '1041302')) ? 'USD' : 'PEN';
        
        // Ordenar grupos por fecha antes del mapeo
        const gruposMayorOrdenadosP9B = Array.from(gruposMayorP9B.entries()).sort((a, b) => {
            return this.ordenarPorFechaP9B(a[1].fechaNormalizada, b[1].fechaNormalizada);
        });
        
        const gruposExtractoOrdenadosP9B = Array.from(gruposExtractoP9B.entries()).sort((a, b) => {
            return this.ordenarPorFechaP9B(a[0], b[0]);
        });
        
        // 📊 MOSTRAR SECCIONES SOLO PARA SBP USD (1041302)
        if (cuentaConfig && cuentaConfig.codigo === '1041302') {
            // 📊 SECCIÓN 1: GRUPOS MAYOR P9B
            let contadorMayorP9B = 1;
            for (const [claveMayor, grupoMayor] of gruposMayorOrdenadosP9B) {
                contadorMayorP9B++;
            }
            
            // 📊 SECCIÓN 2: GRUPOS EXTRACTO P9B
            let contadorExtractoP9B = 1;
            for (const [claveExtracto, grupoExtracto] of gruposExtractoOrdenadosP9B) {
                const fechaFormateada = grupoExtracto.fechaOriginal || claveExtracto;
                contadorExtractoP9B++;
            }
            
            // 📊 SECCIÓN 3: COMPARACIÓN FECHA/MAYOR/EXTRACTO P9B
        }
        
        let numeroGrupoP9B = 1;
        
        for (const [claveMayor, grupoMayor] of gruposMayorOrdenadosP9B) {
            // Usar la fecha ya normalizada en formato DD/MM/YYYY
            const fechaNormalizadaMayor = grupoMayor.fechaNormalizada;
            
            if (cuentaConfig && cuentaConfig.codigo === '1041302') {
            }
            
            // Buscar grupo correspondiente en extracto con fecha coincidente
            if (gruposExtractoP9B.has(fechaNormalizadaMayor)) {
                const grupoExtracto = gruposExtractoP9B.get(fechaNormalizadaMayor);
                const diferencia = Math.abs(grupoMayor.haber - grupoExtracto.totalImporte);
                
                if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                }
                
                // ⭐ VERIFICAR SI FDOC+TOTAL HABER (Mayor) = FECHA+|Total importe| (Extracto)
                if (diferencia < 0.01) { // Tolerancia de 1 centavo
                    if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                    }
                    
                    // ⭐ CONCILIAR GRUPOS
                    const refGrupoP9B = `GRUPO-P12SBP-P9B-${numeroGrupoP9B}`;
                    
                    // Marcar todas las filas del grupo Mayor como conciliadas
                    for (const item of grupoMayor.filas) {
                        if (estadosFilas instanceof Map) {
                            estadosFilas.set(item.indice, {
                                estado: 'P12SBP-P9B - Conciliada',
                                ref: refGrupoP9B
                            });
                        } else if (Array.isArray(estadosFilas)) {
                            estadosFilas[item.indice] = {
                                estado: 'P12SBP-P9B - Conciliada',
                                ref: refGrupoP9B
                            };
                        }
                    }
                    
                    // Marcar todas las filas del grupo Extracto como conciliadas
                    for (const item of grupoExtracto.filas) {
                        if (estadosExtracto instanceof Map) {
                            estadosExtracto.set(item.indice, {
                                estado: 'P12SBP-P9B - Conciliada',
                                ref: refGrupoP9B
                            });
                        } else if (Array.isArray(estadosExtracto)) {
                            estadosExtracto[item.indice] = {
                                estado: 'P12SBP-P9B - Conciliada',
                                ref: refGrupoP9B
                            };
                        }
                    }
                    
                    conciliadosP9B++;
                    numeroGrupoP9B++;
                    
                    // Eliminar grupo del extracto para evitar reutilización
                    gruposExtractoP9B.delete(fechaNormalizadaMayor);
                } else {
                    if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                    }
                }
            } else {
                if (cuentaConfig && cuentaConfig.codigo === '1041302') {
                }
            }
        }

        return {
            candidatos: candidatosExtractoSBP + candidatosMayorSBP,
            conciliados: conciliados + conciliadosP9B,
            conciliadosP9B: conciliadosP9B,
            gruposP9BMayor: gruposP9BMayor,
            gruposP9BExtracto: gruposP9BExtracto
        };
    },

    // === FUNCIÓN AUXILIAR PARA CONCILIAR GRUPOS SBP ===
    conciliarGrupoSBP: function(grupoExtracto, grupoMayor, estadosFilas, estadosExtracto, esUSD, criterioExtracto) {
        if (esUSD) {
            // USD: Conciliar registro individual
            const comprob = grupoMayor.fila[indicesMayor.comprob] || '';
            const libro = grupoMayor.fila[indicesMayor.libro] || '';

            // Marcar Mayor como conciliado
            if (estadosFilas instanceof Map) {
                estadosFilas.set(grupoMayor.indice, {
                    estado: 'P12SBP - Conciliada',
                    ref: `SBP-USD-${criterioExtracto}`
                });
            } else if (Array.isArray(estadosFilas)) {
                estadosFilas[grupoMayor.indice] = {
                    estado: 'P12SBP - Conciliada',
                    ref: `SBP-USD-${criterioExtracto}`
                };
            }

            // Marcar registros del extracto como conciliados
            grupoExtracto.indices.forEach(idxExtracto => {
                if (estadosExtracto instanceof Map) {
                    estadosExtracto.set(idxExtracto, {
                        estado: 'P12SBP - Conciliada',
                        ref: `${libro}-${comprob}`
                    });
                } else if (Array.isArray(estadosExtracto)) {
                    estadosExtracto[idxExtracto] = {
                        estado: 'P12SBP - Conciliada',
                        ref: `${libro}-${comprob}`
                    };
                }
            });

        } else {
            // PEN: Conciliar grupo completo
            const comprob = grupoMayor.registros[0].comprob || '';
            const libro = grupoMayor.registros[0].libro || '';

            // Marcar todos los registros del Mayor como conciliados
            grupoMayor.indices.forEach(indiceMayor => {
                if (estadosFilas instanceof Map) {
                    estadosFilas.set(indiceMayor, {
                        estado: 'P12SBP - Conciliada',
                        ref: `SBP-PEN-${criterioExtracto}`
                    });
                } else if (Array.isArray(estadosFilas)) {
                    estadosFilas[indiceMayor] = {
                        estado: 'P12SBP - Conciliada',
                        ref: `SBP-PEN-${criterioExtracto}`
                    };
                }
            });

            // Marcar registros del extracto como conciliados
            grupoExtracto.indices.forEach(idxExtracto => {
                if (estadosExtracto instanceof Map) {
                    estadosExtracto.set(idxExtracto, {
                        estado: 'P12SBP - Conciliada',
                        ref: `${libro}-${comprob}`
                    });
                } else if (Array.isArray(estadosExtracto)) {
                    estadosExtracto[idxExtracto] = {
                        estado: 'P12SBP - Conciliada',
                        ref: `${libro}-${comprob}`
                    };
                }
            });

        }
    },

    // === PASO 12 SBP USD AGRUPADO - NUEVA LÓGICA ESPECÍFICA PARA USD ===
    procesarPaso12SBPUSDAgrupado: function(datosMayor, datosExtracto, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig) {
        /*
        PASO 12 SBP USD AGRUPADO:
        
        ESTRATEGIA ESPECÍFICA PARA SBP USD (1041302):
        1. MAYOR: Agrupar por FECHA + sumar TOTAL HABER (registros pendientes)
        2. EXTRACTO: Agrupar por FECHA + sumar |Total importe| (valor absoluto)
        3. MAPEO: FECHA+TOTAL HABER (Mayor) vs FECHA+|Total importe| (Extracto)
        
        CRITERIOS:
        - Solo para cuenta SBP USD (1041302)
        - Procesar registros con estado "Pendiente"
        - Tolerancia de 0.01 para diferencias de monto
        
        ESTADOS RESULTANTES:
        - "P12SBP-USD-AGR - Conciliada"
        - Mayor: #REF = "GRUPO-USD-[FECHA]"
        - Extracto: #REF = "GRUPO-USD-[FECHA]"
        */
        
        if (!datosMayor || !Array.isArray(datosMayor) || datosMayor.length === 0) {
            return { candidatos: 0, grupos: 0, conciliados: 0 };
        }

        if (!datosExtracto || !Array.isArray(datosExtracto) || datosExtracto.length === 0) {
            return { candidatos: 0, grupos: 0, conciliados: 0 };
        }

        // Verificar que sea SBP USD
        if (!cuentaConfig || cuentaConfig.codigo !== '1041302') {
            return { candidatos: 0, grupos: 0, conciliados: 0 };
        }
        let gruposMayorFormados = 0;
        let gruposExtractoFormados = 0;
        let conciliados = 0;
        // === FASE 1: AGRUPAR MAYOR POR FECHA + SUMAR HABER ===
        const gruposMayor = new Map();
        
        for (let i = 0; i < datosMayor.length; i++) {
            // Solo procesar filas pendientes
            let estadoInfo;
            if (estadosFilas instanceof Map) {
                estadoInfo = estadosFilas.get(i);
            } else if (Array.isArray(estadosFilas)) {
                estadoInfo = estadosFilas[i];
            } else {
                estadoInfo = null;
            }
            
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') continue;

            const filaMayor = datosMayor[i];
            const fdoc = filaMayor[indicesMayor.fdoc] || '';
            const haber = this.normalizarMonto(filaMayor[indicesMayor.haber] || '0');
            const comprob = filaMayor[indicesMayor.comprob] || '';
            const libro = filaMayor[indicesMayor.libro] || '';
            
            if (haber <= 0) continue; // Solo procesar registros con HABER > 0
            
            const fechaNormalizada = this.normalizarFecha(fdoc);
            
            if (!gruposMayor.has(fechaNormalizada)) {
                gruposMayor.set(fechaNormalizada, {
                    fecha: fechaNormalizada,
                    totalHaber: 0,
                    registros: [],
                    indices: []
                });
                gruposMayorFormados++;
            }
            
            const grupo = gruposMayor.get(fechaNormalizada);
            grupo.totalHaber += haber;
            grupo.registros.push({
                indice: i,
                fdoc: fdoc,
                haber: haber,
                comprob: comprob,
                libro: libro
            });
            grupo.indices.push(i);
        }

        // === SECCIÓN 1: GRUPOS DEL MAYOR ===
        gruposMayor.forEach((grupo, fecha) => {
            grupo.registros.forEach(reg => {
            });
        });

        // === FASE 2: AGRUPAR EXTRACTO POR FECHA + SUMAR |IMPORTE| ===
        const gruposExtracto = new Map();
        // Mostrar headers del extracto para verificar mapeo
        if (datosExtracto.length > 0) {
        }
        
        let registrosPendientes = 0;
        let registrosConDatos = 0;
        
        for (let i = 0; i < datosExtracto.length; i++) {
            // Solo procesar filas pendientes
            let estadoInfo;
            if (estadosExtracto instanceof Map) {
                estadoInfo = estadosExtracto.get(i);
            } else if (Array.isArray(estadosExtracto)) {
                estadoInfo = estadosExtracto[i];
            } else {
                estadoInfo = null;
            }
            
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') {
                continue;
            }

            registrosPendientes++;

            const filaExtracto = datosExtracto[i];
            
            // Log completo de los primeros 3 registros pendientes para diagnóstico
            if (registrosPendientes <= 3) {
                if (filaExtracto.fila) {
                }
            }
            
            const fecha = (filaExtracto.fila && filaExtracto.fila[indicesExtracto.fecha]) || '';
            const importe = this.normalizarMonto((filaExtracto.fila && filaExtracto.fila[indicesExtracto.monto]) || '0');
            const referencia = (filaExtracto.fila && filaExtracto.fila[indicesExtracto.operacion]) || '';
            
            const fechaNormalizada = this.normalizarFecha(fecha);
            const importeAbsoluto = Math.abs(importe);
            if (importeAbsoluto <= 0) {
                continue; // Solo procesar registros con importe > 0
            }

            registrosConDatos++;
            
            if (!gruposExtracto.has(fechaNormalizada)) {
                gruposExtracto.set(fechaNormalizada, {
                    fecha: fechaNormalizada,
                    totalImporte: 0,
                    registros: [],
                    indices: []
                });
                gruposExtractoFormados++;
            }
            
            const grupo = gruposExtracto.get(fechaNormalizada);
            grupo.totalImporte += importeAbsoluto;
            grupo.registros.push({
                indice: i,
                fecha: fecha,
                importe: importe,
                referencia: referencia
            });
            grupo.indices.push(i);
        }

        // === RESUMEN DEL PROCESAMIENTO ===
        gruposExtracto.forEach((grupo, fecha) => {
            grupo.registros.forEach(reg => {
            });
        });

        // === FASE 3: MAPEAR GRUPOS MAYOR VS EXTRACTO ===
        let numeroGrupo = 1;
        
        gruposMayor.forEach((grupoMayor, fechaMayor) => {
            const grupoExtracto = gruposExtracto.get(fechaMayor);
            if (grupoExtracto) {
                const diferencia = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                
                if (diferencia < 0.01) {
                    const refGrupo = `GRUPO-USD-${fechaMayor}`;
                    
                    // Marcar todas las filas del grupo Mayor como conciliadas
                    grupoMayor.indices.forEach(indiceMayor => {
                        if (estadosFilas instanceof Map) {
                            estadosFilas.set(indiceMayor, {
                                estado: 'P12SBP-USD-AGR - Conciliada',
                                ref: refGrupo
                            });
                        } else if (Array.isArray(estadosFilas)) {
                            estadosFilas[indiceMayor] = {
                                estado: 'P12SBP-USD-AGR - Conciliada',
                                ref: refGrupo
                            };
                        }
                    });
                    
                    // Marcar todas las filas del grupo Extracto como conciliadas
                    grupoExtracto.indices.forEach(indiceExtracto => {
                        if (estadosExtracto instanceof Map) {
                            estadosExtracto.set(indiceExtracto, {
                                estado: 'P12SBP-USD-AGR - Conciliada',
                                ref: refGrupo
                            });
                        } else if (Array.isArray(estadosExtracto)) {
                            estadosExtracto[indiceExtracto] = {
                                estado: 'P12SBP-USD-AGR - Conciliada',
                                ref: refGrupo
                            };
                        }
                    });
                    
                    conciliados++;
                    numeroGrupo++;
                    
                    // Eliminar grupo del extracto para evitar reutilización
                    gruposExtracto.delete(fechaMayor);
                }
            } else {
            }
        });

        return {
            candidatos: gruposMayorFormados + gruposExtractoFormados,
            grupos: gruposMayorFormados,
            conciliados: conciliados
        };
    },

            // === FUNCIÓN PARA EXPORTAR ESTADOS DE CONCILIACIÓN ===
            async exportarEstadosConciliacion() {
                try {
                    this.showStatus('Procesando archivos para exportar estados...', 'success');
                    this.isLoading = true;

                    // Validar archivos
                    const validationResult = this.validateFiles();
                    if (!validationResult.isValid) {
                        this.showStatus(validationResult.message, 'error');
                        this.isLoading = false;
                        return;
                    }

                    // Cargar archivos igual que en la conciliación normal
                    const mayorFiles = this.files.filter(f => f.category === 'mayor');
                    const saldoFiles = this.files.filter(f => f.category === 'saldo');

                    const mayorFilePEN = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.pen'))?.file;
                    const mayorFileUSD = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.usd'))?.file;
                    const mayorFileGenerico = mayorFiles.find(f => !f.name.toLowerCase().includes('.pen') && !f.name.toLowerCase().includes('.usd'))?.file;
                    const saldoFile = saldoFiles.length > 0 ? saldoFiles[0].file : null;

                    const mayorFile = mayorFilePEN || mayorFileGenerico;

                    if (!mayorFile) {
                        this.showStatus('Se requiere al menos un archivo MAYOR para exportar estados', 'error');
                        this.isLoading = false;
                        return;
                    }

                    // Procesar extractos por cuenta
                    const extractoFiles = this.files.filter(f => f.category === 'extracto');
                    const extractosPorCuenta = new Map();

                    for (const extractoFileObj of extractoFiles) {
                        const cuentaConfig = this.detectarCuentaPorArchivo(extractoFileObj.name);
                        if (cuentaConfig && cuentaConfig.activo) {
                            const datosExtracto = await this.readExcelFile(extractoFileObj.file, cuentaConfig);
                            extractosPorCuenta.set(cuentaConfig.codigoCuenta, {
                                config: cuentaConfig,
                                datos: datosExtracto,
                                datosExtracto: datosExtracto
                            });
                        }
                    }

                    // Cargar datos
                    const mayorDataPEN = await this.readExcelFile(mayorFile);
                    let mayorDataUSD = null;
                    if (mayorFileUSD) {
                        mayorDataUSD = await this.readExcelFile(mayorFileUSD);
                    }

                    const saldoData = saldoFile ? await this.readExcelFile(saldoFile) : null;

                    // Procesar conciliación
                    const resultado = this.procesarConciliacionMultiCuenta(extractosPorCuenta, mayorDataPEN, saldoData, mayorDataUSD);

                    if (!resultado || !resultado.datosMayor || resultado.datosMayor.length === 0) {
                        throw new Error('No se generaron datos de conciliación');
                    }

                    // Generar archivo Excel con estados (igual que conciliador estados.html)
                    const fileName = `estados_conciliacion_${new Date().toISOString().split('T')[0]}.xlsx`;
                    this.generateExcelFile(resultado, fileName);

                    this.showStatus('Estados de conciliación exportados exitosamente', 'success');

                } catch (error) {
                    this.showStatus(`Error al exportar estados: ${error.message}`, 'error');
                } finally {
                    this.isLoading = false;
                }
            },

            // === FUNCIÓN PARA EXPORTAR RELACIÓN DE CUENTAS ===
            async exportarRelacionCuentas() {
                try {
                    this.showStatus('Generando relación de cuentas...', 'success');
                    this.isLoading = true;

                    // Obtener todas las cuentas configuradas
                    const todasLasCuentas = Object.values(this.cuentasConfig);
                    
                    // Separar por moneda
                    const cuentasPEN = todasLasCuentas.filter(cuenta => cuenta.moneda === 'PEN');
                    const cuentasUSD = todasLasCuentas.filter(cuenta => cuenta.moneda === 'USD');

                    // Crear datos para Excel
                    const datosExcel = [];
                    
                    // Header principal
                    datosExcel.push(['RELACIÓN DE CUENTAS BANCARIAS']);
                    datosExcel.push(['Generado el:', new Date().toLocaleDateString('es-PE')]);
                    datosExcel.push([]); // Fila vacía

                    // Sección SOLES
                    datosExcel.push(['CUENTAS EN SOLES (PEN)']);
                    datosExcel.push(['Código Cuenta', 'Banco', 'Alias', 'Estado', 'Patrón Archivo', 'Pestaña Excel']);
                    
                    cuentasPEN.forEach(cuenta => {
                        datosExcel.push([
                            cuenta.codigoCuenta,
                            cuenta.banco,
                            cuenta.alias,
                            cuenta.activo ? 'ACTIVA' : 'INACTIVA',
                            cuenta.archivoPattern ? cuenta.archivoPattern.source : 'N/A',
                            cuenta.pestañaExcel
                        ]);
                    });

                    datosExcel.push([]); // Fila vacía

                    // Sección DÓLARES
                    datosExcel.push(['CUENTAS EN DÓLARES (USD)']);
                    datosExcel.push(['Código Cuenta', 'Banco', 'Alias', 'Estado', 'Patrón Archivo', 'Pestaña Excel']);
                    
                    cuentasUSD.forEach(cuenta => {
                        datosExcel.push([
                            cuenta.codigoCuenta,
                            cuenta.banco,
                            cuenta.alias,
                            cuenta.activo ? 'ACTIVA' : 'INACTIVA',
                            cuenta.archivoPattern ? cuenta.archivoPattern.source : 'N/A',
                            cuenta.pestañaExcel
                        ]);
                    });

                    datosExcel.push([]); // Fila vacía

                    datosExcel.push(['RESUMEN']);
                    datosExcel.push(['Total cuentas PEN:', cuentasPEN.length]);
                    datosExcel.push(['Total cuentas USD:', cuentasUSD.length]);
                    datosExcel.push(['Total cuentas activas PEN:', cuentasPEN.filter(c => c.activo).length]);
                    datosExcel.push(['Total cuentas activas USD:', cuentasUSD.filter(c => c.activo).length]);
                    datosExcel.push(['Total general:', todasLasCuentas.length]);

                    // Crear workbook
                    const wb = XLSX.utils.book_new();
                    const ws = XLSX.utils.aoa_to_sheet(datosExcel);
                    XLSX.utils.book_append_sheet(wb, ws, "Relación Cuentas");

                    // Generar archivo
                    const fileName = `relacion_cuentas_${new Date().toISOString().split('T')[0]}.xlsx`;
                    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                    const blob = new Blob([wbout], { type: 'application/octet-stream' });
                    const url = window.URL.createObjectURL(blob);

                    // Crear enlace de descarga
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    this.showStatus('Relación de cuentas exportada exitosamente', 'success');

                } catch (error) {
                    this.showStatus(`Error al exportar relación de cuentas: ${error.message}`, 'error');
                } finally {
                    this.isLoading = false;
                }
            },

            // === FUNCIÓN PARA LIMPIAR ARCHIVOS ===
            limpiarArchivos() {
                try {
                    // Limpiar array de archivos
                    this.files = [];
                    
                    // Limpiar localStorage
                    localStorage.removeItem('bancarioConciliador_files');
                    
                    // Limpiar cache de datos manuales
                    this.limpiarCacheDatosManuales();
                    
                    // Resetear valores manuales a defaults
                    this.saldoDET = 0;
                    this.saldoBN = 0;
                    this.tipoCambio = 3.75;
                    
                    // Limpiar resultados de conciliación
                    this.conciliationResult = null;
                    
                    // Limpiar mensajes de estado
                    this.statusMessage = { show: false, text: '', type: 'success' };
                    
                    // Resetear estado de carga
                    this.isLoading = false;
                    
                    this.showStatus('Archivos limpiados exitosamente', 'success');
                    
                } catch (error) {
                    this.showStatus('Error al limpiar archivos', 'error');
                }
            },

            async procesarArchivoLibros(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            
                            
                            // Buscar la pestaña "104 - Mayor General SOLES" o usar la primera
                            let sheetName = workbook.SheetNames.find(name => 
                                name.includes('104') && name.includes('Mayor') && name.includes('SOLES')
                            ) || workbook.SheetNames[0];
                            
                            const worksheet = workbook.Sheets[sheetName];
                            
                            // EXPANDIDO: Leer todo el rango de datos disponible, no solo A8:F20
                            const fullRange = worksheet['!ref'] ? XLSX.utils.decode_range(worksheet['!ref']) : null;
                            
                            if (!fullRange) {
                                resolve(new Map());
                                return;
                            }
                            // Leer todos los datos disponibles
                            const jsonData = [];
                            
                            for (let R = fullRange.s.r; R <= fullRange.e.r; ++R) {
                                const row = [];
                                for (let C = fullRange.s.c; C <= fullRange.e.c; ++C) {
                                    const cellAddress = XLSX.utils.encode_cell({c: C, r: R});
                                    const cell = worksheet[cellAddress];
                                    row.push(cell ? cell.v : undefined);
                                }
                                jsonData.push(row);
                            }
                            const saldosLibros = new Map();
                            
                            // MEJORADO: Buscar automáticamente las columnas de saldos
                            // Buscar fila de headers que contenga "CUENTA" y "SALDO" o similar
                            let headerRowIndex = -1;
                            let cuentaColIndex = -1;
                            let saldoColIndex = -1;
                            
                            for (let i = 0; i < Math.min(jsonData.length, 20); i++) { // Buscar en las primeras 20 filas
                                const fila = jsonData[i];
                                if (fila && Array.isArray(fila)) {
                                    for (let j = 0; j < fila.length; j++) {
                                        const celda = fila[j];
                                        if (celda && typeof celda === 'string') {
                                            const celdaUpper = celda.toString().toUpperCase();
                                            if (celdaUpper.includes('CUENTA') && cuentaColIndex === -1) {
                                                headerRowIndex = i;
                                                cuentaColIndex = j;
                                            }
                                            if ((celdaUpper.includes('SALDO') || celdaUpper.includes('TOTAL')) && saldoColIndex === -1) {
                                                saldoColIndex = j;
                                            }
                                        }
                                    }
                                    if (cuentaColIndex !== -1 && saldoColIndex !== -1) {
                                        break;
                                    }
                                }
                            }
                            // Si no encontramos headers automáticamente, usar posiciones por defecto
                            if (headerRowIndex === -1 || cuentaColIndex === -1 || saldoColIndex === -1) {
                                headerRowIndex = 7; // Fila 8 en Excel (índice 7)
                                cuentaColIndex = 0; // Columna A
                                saldoColIndex = 5;  // Columna F
                            }
                            
                            // Procesar filas de datos a partir del header
                            let cuentasProcesadas = 0;
                            const startRow = headerRowIndex + 1;
                            
                            for (let i = startRow; i < jsonData.length; i++) {
                                const fila = jsonData[i];
                                const filaExcel = i + 1; // Fila real en Excel
                                
                                if (fila && fila.length > Math.max(cuentaColIndex, saldoColIndex)) {
                                    const cuenta = fila[cuentaColIndex];
                                    const saldo = fila[saldoColIndex];
                                    
                                    // Verificar si la cuenta es válida (no vacía y parece número de cuenta)
                                    if (cuenta !== undefined && cuenta !== null && cuenta !== '') {
                                        const cuentaStr = String(cuenta).trim();
                                        const esNumCuenta = /^104\d+$/.test(cuentaStr);
                                        
                                        if (esNumCuenta && saldo !== undefined && saldo !== null && saldo !== '') {
                                            // Convertir saldo a número
                                            let saldoNum = 0;
                                            if (typeof saldo === 'number') {
                                                saldoNum = saldo;
                                            } else {
                                                // Limpiar el saldo de comas y convertir
                                                const saldoLimpio = String(saldo).replace(/,/g, '');
                                                saldoNum = parseFloat(saldoLimpio) || 0;
                                            }
                                            
                                            saldosLibros.set(cuentaStr, saldoNum);
                                            cuentasProcesadas++;
                                        }
                                    }
                                }
                            }
                            resolve(saldosLibros);
                            
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    reader.onerror = function(error) {
                        reject(error);
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            },

                        // === FUNCIÓN PARA LEER SALDO DE EXTRACTOS BANCARIOS ===
            async leerSaldoExtracto(file, cuentaCodigo) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const sheetName = workbook.SheetNames[0]; // Primera hoja
                            const worksheet = workbook.Sheets[sheetName];
                            
                            let saldo = null;
                            
                            // Determinar celda según el banco
                            if (cuentaCodigo.startsWith('1041501') || cuentaCodigo.startsWith('1041505') || cuentaCodigo.startsWith('1041502')) {
                                // BCP: Celda E6
                                const cellE6 = worksheet['E6'];
                                if (cellE6 && cellE6.v !== undefined) {
                                    saldo = cellE6.v;
                                }
                            } else if (cuentaCodigo.startsWith('1041401') || cuentaCodigo.startsWith('1041402')) {
                                // SANTANDER: Celda B5
                                const cellB5 = worksheet['B5'];
                                if (cellB5 && cellB5.v !== undefined) {
                                    saldo = cellB5.v;
                                }
                            } else if (cuentaCodigo.startsWith('1041201') || cuentaCodigo.startsWith('1041202')) {
                                // BBVA: Última fila con datos en columna F
                                
                                const range = XLSX.utils.decode_range(worksheet['!ref']);
                                
                                let filasRevisadas = 0;
                                for (let row = range.e.r; row >= range.s.r; row--) {
                                    filasRevisadas++;
                                    const cellAddress = XLSX.utils.encode_cell({c: 5, r: row}); // Columna F (índice 5)
                                    const cell = worksheet[cellAddress];
                                    
                                    if (cell && cell.v !== undefined && cell.v !== null && cell.v !== '') {
                                        saldo = cell.v;
                                        break;
                                    }
                                    
                                    if (filasRevisadas > 20) {
                                        break;
                                    }
                                }
                                
                                if (saldo === null) {
                                }
                            } else if (cuentaCodigo.startsWith('1041301') || cuentaCodigo.startsWith('1041302')) {
                                // SCOTIABANK: Celda A5 - extraer saldo contable
                                
                                const cellA5 = worksheet['A5'];
                                
                                if (cellA5 && cellA5.v !== undefined) {
                                    const texto = String(cellA5.v);
                                    
                                    // Buscar patrón "Saldo Contable: S/ xxx,xxx.xx" o "Saldo Contable: $ xxx,xxx.xx"
                                    const match = texto.match(/Saldo Contable:\s*[S\/\$]\s*([\d,]+\.?\d*)/);
                                    
                                    if (match) {
                                        
                                        const saldoTexto = match[1].replace(/,/g, '');
                                        
                                        saldo = parseFloat(saldoTexto) || 0;
                                    } else {
                                        
                                        // Usar el patrón alternativo que SÍ funciona
                                        const altMatch1 = texto.match(/Saldo.*?[S\/\$]\s*([\d,]+\.?\d*)/i);
                                        
                                        if (altMatch1) {
                                            const saldoTexto = altMatch1[1].replace(/,/g, '');
                                            saldo = parseFloat(saldoTexto) || 0;
                                        }
                                    }
                                } else {
                                }
                            } else if (cuentaCodigo.startsWith('1041101') || cuentaCodigo.startsWith('1041102')) {
                                // INTERBANK: Celda J10
                                
                                const cellJ10 = worksheet['J10'];
                                
                                if (cellJ10 && cellJ10.v !== undefined) {
                                    saldo = cellJ10.v;
                                } else {
                                    
                                    // Verificar celdas cercanas por si acaso
                                    const cellsToCheck = ['I10', 'K10', 'J9', 'J11', 'J8', 'J12'];
                                    cellsToCheck.forEach(cellAddr => {
                                        const cell = worksheet[cellAddr];
                                    });
                                }
                            }
                            
                            // Convertir a número si es necesario
                            if (saldo !== null && typeof saldo === 'string') {
                                saldo = parseFloat(saldo.replace(/,/g, '')) || 0;
                            }
                            
                            resolve(saldo);
                            
                        } catch (error) {
                            resolve(null);
                        }
                    };
                    
                    reader.onerror = function(error) {
                        resolve(null);
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            },

            // === FUNCIÓN PARA OBTENER SALDO DE LIBROS ===
            getSaldoLibros(cuenta) {
                // Consultando saldo
                if (!this.conciliationResult || !this.conciliationResult.saldosLibros) {
                    return '—';
                }
                
                const saldo = this.conciliationResult.saldosLibros.get(cuenta);
                if (saldo !== undefined && saldo !== null) {
                    const formatted = new Intl.NumberFormat('es-PE', {
                        style: 'currency',
                        currency: 'PEN',
                        minimumFractionDigits: 2
                    }).format(saldo);
                    // Saldo formateado
                    return formatted;
                }
                // No se encontró saldo
                return '—';
            },

            // === FUNCIÓN PARA OBTENER SALDO DE EXTRACTOS (USD/PEN) ===
            getSaldoExtracto(cuenta) {
                // Consultando saldo extracto
                if (!this.conciliationResult || !this.conciliationResult.saldosExtractos) {
                    return '—';
                }
                
                const saldo = this.conciliationResult.saldosExtractos.get(cuenta);
                if (saldo !== undefined && saldo !== null) {
                    // Determinar si es cuenta USD o PEN
                    const cuentasUSD = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                    const esUSD = cuentasUSD.includes(cuenta);
                    
                    const formatted = new Intl.NumberFormat('es-PE', {
                        style: 'currency',
                        currency: esUSD ? 'USD' : 'PEN',
                        minimumFractionDigits: 2
                    }).format(saldo);
                    // Saldo extracto formateado
                    return formatted;
                }
                // No se encontró saldo extracto
                return '—';
            },

            // === FUNCIÓN PARA CALCULAR EQUIVALENTE EN PEN DE CUENTAS USD ===
            getSaldoExtractoPEN(cuenta) {
                // Calculando equivalente PEN
                
                if (!this.conciliationResult || !this.conciliationResult.saldosExtractos) {
                    return '—';
                }
                
                const saldoUSD = this.conciliationResult.saldosExtractos.get(cuenta);
                
                if (saldoUSD === undefined || saldoUSD === null || this.tipoCambio <= 0) {
                    // Saldo USD no disponible
                    return '—';
                }
                
                const equivalentePEN = saldoUSD * this.tipoCambio;
                // Cálculo de equivalente PEN
                
                const formatted = new Intl.NumberFormat('es-PE', {
                    style: 'currency',
                    currency: 'PEN',
                    minimumFractionDigits: 2
                }).format(equivalentePEN);
                
                return formatted;
            },

            // === FUNCIÓN PARA APLICAR FORMATO DE NÚMEROS A HOJAS DE EXCEL ===
            aplicarFormatoNumeros(worksheet, columnasIndices) {
                try {
                    // DEBUG: Verificar configuración actual de columnas
                    //console.log('🔧 [FORMATO] Aplicando formato numFmt a columnas:', columnasIndices);
                    
                    // Aplicar formato de número usando numFmt a las columnas especificadas
                    columnasIndices.forEach(colIndex => {
                        const colLetter = String.fromCharCode(65 + colIndex);
                        
                        // Usar getColumn() para aplicar formato directamente
                        if (worksheet.getColumn) {
                            worksheet.getColumn(colIndex).numFmt = '#,##0.00';
                            //console.log(`🔧 [FORMATO] Aplicado formato #,##0.00 a columna ${colIndex} (${colLetter}) usando getColumn()`);
                        } else {
                            // Fallback: usar configuración manual de columnas
                            if (!worksheet['!cols']) {
                                worksheet['!cols'] = [];
                            }
                            if (!worksheet['!cols'][colIndex]) {
                                worksheet['!cols'][colIndex] = {};
                            }
                            worksheet['!cols'][colIndex].numFmt = '#,##0.00';
                            //console.log(`🔧 [FORMATO] Aplicado formato #,##0.00 a columna ${colIndex} (${colLetter}) usando !cols`);
                        }
                    });
                    
                    //console.log('🔧 [FORMATO] Aplicado formato #,##0.00 a columnas:', columnasIndices);
                    
                } catch (error) {
                    //console.error('❌ [FORMATO] Error aplicando formato:', error);
                }
            }
        }; // cierre del objeto return
    } // cierre de la función bancarioConciliador
</script>

        <!-- Tabla de Cuentas -->
</div>
</body>

</html>


